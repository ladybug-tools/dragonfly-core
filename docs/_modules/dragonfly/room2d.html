<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dragonfly.room2d &#8212; dragonfly-core  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css?v=0bf093e7" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=0b9525ea" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<link rel="icon" type="image/x-icon" href="https://github.com/ladybug-tools/artwork/raw/refs/heads/master/icons_bugs/ico/dragonfly.ico">
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-inverse navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          dragonfly-core</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../cli/index.html">CLI Docs</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../cli/index.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cli/index.html#commands">Commands</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../cli/translate.html">translate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cli/translate.html#dragonfly-translate">dragonfly translate</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../cli/translate.html#dragonfly-translate-merge-models-to-honeybee">merge-models-to-honeybee</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/translate.html#dragonfly-translate-model-to-honeybee">model-to-honeybee</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/translate.html#dragonfly-translate-model-to-honeybee-file">model-to-honeybee-file</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../cli/validate.html">validate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cli/validate.html#dragonfly-validate">dragonfly validate</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../cli/validate.html#dragonfly-validate-model">model</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/validate.html#dragonfly-validate-room-collisions">room-collisions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../cli/create.html">create</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cli/create.html#dragonfly-create">dragonfly create</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../cli/create.html#dragonfly-create-from-geojson">from-geojson</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/create.html#dragonfly-create-from-honeybee">from-honeybee</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/create.html#dragonfly-create-merge-models">merge-models</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../cli/edit.html">edit</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit">dragonfly edit</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-align">align</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-convert-units">convert-units</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-remove-short-segments">remove-short-segments</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-reset-room-boundaries">reset-room-boundaries</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-solve-adjacency">solve-adjacency</a></li>
<li class="toctree-l5"><a class="reference internal" href="../../cli/edit.html#dragonfly-edit-windows-by-ratio">windows-by-ratio</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">dragonfly</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../dragonfly.html">dragonfly package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../dragonfly.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.cli.html">dragonfly.cli package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.cli.html#submodules">Submodules</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.cli.create.html">dragonfly.cli.create module</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../dragonfly.cli.create.html#dragonfly.cli.create.from_geojson"><code class="docutils literal notranslate"><span class="pre">from_geojson()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../dragonfly.cli.create.html#dragonfly.cli.create.from_honeybee"><code class="docutils literal notranslate"><span class="pre">from_honeybee()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../dragonfly.cli.create.html#dragonfly.cli.create.merge_models"><code class="docutils literal notranslate"><span class="pre">merge_models()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.cli.edit.html">dragonfly.cli.edit module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.cli.translate.html">dragonfly.cli.translate module</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../dragonfly.cli.translate.html#dragonfly.cli.translate.merge_models_to_honeybee"><code class="docutils literal notranslate"><span class="pre">merge_models_to_honeybee()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../dragonfly.cli.translate.html#dragonfly.cli.translate.model_to_honeybee"><code class="docutils literal notranslate"><span class="pre">model_to_honeybee()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../dragonfly.cli.translate.html#dragonfly.cli.translate.model_to_honeybee_file"><code class="docutils literal notranslate"><span class="pre">model_to_honeybee_file()</span></code></a></li>
</ul>
</li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.cli.validate.html">dragonfly.cli.validate module</a><ul>
<li class="toctree-l7"><a class="reference internal" href="../../dragonfly.cli.validate.html#dragonfly.cli.validate.validate_model"><code class="docutils literal notranslate"><span class="pre">validate_model()</span></code></a></li>
<li class="toctree-l7"><a class="reference internal" href="../../dragonfly.cli.validate.html#dragonfly.cli.validate.validate_room_collisions"><code class="docutils literal notranslate"><span class="pre">validate_room_collisions()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.cli.html#module-dragonfly.cli">Module contents</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.writer.html">dragonfly.writer package</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.writer.html#submodules">Submodules</a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.building.html">dragonfly.writer.building module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.context.html">dragonfly.writer.context module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.model.html">dragonfly.writer.model module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.room2d.html">dragonfly.writer.room2d module</a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.writer.story.html">dragonfly.writer.story module</a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.writer.html#module-dragonfly.writer">Module contents</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../dragonfly.html#submodules">Submodules</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.building.html">dragonfly.building module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building"><code class="docutils literal notranslate"><span class="pre">Building</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.add_prefix"><code class="docutils literal notranslate"><span class="pre">add_prefix()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.add_roof_geometry"><code class="docutils literal notranslate"><span class="pre">add_roof_geometry()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.add_room_3ds"><code class="docutils literal notranslate"><span class="pre">add_room_3ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.add_stories"><code class="docutils literal notranslate"><span class="pre">add_stories()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.all_room_2ds"><code class="docutils literal notranslate"><span class="pre">all_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.all_stories"><code class="docutils literal notranslate"><span class="pre">all_stories()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.automatically_zone"><code class="docutils literal notranslate"><span class="pre">automatically_zone()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.buildings_to_honeybee"><code class="docutils literal notranslate"><span class="pre">buildings_to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.check_collisions_between_stories"><code class="docutils literal notranslate"><span class="pre">check_collisions_between_stories()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.convert_all_room_3ds_to_2d"><code class="docutils literal notranslate"><span class="pre">convert_all_room_3ds_to_2d()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.convert_multipliers_to_stories"><code class="docutils literal notranslate"><span class="pre">convert_multipliers_to_stories()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.convert_plenum_depths_to_room_2ds"><code class="docutils literal notranslate"><span class="pre">convert_plenum_depths_to_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.convert_room_3d_to_2d"><code class="docutils literal notranslate"><span class="pre">convert_room_3d_to_2d()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.convert_room_3ds_to_2d"><code class="docutils literal notranslate"><span class="pre">convert_room_3ds_to_2d()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.district_to_honeybee"><code class="docutils literal notranslate"><span class="pre">district_to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.find_adjacency_gaps"><code class="docutils literal notranslate"><span class="pre">find_adjacency_gaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.footprint"><code class="docutils literal notranslate"><span class="pre">footprint()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.from_all_story_geometry"><code class="docutils literal notranslate"><span class="pre">from_all_story_geometry()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.from_footprint"><code class="docutils literal notranslate"><span class="pre">from_footprint()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.from_honeybee"><code class="docutils literal notranslate"><span class="pre">from_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.has_floors_ceilings"><code class="docutils literal notranslate"><span class="pre">has_floors_ceilings()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.make_basement_stories"><code class="docutils literal notranslate"><span class="pre">make_basement_stories()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.match_and_replace_room_2d_floor_geometry"><code class="docutils literal notranslate"><span class="pre">match_and_replace_room_2d_floor_geometry()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.process_alleys"><code class="docutils literal notranslate"><span class="pre">process_alleys()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.remove_duplicate_roofs"><code class="docutils literal notranslate"><span class="pre">remove_duplicate_roofs()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.remove_stories_by_identifier"><code class="docutils literal notranslate"><span class="pre">remove_stories_by_identifier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_2ds_by_display_name"><code class="docutils literal notranslate"><span class="pre">room_2ds_by_display_name()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_3ds_by_display_name"><code class="docutils literal notranslate"><span class="pre">room_3ds_by_display_name()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_3ds_by_story"><code class="docutils literal notranslate"><span class="pre">room_3ds_by_story()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.separate_mid_floors"><code class="docutils literal notranslate"><span class="pre">separate_mid_floors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.separate_room_2d_plenums"><code class="docutils literal notranslate"><span class="pre">separate_room_2d_plenums()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.separate_top_bottom_floors"><code class="docutils literal notranslate"><span class="pre">separate_top_bottom_floors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.set_outdoor_shading_parameters"><code class="docutils literal notranslate"><span class="pre">set_outdoor_shading_parameters()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.set_outdoor_window_parameters"><code class="docutils literal notranslate"><span class="pre">set_outdoor_window_parameters()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.shade_representation"><code class="docutils literal notranslate"><span class="pre">shade_representation()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.sort_stories"><code class="docutils literal notranslate"><span class="pre">sort_stories()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.split_room_2d_vertically"><code class="docutils literal notranslate"><span class="pre">split_room_2d_vertically()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.stories_by_display_name"><code class="docutils literal notranslate"><span class="pre">stories_by_display_name()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.stories_by_identifier"><code class="docutils literal notranslate"><span class="pre">stories_by_identifier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.stories_to_honeybee"><code class="docutils literal notranslate"><span class="pre">stories_to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.suggested_alignment_axes"><code class="docutils literal notranslate"><span class="pre">suggested_alignment_axes()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.to_honeybee"><code class="docutils literal notranslate"><span class="pre">to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.display_name"><code class="docutils literal notranslate"><span class="pre">display_name</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.exterior_aperture_area"><code class="docutils literal notranslate"><span class="pre">exterior_aperture_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.exterior_wall_area"><code class="docutils literal notranslate"><span class="pre">exterior_wall_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.floor_area"><code class="docutils literal notranslate"><span class="pre">floor_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.footprint_area"><code class="docutils literal notranslate"><span class="pre">footprint_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.full_id"><code class="docutils literal notranslate"><span class="pre">full_id</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.has_room_2d_plenums"><code class="docutils literal notranslate"><span class="pre">has_room_2d_plenums</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.has_room_2ds"><code class="docutils literal notranslate"><span class="pre">has_room_2ds</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.has_room_3ds"><code class="docutils literal notranslate"><span class="pre">has_room_3ds</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.has_zones"><code class="docutils literal notranslate"><span class="pre">has_zones</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.height"><code class="docutils literal notranslate"><span class="pre">height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.height_above_ground"><code class="docutils literal notranslate"><span class="pre">height_above_ground</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.height_from_first_floor"><code class="docutils literal notranslate"><span class="pre">height_from_first_floor</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.identifier"><code class="docutils literal notranslate"><span class="pre">identifier</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.max"><code class="docutils literal notranslate"><span class="pre">max</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.min"><code class="docutils literal notranslate"><span class="pre">min</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.properties"><code class="docutils literal notranslate"><span class="pre">properties</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_2d_story_names"><code class="docutils literal notranslate"><span class="pre">room_2d_story_names</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_3d_apertures"><code class="docutils literal notranslate"><span class="pre">room_3d_apertures</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_3d_doors"><code class="docutils literal notranslate"><span class="pre">room_3d_doors</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_3d_faces"><code class="docutils literal notranslate"><span class="pre">room_3d_faces</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_3d_shades"><code class="docutils literal notranslate"><span class="pre">room_3d_shades</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_3d_story_names"><code class="docutils literal notranslate"><span class="pre">room_3d_story_names</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.room_3ds"><code class="docutils literal notranslate"><span class="pre">room_3ds</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.story_count"><code class="docutils literal notranslate"><span class="pre">story_count</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.story_count_above_ground"><code class="docutils literal notranslate"><span class="pre">story_count_above_ground</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.to"><code class="docutils literal notranslate"><span class="pre">to</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.unique_room_2ds"><code class="docutils literal notranslate"><span class="pre">unique_room_2ds</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.unique_stories"><code class="docutils literal notranslate"><span class="pre">unique_stories</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.unique_stories_above_ground"><code class="docutils literal notranslate"><span class="pre">unique_stories_above_ground</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.volume"><code class="docutils literal notranslate"><span class="pre">volume</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.building.html#dragonfly.building.Building.zone_dict"><code class="docutils literal notranslate"><span class="pre">zone_dict</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.colorobj.html">dragonfly.colorobj module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D"><code class="docutils literal notranslate"><span class="pre">ColorRoom2D</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.attr_name"><code class="docutils literal notranslate"><span class="pre">attr_name</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.attr_name_end"><code class="docutils literal notranslate"><span class="pre">attr_name_end</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.attributes"><code class="docutils literal notranslate"><span class="pre">attributes</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.attributes_original"><code class="docutils literal notranslate"><span class="pre">attributes_original</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.attributes_unique"><code class="docutils literal notranslate"><span class="pre">attributes_unique</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.floor_faces"><code class="docutils literal notranslate"><span class="pre">floor_faces</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.graphic_container"><code class="docutils literal notranslate"><span class="pre">graphic_container</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.legend_parameters"><code class="docutils literal notranslate"><span class="pre">legend_parameters</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.max_point"><code class="docutils literal notranslate"><span class="pre">max_point</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.min_point"><code class="docutils literal notranslate"><span class="pre">min_point</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.colorobj.html#dragonfly.colorobj.ColorRoom2D.room_2ds"><code class="docutils literal notranslate"><span class="pre">room_2ds</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.config.html">dragonfly.config module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.config.html#dragonfly.config.Folders"><code class="docutils literal notranslate"><span class="pre">Folders</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.config.html#dragonfly.config.Folders.dragonfly_core_version"><code class="docutils literal notranslate"><span class="pre">dragonfly_core_version</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.config.html#dragonfly.config.Folders.dragonfly_core_version_str"><code class="docutils literal notranslate"><span class="pre">dragonfly_core_version_str</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.config.html#dragonfly.config.Folders.dragonfly_schema_version"><code class="docutils literal notranslate"><span class="pre">dragonfly_schema_version</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.config.html#dragonfly.config.Folders.dragonfly_schema_version_str"><code class="docutils literal notranslate"><span class="pre">dragonfly_schema_version_str</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.config.html#dragonfly.config.Folders.python_package_path"><code class="docutils literal notranslate"><span class="pre">python_package_path</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.context.html">dragonfly.context module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade"><code class="docutils literal notranslate"><span class="pre">ContextShade</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.add_prefix"><code class="docutils literal notranslate"><span class="pre">add_prefix()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.align"><code class="docutils literal notranslate"><span class="pre">align()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.apply_vertex_map"><code class="docutils literal notranslate"><span class="pre">apply_vertex_map()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.from_honeybee"><code class="docutils literal notranslate"><span class="pre">from_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.is_conforming"><code class="docutils literal notranslate"><span class="pre">is_conforming()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.snap_to_grid"><code class="docutils literal notranslate"><span class="pre">snap_to_grid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.to_honeybee"><code class="docutils literal notranslate"><span class="pre">to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.unconforming_vertex_map"><code class="docutils literal notranslate"><span class="pre">unconforming_vertex_map()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.area"><code class="docutils literal notranslate"><span class="pre">area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.display_name"><code class="docutils literal notranslate"><span class="pre">display_name</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.full_id"><code class="docutils literal notranslate"><span class="pre">full_id</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.geometry"><code class="docutils literal notranslate"><span class="pre">geometry</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.identifier"><code class="docutils literal notranslate"><span class="pre">identifier</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.is_detached"><code class="docutils literal notranslate"><span class="pre">is_detached</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.max"><code class="docutils literal notranslate"><span class="pre">max</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.min"><code class="docutils literal notranslate"><span class="pre">min</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.properties"><code class="docutils literal notranslate"><span class="pre">properties</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.to"><code class="docutils literal notranslate"><span class="pre">to</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.context.html#dragonfly.context.ContextShade.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.dictutil.html">dragonfly.dictutil module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.dictutil.html#dragonfly.dictutil.dict_to_object"><code class="docutils literal notranslate"><span class="pre">dict_to_object()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.extensionutil.html">dragonfly.extensionutil module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.extensionutil.html#dragonfly.extensionutil.building_extension_dicts"><code class="docutils literal notranslate"><span class="pre">building_extension_dicts()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.extensionutil.html#dragonfly.extensionutil.context_shade_extension_dicts"><code class="docutils literal notranslate"><span class="pre">context_shade_extension_dicts()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.extensionutil.html#dragonfly.extensionutil.model_extension_dicts"><code class="docutils literal notranslate"><span class="pre">model_extension_dicts()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.extensionutil.html#dragonfly.extensionutil.room2d_extension_dicts"><code class="docutils literal notranslate"><span class="pre">room2d_extension_dicts()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.extensionutil.html#dragonfly.extensionutil.story_extension_dicts"><code class="docutils literal notranslate"><span class="pre">story_extension_dicts()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.model.html">dragonfly.model module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model"><code class="docutils literal notranslate"><span class="pre">Model</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.add_building"><code class="docutils literal notranslate"><span class="pre">add_building()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.add_context_shade"><code class="docutils literal notranslate"><span class="pre">add_context_shade()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.add_model"><code class="docutils literal notranslate"><span class="pre">add_model()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.add_prefix"><code class="docutils literal notranslate"><span class="pre">add_prefix()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.buildings_by_identifier"><code class="docutils literal notranslate"><span class="pre">buildings_by_identifier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_all"><code class="docutils literal notranslate"><span class="pre">check_all()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_all_duplicate_identifiers"><code class="docutils literal notranslate"><span class="pre">check_all_duplicate_identifiers()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_all_room3d"><code class="docutils literal notranslate"><span class="pre">check_all_room3d()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_all_room_collisions"><code class="docutils literal notranslate"><span class="pre">check_all_room_collisions()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_collisions_between_stories"><code class="docutils literal notranslate"><span class="pre">check_collisions_between_stories()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_degenerate_room_2ds"><code class="docutils literal notranslate"><span class="pre">check_degenerate_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_duplicate_building_identifiers"><code class="docutils literal notranslate"><span class="pre">check_duplicate_building_identifiers()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_duplicate_context_shade_identifiers"><code class="docutils literal notranslate"><span class="pre">check_duplicate_context_shade_identifiers()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_duplicate_room_2d_identifiers"><code class="docutils literal notranslate"><span class="pre">check_duplicate_room_2d_identifiers()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_duplicate_story_identifiers"><code class="docutils literal notranslate"><span class="pre">check_duplicate_story_identifiers()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_for_error"><code class="docutils literal notranslate"><span class="pre">check_for_error()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_for_extension"><code class="docutils literal notranslate"><span class="pre">check_for_extension()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_missing_adjacencies"><code class="docutils literal notranslate"><span class="pre">check_missing_adjacencies()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_no_roof_overlaps"><code class="docutils literal notranslate"><span class="pre">check_no_roof_overlaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_no_room2d_overlaps"><code class="docutils literal notranslate"><span class="pre">check_no_room2d_overlaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_plenum_depths"><code class="docutils literal notranslate"><span class="pre">check_plenum_depths()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_roofs_above_rooms"><code class="docutils literal notranslate"><span class="pre">check_roofs_above_rooms()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_room2d_floor_heights_valid"><code class="docutils literal notranslate"><span class="pre">check_room2d_floor_heights_valid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_self_intersecting_room_2ds"><code class="docutils literal notranslate"><span class="pre">check_self_intersecting_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.check_window_parameters_valid"><code class="docutils literal notranslate"><span class="pre">check_window_parameters_valid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.clean_irrational_geometry"><code class="docutils literal notranslate"><span class="pre">clean_irrational_geometry()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.context_shade_by_identifier"><code class="docutils literal notranslate"><span class="pre">context_shade_by_identifier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.convert_to_units"><code class="docutils literal notranslate"><span class="pre">convert_to_units()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.from_dfjson"><code class="docutils literal notranslate"><span class="pre">from_dfjson()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.from_dfpkl"><code class="docutils literal notranslate"><span class="pre">from_dfpkl()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.from_file"><code class="docutils literal notranslate"><span class="pre">from_file()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.from_geojson"><code class="docutils literal notranslate"><span class="pre">from_geojson()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.from_honeybee"><code class="docutils literal notranslate"><span class="pre">from_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.from_pomf"><code class="docutils literal notranslate"><span class="pre">from_pomf()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.lines_from_pomf"><code class="docutils literal notranslate"><span class="pre">lines_from_pomf()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.model_dict_room_2d_subset"><code class="docutils literal notranslate"><span class="pre">model_dict_room_2d_subset()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.model_dict_subset"><code class="docutils literal notranslate"><span class="pre">model_dict_subset()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.remove_duplicate_roofs"><code class="docutils literal notranslate"><span class="pre">remove_duplicate_roofs()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.reset_coordinate_system"><code class="docutils literal notranslate"><span class="pre">reset_coordinate_system()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.reset_ids"><code class="docutils literal notranslate"><span class="pre">reset_ids()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.resolve_id_collisions"><code class="docutils literal notranslate"><span class="pre">resolve_id_collisions()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.room_2ds_by_identifier"><code class="docutils literal notranslate"><span class="pre">room_2ds_by_identifier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.room_3ds_by_identifier"><code class="docutils literal notranslate"><span class="pre">room_3ds_by_identifier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.separate_top_bottom_floors"><code class="docutils literal notranslate"><span class="pre">separate_top_bottom_floors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.set_outdoor_shading_parameters"><code class="docutils literal notranslate"><span class="pre">set_outdoor_shading_parameters()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.set_outdoor_window_parameters"><code class="docutils literal notranslate"><span class="pre">set_outdoor_window_parameters()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.stories_by_identifier"><code class="docutils literal notranslate"><span class="pre">stories_by_identifier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.to_dfjson"><code class="docutils literal notranslate"><span class="pre">to_dfjson()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.to_dfpkl"><code class="docutils literal notranslate"><span class="pre">to_dfpkl()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.to_geojson"><code class="docutils literal notranslate"><span class="pre">to_geojson()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.to_geojson_dict"><code class="docutils literal notranslate"><span class="pre">to_geojson_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.to_honeybee"><code class="docutils literal notranslate"><span class="pre">to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.validate"><code class="docutils literal notranslate"><span class="pre">validate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.ERROR_MAP"><code class="docutils literal notranslate"><span class="pre">ERROR_MAP</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.angle_tolerance"><code class="docutils literal notranslate"><span class="pre">angle_tolerance</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.average_height"><code class="docutils literal notranslate"><span class="pre">average_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.average_height_above_ground"><code class="docutils literal notranslate"><span class="pre">average_height_above_ground</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.average_story_count"><code class="docutils literal notranslate"><span class="pre">average_story_count</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.average_story_count_above_ground"><code class="docutils literal notranslate"><span class="pre">average_story_count_above_ground</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.buildings"><code class="docutils literal notranslate"><span class="pre">buildings</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.context_shades"><code class="docutils literal notranslate"><span class="pre">context_shades</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.display_name"><code class="docutils literal notranslate"><span class="pre">display_name</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.exterior_aperture_area"><code class="docutils literal notranslate"><span class="pre">exterior_aperture_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.exterior_wall_area"><code class="docutils literal notranslate"><span class="pre">exterior_wall_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.floor_area"><code class="docutils literal notranslate"><span class="pre">floor_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.footprint_area"><code class="docutils literal notranslate"><span class="pre">footprint_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.full_id"><code class="docutils literal notranslate"><span class="pre">full_id</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.identifier"><code class="docutils literal notranslate"><span class="pre">identifier</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.max"><code class="docutils literal notranslate"><span class="pre">max</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.min"><code class="docutils literal notranslate"><span class="pre">min</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.properties"><code class="docutils literal notranslate"><span class="pre">properties</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.reference_vector"><code class="docutils literal notranslate"><span class="pre">reference_vector</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.room_2ds"><code class="docutils literal notranslate"><span class="pre">room_2ds</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.room_3ds"><code class="docutils literal notranslate"><span class="pre">room_3ds</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.stories"><code class="docutils literal notranslate"><span class="pre">stories</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.to"><code class="docutils literal notranslate"><span class="pre">to</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.tolerance"><code class="docutils literal notranslate"><span class="pre">tolerance</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.units"><code class="docutils literal notranslate"><span class="pre">units</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.model.html#dragonfly.model.Model.volume"><code class="docutils literal notranslate"><span class="pre">volume</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.projection.html">dragonfly.projection module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.projection.html#dragonfly.projection.lon_lat_to_polygon"><code class="docutils literal notranslate"><span class="pre">lon_lat_to_polygon()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.projection.html#dragonfly.projection.meters_to_long_lat_factors"><code class="docutils literal notranslate"><span class="pre">meters_to_long_lat_factors()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.projection.html#dragonfly.projection.origin_long_lat_from_location"><code class="docutils literal notranslate"><span class="pre">origin_long_lat_from_location()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.projection.html#dragonfly.projection.polygon_to_lon_lat"><code class="docutils literal notranslate"><span class="pre">polygon_to_lon_lat()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.properties.html">dragonfly.properties module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties"><code class="docutils literal notranslate"><span class="pre">BuildingProperties</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.add_prefix"><code class="docutils literal notranslate"><span class="pre">add_prefix()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.apply_ceiling_plenum_face_properties"><code class="docutils literal notranslate"><span class="pre">apply_ceiling_plenum_face_properties()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.apply_floor_plenum_face_properties"><code class="docutils literal notranslate"><span class="pre">apply_floor_plenum_face_properties()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.apply_properties_from_geojson_dict"><code class="docutils literal notranslate"><span class="pre">apply_properties_from_geojson_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.make_plenums"><code class="docutils literal notranslate"><span class="pre">make_plenums()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.BuildingProperties.host"><code class="docutils literal notranslate"><span class="pre">host</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties"><code class="docutils literal notranslate"><span class="pre">ContextShadeProperties</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.add_prefix"><code class="docutils literal notranslate"><span class="pre">add_prefix()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.from_honeybee"><code class="docutils literal notranslate"><span class="pre">from_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.to_honeybee"><code class="docutils literal notranslate"><span class="pre">to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ContextShadeProperties.host"><code class="docutils literal notranslate"><span class="pre">host</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties"><code class="docutils literal notranslate"><span class="pre">ModelProperties</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties.apply_properties_from_dict"><code class="docutils literal notranslate"><span class="pre">apply_properties_from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties.to_honeybee"><code class="docutils literal notranslate"><span class="pre">to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.ModelProperties.host"><code class="docutils literal notranslate"><span class="pre">host</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties"><code class="docutils literal notranslate"><span class="pre">Room2DProperties</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.add_prefix"><code class="docutils literal notranslate"><span class="pre">add_prefix()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.from_honeybee"><code class="docutils literal notranslate"><span class="pre">from_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.to_honeybee"><code class="docutils literal notranslate"><span class="pre">to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.Room2DProperties.host"><code class="docutils literal notranslate"><span class="pre">host</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.StoryProperties"><code class="docutils literal notranslate"><span class="pre">StoryProperties</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.StoryProperties.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.StoryProperties.add_prefix"><code class="docutils literal notranslate"><span class="pre">add_prefix()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.StoryProperties.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.StoryProperties.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.StoryProperties.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.StoryProperties.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.StoryProperties.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.properties.html#dragonfly.properties.StoryProperties.host"><code class="docutils literal notranslate"><span class="pre">host</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.roof.html">dragonfly.roof module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification"><code class="docutils literal notranslate"><span class="pre">RoofSpecification</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.align"><code class="docutils literal notranslate"><span class="pre">align()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.check_roof_above_rooms"><code class="docutils literal notranslate"><span class="pre">check_roof_above_rooms()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.find_gaps"><code class="docutils literal notranslate"><span class="pre">find_gaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.from_geometry_to_join"><code class="docutils literal notranslate"><span class="pre">from_geometry_to_join()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.join_geometries"><code class="docutils literal notranslate"><span class="pre">join_geometries()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.overlap_count"><code class="docutils literal notranslate"><span class="pre">overlap_count()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.pull_to_segments"><code class="docutils literal notranslate"><span class="pre">pull_to_segments()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.remove_small_holes"><code class="docutils literal notranslate"><span class="pre">remove_small_holes()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.resolved_geometry"><code class="docutils literal notranslate"><span class="pre">resolved_geometry()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.snap_to_grid"><code class="docutils literal notranslate"><span class="pre">snap_to_grid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.split_with_lines"><code class="docutils literal notranslate"><span class="pre">split_with_lines()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.split_with_polygon"><code class="docutils literal notranslate"><span class="pre">split_with_polygon()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.split_with_thick_line"><code class="docutils literal notranslate"><span class="pre">split_with_thick_line()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.split_with_thick_polyline"><code class="docutils literal notranslate"><span class="pre">split_with_thick_polyline()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.subtract_roofs"><code class="docutils literal notranslate"><span class="pre">subtract_roofs()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.union_coplanar"><code class="docutils literal notranslate"><span class="pre">union_coplanar()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.update_geometry_2d"><code class="docutils literal notranslate"><span class="pre">update_geometry_2d()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.update_geometry_3d"><code class="docutils literal notranslate"><span class="pre">update_geometry_3d()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.altitudes"><code class="docutils literal notranslate"><span class="pre">altitudes</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.azimuths"><code class="docutils literal notranslate"><span class="pre">azimuths</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.boundary_geometry_2d"><code class="docutils literal notranslate"><span class="pre">boundary_geometry_2d</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.center_heights"><code class="docutils literal notranslate"><span class="pre">center_heights</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.geometry"><code class="docutils literal notranslate"><span class="pre">geometry</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.geometry_2d"><code class="docutils literal notranslate"><span class="pre">geometry_2d</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.has_parent"><code class="docutils literal notranslate"><span class="pre">has_parent</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.max"><code class="docutils literal notranslate"><span class="pre">max</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.max_height"><code class="docutils literal notranslate"><span class="pre">max_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.min"><code class="docutils literal notranslate"><span class="pre">min</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.min_height"><code class="docutils literal notranslate"><span class="pre">min_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.parent"><code class="docutils literal notranslate"><span class="pre">parent</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.planes"><code class="docutils literal notranslate"><span class="pre">planes</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.roof.html#dragonfly.roof.RoofSpecification.tilts"><code class="docutils literal notranslate"><span class="pre">tilts</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.room2d.html">dragonfly.room2d module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D"><code class="docutils literal notranslate"><span class="pre">Room2D</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.add_prefix"><code class="docutils literal notranslate"><span class="pre">add_prefix()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.align"><code class="docutils literal notranslate"><span class="pre">align()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.apply_vertex_map"><code class="docutils literal notranslate"><span class="pre">apply_vertex_map()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.assign_sub_faces"><code class="docutils literal notranslate"><span class="pre">assign_sub_faces()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.automatically_zone"><code class="docutils literal notranslate"><span class="pre">automatically_zone()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.average_orientation"><code class="docutils literal notranslate"><span class="pre">average_orientation()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_degenerate"><code class="docutils literal notranslate"><span class="pre">check_degenerate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_horizontal"><code class="docutils literal notranslate"><span class="pre">check_horizontal()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_plenum_depths"><code class="docutils literal notranslate"><span class="pre">check_plenum_depths()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_self_intersecting"><code class="docutils literal notranslate"><span class="pre">check_self_intersecting()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_window_parameters_valid"><code class="docutils literal notranslate"><span class="pre">check_window_parameters_valid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.coordinate_room_2d_vertices"><code class="docutils literal notranslate"><span class="pre">coordinate_room_2d_vertices()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.coordinate_segment_vertices"><code class="docutils literal notranslate"><span class="pre">coordinate_segment_vertices()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.find_adjacency"><code class="docutils literal notranslate"><span class="pre">find_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.find_adjacency_by_guide_lines"><code class="docutils literal notranslate"><span class="pre">find_adjacency_by_guide_lines()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.find_adjacency_gaps"><code class="docutils literal notranslate"><span class="pre">find_adjacency_gaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.find_segment_adjacency"><code class="docutils literal notranslate"><span class="pre">find_segment_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_segment_by_index"><code class="docutils literal notranslate"><span class="pre">floor_segment_by_index()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_honeybee"><code class="docutils literal notranslate"><span class="pre">from_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_polygon"><code class="docutils literal notranslate"><span class="pre">from_polygon()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_vertices"><code class="docutils literal notranslate"><span class="pre">from_vertices()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.generate_alignment_axes"><code class="docutils literal notranslate"><span class="pre">generate_alignment_axes()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.generate_grid"><code class="docutils literal notranslate"><span class="pre">generate_grid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_adjacency"><code class="docutils literal notranslate"><span class="pre">group_by_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_air_boundary_adjacency"><code class="docutils literal notranslate"><span class="pre">group_by_air_boundary_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_attribute"><code class="docutils literal notranslate"><span class="pre">group_by_attribute()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_floor_height"><code class="docutils literal notranslate"><span class="pre">group_by_floor_height()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_orientation"><code class="docutils literal notranslate"><span class="pre">group_by_orientation()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.grouped_horizontal_boundary"><code class="docutils literal notranslate"><span class="pre">grouped_horizontal_boundary()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.intersect_adjacency"><code class="docutils literal notranslate"><span class="pre">intersect_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.join_by_boundary"><code class="docutils literal notranslate"><span class="pre">join_by_boundary()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.join_room_2ds"><code class="docutils literal notranslate"><span class="pre">join_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.join_to_neighbor"><code class="docutils literal notranslate"><span class="pre">join_to_neighbor()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.label_point"><code class="docutils literal notranslate"><span class="pre">label_point()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.make_skylights_flush"><code class="docutils literal notranslate"><span class="pre">make_skylights_flush()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.make_windows_flush"><code class="docutils literal notranslate"><span class="pre">make_windows_flush()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.offset_skylights"><code class="docutils literal notranslate"><span class="pre">offset_skylights()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.offset_skylights_from_edges"><code class="docutils literal notranslate"><span class="pre">offset_skylights_from_edges()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.offset_windows"><code class="docutils literal notranslate"><span class="pre">offset_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.overlap_area"><code class="docutils literal notranslate"><span class="pre">overlap_area()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.patch_missing_adjacencies"><code class="docutils literal notranslate"><span class="pre">patch_missing_adjacencies()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.pull_to_polygon"><code class="docutils literal notranslate"><span class="pre">pull_to_polygon()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.pull_to_polyline"><code class="docutils literal notranslate"><span class="pre">pull_to_polyline()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.pull_to_room_2d"><code class="docutils literal notranslate"><span class="pre">pull_to_room_2d()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.pull_to_segments"><code class="docutils literal notranslate"><span class="pre">pull_to_segments()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.rectangularize_windows"><code class="docutils literal notranslate"><span class="pre">rectangularize_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.relevant_roof_geometry"><code class="docutils literal notranslate"><span class="pre">relevant_roof_geometry()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_colinear_vertices"><code class="docutils literal notranslate"><span class="pre">remove_colinear_vertices()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_degenerate_holes"><code class="docutils literal notranslate"><span class="pre">remove_degenerate_holes()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_doors"><code class="docutils literal notranslate"><span class="pre">remove_doors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_duplicate_vertices"><code class="docutils literal notranslate"><span class="pre">remove_duplicate_vertices()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_short_segments"><code class="docutils literal notranslate"><span class="pre">remove_short_segments()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_small_holes"><code class="docutils literal notranslate"><span class="pre">remove_small_holes()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_small_skylights"><code class="docutils literal notranslate"><span class="pre">remove_small_skylights()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_small_windows"><code class="docutils literal notranslate"><span class="pre">remove_small_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.replace_floor_geometry"><code class="docutils literal notranslate"><span class="pre">replace_floor_geometry()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.reset_adjacency"><code class="docutils literal notranslate"><span class="pre">reset_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.room_orientation_plane"><code class="docutils literal notranslate"><span class="pre">room_orientation_plane()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.segment_indices_by_guide_lines"><code class="docutils literal notranslate"><span class="pre">segment_indices_by_guide_lines()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.segment_orientations"><code class="docutils literal notranslate"><span class="pre">segment_orientations()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.separate_plenum"><code class="docutils literal notranslate"><span class="pre">separate_plenum()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_adjacency"><code class="docutils literal notranslate"><span class="pre">set_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_air_boundary"><code class="docutils literal notranslate"><span class="pre">set_air_boundary()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_boundary_condition"><code class="docutils literal notranslate"><span class="pre">set_boundary_condition()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_outdoor_shading_parameters"><code class="docutils literal notranslate"><span class="pre">set_outdoor_shading_parameters()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_outdoor_window_parameters"><code class="docutils literal notranslate"><span class="pre">set_outdoor_window_parameters()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_window_parameter"><code class="docutils literal notranslate"><span class="pre">set_window_parameter()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.snap_to_grid"><code class="docutils literal notranslate"><span class="pre">snap_to_grid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.snap_to_line_end_points"><code class="docutils literal notranslate"><span class="pre">snap_to_line_end_points()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.snap_to_points"><code class="docutils literal notranslate"><span class="pre">snap_to_points()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.solve_adjacency"><code class="docutils literal notranslate"><span class="pre">solve_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_through_self_intersection"><code class="docutils literal notranslate"><span class="pre">split_through_self_intersection()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_line"><code class="docutils literal notranslate"><span class="pre">split_with_line()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_lines"><code class="docutils literal notranslate"><span class="pre">split_with_lines()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_polygon"><code class="docutils literal notranslate"><span class="pre">split_with_polygon()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_polyline"><code class="docutils literal notranslate"><span class="pre">split_with_polyline()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_thick_line"><code class="docutils literal notranslate"><span class="pre">split_with_thick_line()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_thick_polyline"><code class="docutils literal notranslate"><span class="pre">split_with_thick_polyline()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.subtract_room_2ds"><code class="docutils literal notranslate"><span class="pre">subtract_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_core_perimeter"><code class="docutils literal notranslate"><span class="pre">to_core_perimeter()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_detailed_windows"><code class="docutils literal notranslate"><span class="pre">to_detailed_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_honeybee"><code class="docutils literal notranslate"><span class="pre">to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.unconforming_vertex_map"><code class="docutils literal notranslate"><span class="pre">unconforming_vertex_map()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.update_floor_geometry"><code class="docutils literal notranslate"><span class="pre">update_floor_geometry()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.air_boundaries"><code class="docutils literal notranslate"><span class="pre">air_boundaries</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.boundary_conditions"><code class="docutils literal notranslate"><span class="pre">boundary_conditions</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.ceiling_height"><code class="docutils literal notranslate"><span class="pre">ceiling_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.ceiling_plenum_depth"><code class="docutils literal notranslate"><span class="pre">ceiling_plenum_depth</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.center"><code class="docutils literal notranslate"><span class="pre">center</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.display_name"><code class="docutils literal notranslate"><span class="pre">display_name</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.exterior_aperture_area"><code class="docutils literal notranslate"><span class="pre">exterior_aperture_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.exterior_wall_area"><code class="docutils literal notranslate"><span class="pre">exterior_wall_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.exterior_window_area"><code class="docutils literal notranslate"><span class="pre">exterior_window_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_area"><code class="docutils literal notranslate"><span class="pre">floor_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_geometry"><code class="docutils literal notranslate"><span class="pre">floor_geometry</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_height"><code class="docutils literal notranslate"><span class="pre">floor_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_plenum_depth"><code class="docutils literal notranslate"><span class="pre">floor_plenum_depth</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_segments"><code class="docutils literal notranslate"><span class="pre">floor_segments</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_segments_2d"><code class="docutils literal notranslate"><span class="pre">floor_segments_2d</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_to_ceiling_height"><code class="docutils literal notranslate"><span class="pre">floor_to_ceiling_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.full_id"><code class="docutils literal notranslate"><span class="pre">full_id</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.has_ceiling"><code class="docutils literal notranslate"><span class="pre">has_ceiling</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.has_floor"><code class="docutils literal notranslate"><span class="pre">has_floor</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.has_parent"><code class="docutils literal notranslate"><span class="pre">has_parent</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.highest_plenum_floor_height"><code class="docutils literal notranslate"><span class="pre">highest_plenum_floor_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.identifier"><code class="docutils literal notranslate"><span class="pre">identifier</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.interior_wall_area"><code class="docutils literal notranslate"><span class="pre">interior_wall_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.is_core"><code class="docutils literal notranslate"><span class="pre">is_core</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.is_ground_contact"><code class="docutils literal notranslate"><span class="pre">is_ground_contact</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.is_perimeter"><code class="docutils literal notranslate"><span class="pre">is_perimeter</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.is_top_exposed"><code class="docutils literal notranslate"><span class="pre">is_top_exposed</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.max"><code class="docutils literal notranslate"><span class="pre">max</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.min"><code class="docutils literal notranslate"><span class="pre">min</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.parent"><code class="docutils literal notranslate"><span class="pre">parent</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.properties"><code class="docutils literal notranslate"><span class="pre">properties</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.roof_sub_face_area"><code class="docutils literal notranslate"><span class="pre">roof_sub_face_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.segment_count"><code class="docutils literal notranslate"><span class="pre">segment_count</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.segment_normals"><code class="docutils literal notranslate"><span class="pre">segment_normals</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.shading_parameters"><code class="docutils literal notranslate"><span class="pre">shading_parameters</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.skylight_area"><code class="docutils literal notranslate"><span class="pre">skylight_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.skylight_parameters"><code class="docutils literal notranslate"><span class="pre">skylight_parameters</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.sub_face_area"><code class="docutils literal notranslate"><span class="pre">sub_face_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to"><code class="docutils literal notranslate"><span class="pre">to</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.volume"><code class="docutils literal notranslate"><span class="pre">volume</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.wall_sub_face_area"><code class="docutils literal notranslate"><span class="pre">wall_sub_face_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.window_parameters"><code class="docutils literal notranslate"><span class="pre">window_parameters</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.zone"><code class="docutils literal notranslate"><span class="pre">zone</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.shadingparameter.html">dragonfly.shadingparameter module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.ExtrudedBorder"><code class="docutils literal notranslate"><span class="pre">ExtrudedBorder</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.ExtrudedBorder.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.ExtrudedBorder.add_shading_to_face"><code class="docutils literal notranslate"><span class="pre">add_shading_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.ExtrudedBorder.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.ExtrudedBorder.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.ExtrudedBorder.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.ExtrudedBorder.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.ExtrudedBorder.depth"><code class="docutils literal notranslate"><span class="pre">depth</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount"><code class="docutils literal notranslate"><span class="pre">LouversByCount</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.add_shading_to_face"><code class="docutils literal notranslate"><span class="pre">add_shading_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.angle"><code class="docutils literal notranslate"><span class="pre">angle</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.contour_vector"><code class="docutils literal notranslate"><span class="pre">contour_vector</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.depth"><code class="docutils literal notranslate"><span class="pre">depth</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.flip_start_side"><code class="docutils literal notranslate"><span class="pre">flip_start_side</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.louver_count"><code class="docutils literal notranslate"><span class="pre">louver_count</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByCount.offset"><code class="docutils literal notranslate"><span class="pre">offset</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance"><code class="docutils literal notranslate"><span class="pre">LouversByDistance</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.add_shading_to_face"><code class="docutils literal notranslate"><span class="pre">add_shading_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.angle"><code class="docutils literal notranslate"><span class="pre">angle</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.contour_vector"><code class="docutils literal notranslate"><span class="pre">contour_vector</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.depth"><code class="docutils literal notranslate"><span class="pre">depth</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.distance"><code class="docutils literal notranslate"><span class="pre">distance</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.flip_start_side"><code class="docutils literal notranslate"><span class="pre">flip_start_side</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.LouversByDistance.offset"><code class="docutils literal notranslate"><span class="pre">offset</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.Overhang"><code class="docutils literal notranslate"><span class="pre">Overhang</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.Overhang.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.Overhang.add_shading_to_face"><code class="docutils literal notranslate"><span class="pre">add_shading_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.Overhang.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.Overhang.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.Overhang.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.Overhang.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.Overhang.angle"><code class="docutils literal notranslate"><span class="pre">angle</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.shadingparameter.html#dragonfly.shadingparameter.Overhang.depth"><code class="docutils literal notranslate"><span class="pre">depth</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.skylightparameter.html">dragonfly.skylightparameter module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights"><code class="docutils literal notranslate"><span class="pre">DetailedSkylights</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.add_skylight_to_face"><code class="docutils literal notranslate"><span class="pre">add_skylight_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.aperture_area_from_face"><code class="docutils literal notranslate"><span class="pre">aperture_area_from_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.area_from_face"><code class="docutils literal notranslate"><span class="pre">area_from_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.check_overlaps"><code class="docutils literal notranslate"><span class="pre">check_overlaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.check_self_intersecting"><code class="docutils literal notranslate"><span class="pre">check_self_intersecting()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.check_valid_for_face"><code class="docutils literal notranslate"><span class="pre">check_valid_for_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.from_honeybee"><code class="docutils literal notranslate"><span class="pre">from_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.invalid_face_geometries"><code class="docutils literal notranslate"><span class="pre">invalid_face_geometries()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.make_flush"><code class="docutils literal notranslate"><span class="pre">make_flush()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.merge_and_simplify"><code class="docutils literal notranslate"><span class="pre">merge_and_simplify()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.merge_to_bounding_rectangle"><code class="docutils literal notranslate"><span class="pre">merge_to_bounding_rectangle()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.offset"><code class="docutils literal notranslate"><span class="pre">offset()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.offset_polygons_for_face"><code class="docutils literal notranslate"><span class="pre">offset_polygons_for_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.overlapping_geometries"><code class="docutils literal notranslate"><span class="pre">overlapping_geometries()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.rectangularize"><code class="docutils literal notranslate"><span class="pre">rectangularize()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.remove_doors"><code class="docutils literal notranslate"><span class="pre">remove_doors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.remove_self_intersecting"><code class="docutils literal notranslate"><span class="pre">remove_self_intersecting()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.remove_small_skylights"><code class="docutils literal notranslate"><span class="pre">remove_small_skylights()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.rotate"><code class="docutils literal notranslate"><span class="pre">rotate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.self_intersecting_geometries"><code class="docutils literal notranslate"><span class="pre">self_intersecting_geometries()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.union_overlaps"><code class="docutils literal notranslate"><span class="pre">union_overlaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.are_doors"><code class="docutils literal notranslate"><span class="pre">are_doors</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.polygons"><code class="docutils literal notranslate"><span class="pre">polygons</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.DetailedSkylights.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea"><code class="docutils literal notranslate"><span class="pre">GriddedSkylightArea</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.add_skylight_to_face"><code class="docutils literal notranslate"><span class="pre">add_skylight_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.area_from_face"><code class="docutils literal notranslate"><span class="pre">area_from_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.skylight_area"><code class="docutils literal notranslate"><span class="pre">skylight_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.spacing"><code class="docutils literal notranslate"><span class="pre">spacing</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightArea.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio"><code class="docutils literal notranslate"><span class="pre">GriddedSkylightRatio</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.add_skylight_to_face"><code class="docutils literal notranslate"><span class="pre">add_skylight_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.area_from_face"><code class="docutils literal notranslate"><span class="pre">area_from_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.skylight_ratio"><code class="docutils literal notranslate"><span class="pre">skylight_ratio</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.spacing"><code class="docutils literal notranslate"><span class="pre">spacing</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.skylightparameter.html#dragonfly.skylightparameter.GriddedSkylightRatio.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.story.html">dragonfly.story module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story"><code class="docutils literal notranslate"><span class="pre">Story</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.add_prefix"><code class="docutils literal notranslate"><span class="pre">add_prefix()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.add_room_2d"><code class="docutils literal notranslate"><span class="pre">add_room_2d()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.add_room_2ds"><code class="docutils literal notranslate"><span class="pre">add_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.align"><code class="docutils literal notranslate"><span class="pre">align()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.align_room_2ds"><code class="docutils literal notranslate"><span class="pre">align_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.automatically_zone"><code class="docutils literal notranslate"><span class="pre">automatically_zone()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.check_collision_with_story"><code class="docutils literal notranslate"><span class="pre">check_collision_with_story()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.check_missing_adjacencies"><code class="docutils literal notranslate"><span class="pre">check_missing_adjacencies()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.check_no_roof_overlaps"><code class="docutils literal notranslate"><span class="pre">check_no_roof_overlaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.check_no_room2d_overlaps"><code class="docutils literal notranslate"><span class="pre">check_no_room2d_overlaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.check_roofs_above_rooms"><code class="docutils literal notranslate"><span class="pre">check_roofs_above_rooms()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.check_room2d_floor_heights_valid"><code class="docutils literal notranslate"><span class="pre">check_room2d_floor_heights_valid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.delete_degenerate_room_2ds"><code class="docutils literal notranslate"><span class="pre">delete_degenerate_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.fill_holes"><code class="docutils literal notranslate"><span class="pre">fill_holes()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.floor_geometry"><code class="docutils literal notranslate"><span class="pre">floor_geometry()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.footprint"><code class="docutils literal notranslate"><span class="pre">footprint()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.from_honeybee"><code class="docutils literal notranslate"><span class="pre">from_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.generate_grid"><code class="docutils literal notranslate"><span class="pre">generate_grid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.intersect_room_2d_adjacency"><code class="docutils literal notranslate"><span class="pre">intersect_room_2d_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.join_room_2ds"><code class="docutils literal notranslate"><span class="pre">join_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.join_small_room_2ds"><code class="docutils literal notranslate"><span class="pre">join_small_room_2ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.make_underground"><code class="docutils literal notranslate"><span class="pre">make_underground()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.move"><code class="docutils literal notranslate"><span class="pre">move()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.outline_polylines"><code class="docutils literal notranslate"><span class="pre">outline_polylines()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.outline_segments"><code class="docutils literal notranslate"><span class="pre">outline_segments()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.patch_missing_adjacencies"><code class="docutils literal notranslate"><span class="pre">patch_missing_adjacencies()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.rebuild_detailed_windows"><code class="docutils literal notranslate"><span class="pre">rebuild_detailed_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.reflect"><code class="docutils literal notranslate"><span class="pre">reflect()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.remove_room_2d_colinear_vertices"><code class="docutils literal notranslate"><span class="pre">remove_room_2d_colinear_vertices()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.remove_room_2d_duplicate_vertices"><code class="docutils literal notranslate"><span class="pre">remove_room_2d_duplicate_vertices()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.remove_room_2d_short_segments"><code class="docutils literal notranslate"><span class="pre">remove_room_2d_short_segments()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.reset_adjacency"><code class="docutils literal notranslate"><span class="pre">reset_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.reset_room_2d_boundaries"><code class="docutils literal notranslate"><span class="pre">reset_room_2d_boundaries()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.room_2d_story_geometry_valid"><code class="docutils literal notranslate"><span class="pre">room_2d_story_geometry_valid()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.room_by_identifier"><code class="docutils literal notranslate"><span class="pre">room_by_identifier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.rooms_by_identifier"><code class="docutils literal notranslate"><span class="pre">rooms_by_identifier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.rotate_xy"><code class="docutils literal notranslate"><span class="pre">rotate_xy()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.set_adjacent_air_boundary"><code class="docutils literal notranslate"><span class="pre">set_adjacent_air_boundary()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.set_ground_contact"><code class="docutils literal notranslate"><span class="pre">set_ground_contact()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.set_ground_contact_by_story_below"><code class="docutils literal notranslate"><span class="pre">set_ground_contact_by_story_below()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.set_outdoor_shading_parameters"><code class="docutils literal notranslate"><span class="pre">set_outdoor_shading_parameters()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.set_outdoor_window_parameters"><code class="docutils literal notranslate"><span class="pre">set_outdoor_window_parameters()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.set_top_exposed"><code class="docutils literal notranslate"><span class="pre">set_top_exposed()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.set_top_exposed_by_story_above"><code class="docutils literal notranslate"><span class="pre">set_top_exposed_by_story_above()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.shade_representation"><code class="docutils literal notranslate"><span class="pre">shade_representation()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.shade_representation_multiplier"><code class="docutils literal notranslate"><span class="pre">shade_representation_multiplier()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.solve_room_2d_adjacency"><code class="docutils literal notranslate"><span class="pre">solve_room_2d_adjacency()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.split_with_story_above"><code class="docutils literal notranslate"><span class="pre">split_with_story_above()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.suggested_alignment_axes"><code class="docutils literal notranslate"><span class="pre">suggested_alignment_axes()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.to_honeybee"><code class="docutils literal notranslate"><span class="pre">to_honeybee()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.STORY_TYPES"><code class="docutils literal notranslate"><span class="pre">STORY_TYPES</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.display_name"><code class="docutils literal notranslate"><span class="pre">display_name</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.exterior_aperture_area"><code class="docutils literal notranslate"><span class="pre">exterior_aperture_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.exterior_wall_area"><code class="docutils literal notranslate"><span class="pre">exterior_wall_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.floor_area"><code class="docutils literal notranslate"><span class="pre">floor_area</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.floor_height"><code class="docutils literal notranslate"><span class="pre">floor_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.floor_to_floor_height"><code class="docutils literal notranslate"><span class="pre">floor_to_floor_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.full_id"><code class="docutils literal notranslate"><span class="pre">full_id</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.has_parent"><code class="docutils literal notranslate"><span class="pre">has_parent</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.has_plenums"><code class="docutils literal notranslate"><span class="pre">has_plenums</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.has_zones"><code class="docutils literal notranslate"><span class="pre">has_zones</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.highest_plenum_floor_height"><code class="docutils literal notranslate"><span class="pre">highest_plenum_floor_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.identifier"><code class="docutils literal notranslate"><span class="pre">identifier</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.is_above_ground"><code class="docutils literal notranslate"><span class="pre">is_above_ground</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.is_plenum"><code class="docutils literal notranslate"><span class="pre">is_plenum</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.max"><code class="docutils literal notranslate"><span class="pre">max</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.max_room_2d_ceiling_height"><code class="docutils literal notranslate"><span class="pre">max_room_2d_ceiling_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.median_room2d_floor_height"><code class="docutils literal notranslate"><span class="pre">median_room2d_floor_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.min"><code class="docutils literal notranslate"><span class="pre">min</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.min_room_2d_floor_height"><code class="docutils literal notranslate"><span class="pre">min_room_2d_floor_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.multiplier"><code class="docutils literal notranslate"><span class="pre">multiplier</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.parent"><code class="docutils literal notranslate"><span class="pre">parent</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.properties"><code class="docutils literal notranslate"><span class="pre">properties</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.roof"><code class="docutils literal notranslate"><span class="pre">roof</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.room_2ds"><code class="docutils literal notranslate"><span class="pre">room_2ds</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.to"><code class="docutils literal notranslate"><span class="pre">to</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.type"><code class="docutils literal notranslate"><span class="pre">type</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.volume"><code class="docutils literal notranslate"><span class="pre">volume</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.story.html#dragonfly.story.Story.zone_dict"><code class="docutils literal notranslate"><span class="pre">zone_dict</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.subdivide.html">dragonfly.subdivide module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.subdivide.html#dragonfly.subdivide.interpret_core_perimeter_subdivide"><code class="docutils literal notranslate"><span class="pre">interpret_core_perimeter_subdivide()</span></code></a></li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.subdivide.html#dragonfly.subdivide.interpret_floor_height_subdivide"><code class="docutils literal notranslate"><span class="pre">interpret_floor_height_subdivide()</span></code></a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="../../dragonfly.windowparameter.html">dragonfly.windowparameter module</a><ul>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows"><code class="docutils literal notranslate"><span class="pre">DetailedWindows</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.add_window_to_face"><code class="docutils literal notranslate"><span class="pre">add_window_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.adjust_for_segment"><code class="docutils literal notranslate"><span class="pre">adjust_for_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.aperture_area_from_segment"><code class="docutils literal notranslate"><span class="pre">aperture_area_from_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.area_from_segment"><code class="docutils literal notranslate"><span class="pre">area_from_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.check_self_intersecting"><code class="docutils literal notranslate"><span class="pre">check_self_intersecting()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.check_valid_for_segment"><code class="docutils literal notranslate"><span class="pre">check_valid_for_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.check_window_overlaps"><code class="docutils literal notranslate"><span class="pre">check_window_overlaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.flip"><code class="docutils literal notranslate"><span class="pre">flip()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.from_face3ds"><code class="docutils literal notranslate"><span class="pre">from_face3ds()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.is_face3d_in_segment_plane"><code class="docutils literal notranslate"><span class="pre">is_face3d_in_segment_plane()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.is_flipped_equivalent"><code class="docutils literal notranslate"><span class="pre">is_flipped_equivalent()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.make_flush"><code class="docutils literal notranslate"><span class="pre">make_flush()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.merge"><code class="docutils literal notranslate"><span class="pre">merge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.merge_and_simplify"><code class="docutils literal notranslate"><span class="pre">merge_and_simplify()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.merge_to_bounding_rectangle"><code class="docutils literal notranslate"><span class="pre">merge_to_bounding_rectangle()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.merge_to_rectangular"><code class="docutils literal notranslate"><span class="pre">merge_to_rectangular()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.offset"><code class="docutils literal notranslate"><span class="pre">offset()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.overlapping_geometries"><code class="docutils literal notranslate"><span class="pre">overlapping_geometries()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.rectangularize"><code class="docutils literal notranslate"><span class="pre">rectangularize()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.remove_doors"><code class="docutils literal notranslate"><span class="pre">remove_doors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.remove_small_windows"><code class="docutils literal notranslate"><span class="pre">remove_small_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.self_intersecting_geometries"><code class="docutils literal notranslate"><span class="pre">self_intersecting_geometries()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.shift_horizontally"><code class="docutils literal notranslate"><span class="pre">shift_horizontally()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.shift_vertically"><code class="docutils literal notranslate"><span class="pre">shift_vertically()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.trim"><code class="docutils literal notranslate"><span class="pre">trim()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.union_overlaps"><code class="docutils literal notranslate"><span class="pre">union_overlaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.are_doors"><code class="docutils literal notranslate"><span class="pre">are_doors</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.polygons"><code class="docutils literal notranslate"><span class="pre">polygons</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.DetailedWindows.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows"><code class="docutils literal notranslate"><span class="pre">RectangularWindows</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.add_window_to_face"><code class="docutils literal notranslate"><span class="pre">add_window_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.adjust_for_segment"><code class="docutils literal notranslate"><span class="pre">adjust_for_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.aperture_area_from_segment"><code class="docutils literal notranslate"><span class="pre">aperture_area_from_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.area_from_segment"><code class="docutils literal notranslate"><span class="pre">area_from_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.check_valid_for_segment"><code class="docutils literal notranslate"><span class="pre">check_valid_for_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.check_window_overlaps"><code class="docutils literal notranslate"><span class="pre">check_window_overlaps()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.flip"><code class="docutils literal notranslate"><span class="pre">flip()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.merge"><code class="docutils literal notranslate"><span class="pre">merge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.merge_to_rectangular"><code class="docutils literal notranslate"><span class="pre">merge_to_rectangular()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.offset"><code class="docutils literal notranslate"><span class="pre">offset()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.remove_doors"><code class="docutils literal notranslate"><span class="pre">remove_doors()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.remove_small_windows"><code class="docutils literal notranslate"><span class="pre">remove_small_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.shift_horizontally"><code class="docutils literal notranslate"><span class="pre">shift_horizontally()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.shift_vertically"><code class="docutils literal notranslate"><span class="pre">shift_vertically()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.to_detailed_windows"><code class="docutils literal notranslate"><span class="pre">to_detailed_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.trim"><code class="docutils literal notranslate"><span class="pre">trim()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.are_doors"><code class="docutils literal notranslate"><span class="pre">are_doors</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.heights"><code class="docutils literal notranslate"><span class="pre">heights</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.origins"><code class="docutils literal notranslate"><span class="pre">origins</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RectangularWindows.widths"><code class="docutils literal notranslate"><span class="pre">widths</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio"><code class="docutils literal notranslate"><span class="pre">RepeatingWindowRatio</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.add_window_to_face"><code class="docutils literal notranslate"><span class="pre">add_window_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.area_from_segment"><code class="docutils literal notranslate"><span class="pre">area_from_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.merge"><code class="docutils literal notranslate"><span class="pre">merge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.merge_to_rectangular"><code class="docutils literal notranslate"><span class="pre">merge_to_rectangular()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.trim"><code class="docutils literal notranslate"><span class="pre">trim()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.horizontal_separation"><code class="docutils literal notranslate"><span class="pre">horizontal_separation</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.rect_split"><code class="docutils literal notranslate"><span class="pre">rect_split</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.sill_height"><code class="docutils literal notranslate"><span class="pre">sill_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.vertical_separation"><code class="docutils literal notranslate"><span class="pre">vertical_separation</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.window_height"><code class="docutils literal notranslate"><span class="pre">window_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowRatio.window_ratio"><code class="docutils literal notranslate"><span class="pre">window_ratio</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight"><code class="docutils literal notranslate"><span class="pre">RepeatingWindowWidthHeight</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.add_window_to_face"><code class="docutils literal notranslate"><span class="pre">add_window_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.area_from_segment"><code class="docutils literal notranslate"><span class="pre">area_from_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.merge"><code class="docutils literal notranslate"><span class="pre">merge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.merge_to_rectangular"><code class="docutils literal notranslate"><span class="pre">merge_to_rectangular()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.trim"><code class="docutils literal notranslate"><span class="pre">trim()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.horizontal_separation"><code class="docutils literal notranslate"><span class="pre">horizontal_separation</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.sill_height"><code class="docutils literal notranslate"><span class="pre">sill_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.window_height"><code class="docutils literal notranslate"><span class="pre">window_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.RepeatingWindowWidthHeight.window_width"><code class="docutils literal notranslate"><span class="pre">window_width</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea"><code class="docutils literal notranslate"><span class="pre">SimpleWindowArea</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.add_window_to_face"><code class="docutils literal notranslate"><span class="pre">add_window_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.area_from_segment"><code class="docutils literal notranslate"><span class="pre">area_from_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.merge"><code class="docutils literal notranslate"><span class="pre">merge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.merge_to_rectangular"><code class="docutils literal notranslate"><span class="pre">merge_to_rectangular()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.trim"><code class="docutils literal notranslate"><span class="pre">trim()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.rect_split"><code class="docutils literal notranslate"><span class="pre">rect_split</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowArea.window_area"><code class="docutils literal notranslate"><span class="pre">window_area</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio"><code class="docutils literal notranslate"><span class="pre">SimpleWindowRatio</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.add_window_to_face"><code class="docutils literal notranslate"><span class="pre">add_window_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.area_from_segment"><code class="docutils literal notranslate"><span class="pre">area_from_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.merge"><code class="docutils literal notranslate"><span class="pre">merge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.merge_to_rectangular"><code class="docutils literal notranslate"><span class="pre">merge_to_rectangular()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.trim"><code class="docutils literal notranslate"><span class="pre">trim()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.rect_split"><code class="docutils literal notranslate"><span class="pre">rect_split</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SimpleWindowRatio.window_ratio"><code class="docutils literal notranslate"><span class="pre">window_ratio</span></code></a></li>
</ul>
</li>
<li class="toctree-l5"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow"><code class="docutils literal notranslate"><span class="pre">SingleWindow</span></code></a><ul>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.ToString"><code class="docutils literal notranslate"><span class="pre">ToString()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.add_window_to_face"><code class="docutils literal notranslate"><span class="pre">add_window_to_face()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.area_from_segment"><code class="docutils literal notranslate"><span class="pre">area_from_segment()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.duplicate"><code class="docutils literal notranslate"><span class="pre">duplicate()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.from_dict"><code class="docutils literal notranslate"><span class="pre">from_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.merge"><code class="docutils literal notranslate"><span class="pre">merge()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.merge_to_rectangular"><code class="docutils literal notranslate"><span class="pre">merge_to_rectangular()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.scale"><code class="docutils literal notranslate"><span class="pre">scale()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.split"><code class="docutils literal notranslate"><span class="pre">split()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.to_dict"><code class="docutils literal notranslate"><span class="pre">to_dict()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.to_rectangular_windows"><code class="docutils literal notranslate"><span class="pre">to_rectangular_windows()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.trim"><code class="docutils literal notranslate"><span class="pre">trim()</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.height"><code class="docutils literal notranslate"><span class="pre">height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.sill_height"><code class="docutils literal notranslate"><span class="pre">sill_height</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.user_data"><code class="docutils literal notranslate"><span class="pre">user_data</span></code></a></li>
<li class="toctree-l6"><a class="reference internal" href="../../dragonfly.windowparameter.html#dragonfly.windowparameter.SingleWindow.width"><code class="docutils literal notranslate"><span class="pre">width</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../dragonfly.html#module-dragonfly">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../cli/index.html">CLI Docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">dragonfly</a></li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-4">
        <div id="sidebar" class="bs-sidenav" role="complementary"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../cli/index.html">CLI Docs</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">dragonfly</a></li>
</ul>

        </div>
      </div>
    <div class="body col-md-8 content" role="main">
      
  <h1>Source code for dragonfly.room2d</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="sd">&quot;&quot;&quot;Dragonfly Room2D.&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">ladybug_geometry.geometry2d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point2D</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">,</span> <span class="n">Ray2D</span><span class="p">,</span> <span class="n">LineSegment2D</span><span class="p">,</span> \
    <span class="n">Polyline2D</span><span class="p">,</span> <span class="n">Polygon2D</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ladybug_geometry.geometry3d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Point3D</span><span class="p">,</span> <span class="n">Vector3D</span><span class="p">,</span> <span class="n">Ray3D</span><span class="p">,</span> <span class="n">LineSegment3D</span><span class="p">,</span> \
    <span class="n">Plane</span><span class="p">,</span> <span class="n">Polyline3D</span><span class="p">,</span> <span class="n">Face3D</span><span class="p">,</span> <span class="n">Polyface3D</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ladybug_geometry.intersection2d</span><span class="w"> </span><span class="kn">import</span> <span class="n">closest_point2d_between_line2d</span><span class="p">,</span> \
    <span class="n">closest_point2d_on_line2d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ladybug_geometry.intersection3d</span><span class="w"> </span><span class="kn">import</span> <span class="n">closest_point3d_on_line3d</span><span class="p">,</span> \
    <span class="n">closest_point3d_on_line3d_infinite</span><span class="p">,</span> <span class="n">intersect_line3d_plane_infinite</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ladybug_geometry.bounding</span><span class="w"> </span><span class="kn">import</span> <span class="n">bounding_box</span><span class="p">,</span> <span class="n">overlapping_bounding_boxes</span><span class="p">,</span> \
    <span class="n">overlapping_bounding_rect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ladybug_geometry.boolean</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pb</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ladybug_geometry_polyskel.polysplit</span><span class="w"> </span><span class="kn">import</span> <span class="n">perimeter_core_subfaces</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">float_positive</span><span class="p">,</span> <span class="n">clean_string</span><span class="p">,</span> <span class="n">clean_and_id_string</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.orientation</span><span class="w"> </span><span class="kn">import</span> <span class="n">angles_from_num_orient</span><span class="p">,</span> <span class="n">orient_index</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.search</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_attr_nested</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">honeybee.boundarycondition</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">hbc</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.boundarycondition</span><span class="w"> </span><span class="kn">import</span> <span class="n">boundary_conditions</span> <span class="k">as</span> <span class="n">bcs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.boundarycondition</span><span class="w"> </span><span class="kn">import</span> <span class="n">_BoundaryCondition</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">,</span> <span class="n">Ground</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.facetype</span><span class="w"> </span><span class="kn">import</span> <span class="n">Floor</span><span class="p">,</span> <span class="n">Wall</span><span class="p">,</span> <span class="n">AirBoundary</span><span class="p">,</span> <span class="n">RoofCeiling</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.facetype</span><span class="w"> </span><span class="kn">import</span> <span class="n">face_types</span> <span class="k">as</span> <span class="n">ftyp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.door</span><span class="w"> </span><span class="kn">import</span> <span class="n">Door</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.aperture</span><span class="w"> </span><span class="kn">import</span> <span class="n">Aperture</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.face</span><span class="w"> </span><span class="kn">import</span> <span class="n">Face</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">honeybee.room</span><span class="w"> </span><span class="kn">import</span> <span class="n">Room</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">._base</span><span class="w"> </span><span class="kn">import</span> <span class="n">_BaseGeometry</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.properties</span><span class="w"> </span><span class="kn">import</span> <span class="n">Room2DProperties</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dragonfly.windowparameter</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">glzpar</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dragonfly.windowparameter</span><span class="w"> </span><span class="kn">import</span> <span class="n">_WindowParameterBase</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">,</span> \
    <span class="n">SimpleWindowRatio</span><span class="p">,</span> <span class="n">RectangularWindows</span><span class="p">,</span> <span class="n">DetailedWindows</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dragonfly.skylightparameter</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">skypar</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dragonfly.skylightparameter</span><span class="w"> </span><span class="kn">import</span> <span class="n">_SkylightParameterBase</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">,</span> \
    <span class="n">GriddedSkylightArea</span><span class="p">,</span> <span class="n">GriddedSkylightRatio</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dragonfly.shadingparameter</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">shdpar</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dragonfly.shadingparameter</span><span class="w"> </span><span class="kn">import</span> <span class="n">_ShadingParameterBase</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dragonfly.writer.room2d</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">writer</span>


<div class="viewcode-block" id="Room2D">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Room2D</span><span class="p">(</span><span class="n">_BaseGeometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A volume defined by an extruded floor plate, representing a single room or space.</span>

<span class="sd">    Args:</span>
<span class="sd">        identifier: Text string for a unique Room2D ID. Must be &lt; 100 characters and</span>
<span class="sd">            not contain any spaces or special characters.</span>
<span class="sd">        floor_geometry: A single horizontal Face3D object representing the</span>
<span class="sd">            floor plate of the Room. Note that this Face3D must be horizontal</span>
<span class="sd">            to be valid.</span>
<span class="sd">        floor_to_ceiling_height: A number for the height above the floor where the</span>
<span class="sd">            ceiling begins. This should be in the same units system as the input</span>
<span class="sd">            floor_geometry. Typical values range from 3 to 5 meters.</span>
<span class="sd">        boundary_conditions: A list of boundary conditions that match the number of</span>
<span class="sd">            segments in the input floor_geometry. These will be used to assign</span>
<span class="sd">            boundary conditions to each of the walls of the Room in the resulting</span>
<span class="sd">            model. If None, all boundary conditions will be Outdoors or Ground</span>
<span class="sd">            depending on whether ceiling of the room is below 0 (the assumed</span>
<span class="sd">            ground plane). Default: None.</span>
<span class="sd">        window_parameters: A list of WindowParameter objects that dictate how the</span>
<span class="sd">            window geometries will be generated for each of the walls. If None,</span>
<span class="sd">            no windows will exist over the entire Room2D. Default: None.</span>
<span class="sd">        shading_parameters: A list of ShadingParameter objects that dictate how the</span>
<span class="sd">            shade geometries will be generated for each of the walls. If None,</span>
<span class="sd">            no shades will exist over the entire Room2D. Default: None.</span>
<span class="sd">        is_ground_contact: A boolean noting whether this Room2D has its floor</span>
<span class="sd">            in contact with the ground. Default: False.</span>
<span class="sd">        is_top_exposed: A boolean noting whether this Room2D has its ceiling</span>
<span class="sd">            exposed to the outdoors. Default: False.</span>
<span class="sd">        tolerance: The maximum difference between z values at which point vertices</span>
<span class="sd">            are considered to be in the same horizontal plane. This is used to check</span>
<span class="sd">            that all vertices of the input floor_geometry lie in the same horizontal</span>
<span class="sd">            floor plane. Default is 0, which will not perform any check.</span>

<span class="sd">    Properties:</span>
<span class="sd">        * identifier</span>
<span class="sd">        * display_name</span>
<span class="sd">        * full_id</span>
<span class="sd">        * floor_geometry</span>
<span class="sd">        * floor_to_ceiling_height</span>
<span class="sd">        * boundary_conditions</span>
<span class="sd">        * window_parameters</span>
<span class="sd">        * shading_parameters</span>
<span class="sd">        * air_boundaries</span>
<span class="sd">        * is_ground_contact</span>
<span class="sd">        * is_top_exposed</span>
<span class="sd">        * has_floor</span>
<span class="sd">        * has_ceiling</span>
<span class="sd">        * ceiling_plenum_depth</span>
<span class="sd">        * floor_plenum_depth</span>
<span class="sd">        * zone</span>
<span class="sd">        * skylight_parameters</span>
<span class="sd">        * parent</span>
<span class="sd">        * has_parent</span>
<span class="sd">        * floor_segments</span>
<span class="sd">        * floor_segments_2d</span>
<span class="sd">        * segment_count</span>
<span class="sd">        * segment_normals</span>
<span class="sd">        * floor_height</span>
<span class="sd">        * ceiling_height</span>
<span class="sd">        * highest_plenum_floor_height</span>
<span class="sd">        * volume</span>
<span class="sd">        * floor_area</span>
<span class="sd">        * exterior_wall_area</span>
<span class="sd">        * interior_wall_area</span>
<span class="sd">        * exterior_window_area</span>
<span class="sd">        * skylight_area</span>
<span class="sd">        * exterior_aperture_area</span>
<span class="sd">        * wall_sub_face_area</span>
<span class="sd">        * roof_sub_face_area</span>
<span class="sd">        * sub_face_area</span>
<span class="sd">        * is_core</span>
<span class="sd">        * is_perimeter</span>
<span class="sd">        * min</span>
<span class="sd">        * max</span>
<span class="sd">        * center</span>
<span class="sd">        * user_data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;_floor_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;_segment_count&#39;</span><span class="p">,</span> <span class="s1">&#39;_floor_to_ceiling_height&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_boundary_conditions&#39;</span><span class="p">,</span> <span class="s1">&#39;_window_parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;_shading_parameters&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_air_boundaries&#39;</span><span class="p">,</span> <span class="s1">&#39;_is_ground_contact&#39;</span><span class="p">,</span> <span class="s1">&#39;_is_top_exposed&#39;</span><span class="p">,</span> <span class="s1">&#39;_has_floor&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_has_ceiling&#39;</span><span class="p">,</span> <span class="s1">&#39;_ceiling_plenum_depth&#39;</span><span class="p">,</span> <span class="s1">&#39;_floor_plenum_depth&#39;</span><span class="p">,</span> <span class="s1">&#39;_zone&#39;</span><span class="p">,</span>
        <span class="s1">&#39;_skylight_parameters&#39;</span><span class="p">,</span> <span class="s1">&#39;_parent&#39;</span><span class="p">,</span> <span class="s1">&#39;_abridged_properties&#39;</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">floor_geometry</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                 <span class="n">boundary_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">shading_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_ground_contact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A volume defined by an extruded floor plate, representing a single room.&quot;&quot;&quot;</span>
        <span class="n">_BaseGeometry</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">)</span>  <span class="c1"># process the identifier</span>

        <span class="c1"># process the floor_geometry</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">Face3D</span><span class="p">),</span> \
            <span class="s1">&#39;Expected ladybug_geometry Face3D. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">floor_geometry</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">floor_geometry</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ensure upward-facing Face3D</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">floor_geometry</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">floor_geometry</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="c1"># ensure a global 2D origin, which helps in solve adjacency and the dict schema</span>
        <span class="n">o_pl</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span>
                                      <span class="n">o_pl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>
        <span class="c1"># check that the floor_geometry lies in the same horizontal plane.</span>
        <span class="k">if</span> <span class="n">tolerance</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">z_vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">z_vals</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">z_vals</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">,</span> <span class="s1">&#39;Not all of Room2D &#39;</span> \
                <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot; vertices lie within the same horizontal plane.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">identifier</span><span class="p">)</span>

        <span class="c1"># process segment count and floor-to-ceiling height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">=</span> <span class="n">floor_to_ceiling_height</span>

        <span class="c1"># process the boundary conditions</span>
        <span class="k">if</span> <span class="n">boundary_conditions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bc</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_height</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">bc</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span>
                <span class="n">boundary_conditions</span><span class="p">,</span> <span class="s1">&#39;boundary_conditions&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">_BoundaryCondition</span><span class="p">),</span> \
                    <span class="s1">&#39;Expected BoundaryCondition. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># process the window and shading parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">window_parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shading_parameters</span> <span class="o">=</span> <span class="n">shading_parameters</span>

        <span class="c1"># ensure all wall-assigned objects align with the geometry if it has been flipped</span>
        <span class="k">if</span> <span class="n">floor_geometry</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win_pars</span><span class="p">,</span> <span class="n">new_shd_pars</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_flip_wall_assigned_objects</span><span class="p">(</span>
                <span class="n">floor_geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_win_pars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">new_shd_pars</span>

        <span class="c1"># process the top and bottom exposure properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span> <span class="o">=</span> <span class="n">is_ground_contact</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span> <span class="o">=</span> <span class="n">is_top_exposed</span>

        <span class="c1"># set defaults for all other properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will be set if it&#39;s ever used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># _parent will be set when Room2D is added to a Story</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># will be set when originating from abridged</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="n">Room2DProperties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># properties for extensions</span>

<div class="viewcode-block" id="Room2D.from_dict">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_dict">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">persist_abridged</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a Room2D from a dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            data: A dictionary representation of a Room2D object.</span>
<span class="sd">            tolerance: The maximum difference between z values at which point vertices</span>
<span class="sd">                are considered to be in the same horizontal plane. This is used to check</span>
<span class="sd">                that all vertices of the input floor_geometry lie in the same horizontal</span>
<span class="sd">                floor plane. Default is 0, which will not perform any check.</span>
<span class="sd">            persist_abridged: Set to True when the properties of the Room2D dictionary</span>
<span class="sd">                are abridged and you want to ensure that these exact same abridged</span>
<span class="sd">                properties persist into the output of Room2D.to_dict(abridged=True).</span>
<span class="sd">                It is useful when trying to edit the Room2D independently of a</span>
<span class="sd">                Model and there are no plans to edit any extension properties of</span>
<span class="sd">                the Room2D. THIS IS AN ADVANCED OPTION. (Default: False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check the type of dictionary</span>
        <span class="k">assert</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Room2D&#39;</span><span class="p">,</span> <span class="s1">&#39;Expected Room2D dictionary. &#39;</span> \
            <span class="s1">&#39;Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>

        <span class="c1"># re-assemble the floor_geometry</span>
        <span class="n">bound_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_height&#39;</span><span class="p">])</span>
                       <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_boundary&#39;</span><span class="p">]]</span>
        <span class="k">if</span> <span class="s1">&#39;floor_holes&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">hole_verts</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_height&#39;</span><span class="p">])</span>
                          <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_holes&#39;</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hole_verts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">hole_verts</span><span class="p">)</span>

        <span class="c1"># re-assemble boundary conditions</span>
        <span class="k">if</span> <span class="s1">&#39;boundary_conditions&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;boundary_conditions&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">b_conditions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bc_dict</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;boundary_conditions&#39;</span><span class="p">]:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">bc_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">hbc</span><span class="p">,</span> <span class="n">bc_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s1">&#39;Boundary condition &quot;</span><span class="si">{}</span><span class="s1">&quot; is not supported in this honeybee &#39;</span>
                        <span class="s1">&#39;installation.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bc_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span>
                <span class="n">b_conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc_class</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">bc_dict</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b_conditions</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># re-assemble window parameters</span>
        <span class="k">if</span> <span class="s1">&#39;window_parameters&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;window_parameters&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">glz_pars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">glz_dict</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;window_parameters&#39;</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">glz_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">glz_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;DetailedWindows&#39;</span><span class="p">:</span>
                        <span class="n">segment</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">floor_segment_by_index</span><span class="p">(</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">glz_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DetailedWindows</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">glz_dict</span><span class="p">,</span> <span class="n">segment</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">glz_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">glzpar</span><span class="p">,</span> <span class="n">glz_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
                        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s1">&#39;Window parameter &quot;</span><span class="si">{}</span><span class="s1">&quot; is not recognized.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="n">glz_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span>
                        <span class="n">glz_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glz_class</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">glz_dict</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">glz_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glz_pars</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># re-assemble shading parameters</span>
        <span class="k">if</span> <span class="s1">&#39;shading_parameters&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;shading_parameters&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shd_pars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">shd_dict</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;shading_parameters&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">shd_dict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">shd_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">shdpar</span><span class="p">,</span> <span class="n">shd_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;Shading parameter &quot;</span><span class="si">{}</span><span class="s1">&quot; is not recognized.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="n">shd_dict</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span>
                    <span class="n">shd_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shd_class</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">shd_dict</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">shd_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shd_pars</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># get the top and bottom exposure properties</span>
        <span class="n">grnd</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;is_ground_contact&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;is_ground_contact&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">top</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;is_top_exposed&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;is_top_exposed&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">flr</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;has_floor&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;has_floor&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">else</span> <span class="kc">True</span>
        <span class="n">ceil</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;has_ceiling&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;has_ceiling&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">else</span> <span class="kc">True</span>
        <span class="n">flr_pln</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_plenum_depth&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;floor_plenum_depth&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">ceil_pln</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ceiling_plenum_depth&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;ceiling_plenum_depth&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="c1"># create the Room2D object</span>
        <span class="n">room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;identifier&#39;</span><span class="p">],</span> <span class="n">floor_geometry</span><span class="p">,</span>
                      <span class="n">data</span><span class="p">[</span><span class="s1">&#39;floor_to_ceiling_height&#39;</span><span class="p">],</span>
                      <span class="n">b_conditions</span><span class="p">,</span> <span class="n">glz_pars</span><span class="p">,</span> <span class="n">shd_pars</span><span class="p">,</span> <span class="n">grnd</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="n">room</span><span class="o">.</span><span class="n">has_floor</span> <span class="o">=</span> <span class="n">flr</span>
        <span class="n">room</span><span class="o">.</span><span class="n">has_ceiling</span> <span class="o">=</span> <span class="n">ceil</span>
        <span class="n">room</span><span class="o">.</span><span class="n">ceiling_plenum_depth</span> <span class="o">=</span> <span class="n">ceil_pln</span>
        <span class="n">room</span><span class="o">.</span><span class="n">floor_plenum_depth</span> <span class="o">=</span> <span class="n">flr_pln</span>
        <span class="k">if</span> <span class="s1">&#39;zone&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;zone&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;zone&#39;</span><span class="p">]</span>

        <span class="c1"># assign any skylight parameters if they are specified</span>
        <span class="k">if</span> <span class="s1">&#39;skylight_parameters&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sky_class</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">skypar</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Skylight parameter &quot;</span><span class="si">{}</span><span class="s1">&quot; is not recognized.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span>
            <span class="n">room</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="n">sky_class</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">])</span>

        <span class="c1"># set all of the other optional properties</span>
        <span class="k">if</span> <span class="s1">&#39;air_boundaries&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;air_boundaries&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">air_boundaries</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;air_boundaries&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;display_name&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;display_name&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;display_name&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;user_data&#39;</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;user_data&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;user_data&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Room2DProperties&#39;</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">_load_extension_attr_from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">persist_abridged</span> <span class="ow">and</span> \
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;Room2DPropertiesAbridged&#39;</span><span class="p">:</span>
            <span class="n">room</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">room</span></div>


<div class="viewcode-block" id="Room2D.from_honeybee">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_honeybee">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_honeybee</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a Room2D from a Honeybee Room.</span>

<span class="sd">        Note that Dragonfly Room2Ds are abstractions of Honeybee Rooms and there</span>
<span class="sd">        will be loss of information if the Honeybee Room is not an extruded floor</span>
<span class="sd">        plate or if extension properties are assigned to individual Faces</span>
<span class="sd">        or Apertures instead of at the Room level.</span>

<span class="sd">        If the Honeybee Room contains no Floor Faces, None will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            room: A Honeybee Room object.</span>
<span class="sd">            tolerance: The maximum difference between values at which point vertices</span>
<span class="sd">                are considered to be the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first get the floor_geometry for the Room2D using the horizontal boundary</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">flr_geo</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">horizontal_boundary</span><span class="p">(</span><span class="n">match_walls</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># not a closed volume; maybe using the floors could work</span>
            <span class="n">flr_geos</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">horizontal_floor_boundaries</span><span class="p">(</span>
                <span class="n">match_walls</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flr_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># degenerate room</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="n">flr_geos</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">flr_geos</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">flr_geo</span> <span class="o">=</span> <span class="n">flr_geos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># use the geometry with the largest area</span>
        <span class="n">flr_geo</span> <span class="o">=</span> <span class="n">flr_geo</span> <span class="k">if</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>

        <span class="c1"># match the segments of the floor geometry to walls of the Room</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="k">if</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
            <span class="n">flr_geo</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">hole_segments</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span>
        <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="n">window_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="n">air_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs</span><span class="p">):</span>
            <span class="n">wall_f</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_segment_wall_face</span><span class="p">(</span><span class="n">room</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wall_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wall_f</span><span class="o">.</span><span class="n">boundary_condition</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">_apertures</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">_doors</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sf_objs</span> <span class="o">=</span> <span class="n">wall_f</span><span class="o">.</span><span class="n">_apertures</span> <span class="o">+</span> <span class="n">wall_f</span><span class="o">.</span><span class="n">_doors</span>
                    <span class="n">w_geos</span> <span class="o">=</span> <span class="p">[</span><span class="n">sf</span><span class="o">.</span><span class="n">geometry</span> <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">sf_objs</span><span class="p">]</span>
                    <span class="n">is_drs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">Door</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sf</span><span class="o">.</span><span class="n">is_glass</span> <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">sf_objs</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.01</span><span class="p">:</span>  <span class="c1"># vertical wall</span>
                        <span class="n">window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">from_face3ds</span><span class="p">(</span>
                            <span class="n">w_geos</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">is_drs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># angled wall; scale the Y to covert to vertical</span>
                        <span class="n">w_p</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
                        <span class="n">w3d</span> <span class="o">=</span> <span class="p">[</span><span class="n">Face3D</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">w_p</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">w_p</span><span class="o">.</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">geo</span><span class="o">.</span><span class="n">boundary</span><span class="p">])</span>
                               <span class="k">for</span> <span class="n">geo</span> <span class="ow">in</span> <span class="n">w_geos</span><span class="p">]</span>
                        <span class="n">window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">from_face3ds</span><span class="p">(</span>
                            <span class="n">w3d</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">is_drs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">AirBoundary</span><span class="p">):</span>
                    <span class="n">air_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># determine the ceiling height</span>
        <span class="n">horiz_roofs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">roof_ceilings</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">face</span><span class="o">.</span><span class="n">tilt</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># use one degree tolerance</span>
                <span class="n">horiz_roofs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">horiz_roofs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ceiling_height</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">horiz_roofs</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">horiz_roofs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ceiling_height</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>
        <span class="n">floor_to_ceiling_height</span> <span class="o">=</span> <span class="n">ceiling_height</span> <span class="o">-</span> <span class="n">room</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span>

        <span class="c1"># determine the top/bottom boundary conditions</span>
        <span class="n">is_ground_contact</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">boundary_condition</span><span class="p">,</span> <span class="n">Ground</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">Floor</span><span class="p">)])</span>
        <span class="n">is_top_exposed</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">boundary_condition</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span>
                              <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">RoofCeiling</span><span class="p">)])</span>
        <span class="n">ex_floor</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">AirBoundary</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">altitude</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">89.0</span><span class="p">])</span>
        <span class="n">ex_ceiling</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">AirBoundary</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">altitude</span> <span class="o">&gt;</span> <span class="mf">89.0</span><span class="p">])</span>

        <span class="c1"># create the Dragonfly Room2D</span>
        <span class="n">room_2d</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">room</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">flr_geo</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
            <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">window_parameters</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">is_ground_contact</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">has_floor</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">ex_floor</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">has_ceiling</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">ex_ceiling</span>
        <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">_zone</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room_2d</span><span class="o">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">zone</span>

        <span class="c1"># check if there are any skylights to be added</span>
        <span class="n">skylights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">RoofCeiling</span><span class="p">)</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">tilt</span> <span class="o">&lt;</span> <span class="mi">89</span><span class="p">:</span>
                <span class="n">sf_objs</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">_apertures</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="n">_doors</span>
                <span class="n">skylights</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sf_objs</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skylights</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">room_2d</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="n">DetailedSkylights</span><span class="o">.</span><span class="n">from_honeybee</span><span class="p">(</span><span class="n">skylights</span><span class="p">)</span>

        <span class="c1"># add the extra optional attributes</span>
        <span class="n">final_ab</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">air_bounds</span><span class="p">,</span> <span class="n">room_2d</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="n">v_f</span> <span class="o">=</span> <span class="n">v</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
            <span class="n">final_ab</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v_f</span><span class="p">)</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">air_boundaries</span> <span class="o">=</span> <span class="n">final_ab</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">_display_name</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">room</span><span class="o">.</span><span class="n">user_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">room_2d</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">from_honeybee</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">room_2d</span></div>


<div class="viewcode-block" id="Room2D.from_polygon">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_polygon">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_polygon</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                     <span class="n">boundary_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">shading_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_ground_contact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">is_top_exposed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Room2D from a ladybug-geometry Polygon2D and a floor_height.</span>

<span class="sd">        Note that this method is not recommended for a Room with one or more holes</span>
<span class="sd">        (like a courtyard) since polygons cannot have holes within them.</span>

<span class="sd">        Args:</span>
<span class="sd">            identifier: Text string for a unique Room2D ID. Must be &lt; 100 characters</span>
<span class="sd">                and not contain any spaces or special characters.</span>
<span class="sd">            polygon: A single Polygon2D object representing the floor plate of the Room.</span>
<span class="sd">            floor_height: A float value to place the polygon within 3D space.</span>
<span class="sd">            floor_to_ceiling_height: A number for the height above the floor where the</span>
<span class="sd">                ceiling begins. Typical values range from 3 to 5 meters.</span>
<span class="sd">            boundary_conditions: A list of boundary conditions that match the number of</span>
<span class="sd">                segments in the input floor_geometry. These will be used to assign</span>
<span class="sd">                boundary conditions to each of the walls of the Room in the resulting</span>
<span class="sd">                model. If None, all boundary conditions will be Outdoors or Ground</span>
<span class="sd">                depending on whether ceiling of the room is below 0 (the assumed</span>
<span class="sd">                ground plane). Default: None.</span>
<span class="sd">            window_parameters: A list of WindowParameter objects that dictate how the</span>
<span class="sd">                window geometries will be generated for each of the walls. If None,</span>
<span class="sd">                no windows will exist over the entire Room2D. Default: None.</span>
<span class="sd">            shading_parameters: A list of ShadingParameter objects that dictate how the</span>
<span class="sd">                shade geometries will be generated for each of the walls. If None,</span>
<span class="sd">                no shades will exist over the entire Room2D. Default: None.</span>
<span class="sd">            is_ground_contact: A boolean to note whether this Room2D has its floor</span>
<span class="sd">                in contact with the ground. Default: False.</span>
<span class="sd">            is_top_exposed: A boolean to note whether this Room2D has its ceiling</span>
<span class="sd">                exposed to the outdoors. Default: False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check the input polygon and ensure it&#39;s counter-clockwise</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">Polygon2D</span><span class="p">),</span> \
            <span class="s1">&#39;Expected ladybug_geometry Polygon2D. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">polygon</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_clockwise</span><span class="p">:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">boundary_conditions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">boundary_conditions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">boundary_conditions</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">window_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_win_pars</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">win_par</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">segments</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">window_parameters</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win_par</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                        <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_par</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_par</span><span class="p">)</span>
                <span class="n">window_parameters</span> <span class="o">=</span> <span class="n">new_win_pars</span>
            <span class="k">if</span> <span class="n">shading_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shading_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">shading_parameters</span><span class="p">))</span>

        <span class="c1"># build the Face3D without using right-hand rule to ensure alignment w/ bcs</span>
        <span class="n">base_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">))</span>
        <span class="n">vert3d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">base_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">_v</span> <span class="ow">in</span> <span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">vert3d</span><span class="p">,</span> <span class="n">base_plane</span><span class="p">,</span> <span class="n">enforce_right_hand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">identifier</span><span class="p">,</span> <span class="n">floor_geometry</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                   <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">window_parameters</span><span class="p">,</span> <span class="n">shading_parameters</span><span class="p">,</span>
                   <span class="n">is_ground_contact</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.from_vertices">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.from_vertices">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_vertices</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                      <span class="n">boundary_conditions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">shading_parameters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_ground_contact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">is_top_exposed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Room2D from 2D vertices with each vertex as an iterable of 2 floats.</span>

<span class="sd">        Note that this method is not recommended for a Room with one or more holes</span>
<span class="sd">        (like a courtyard) since the distinction between hole vertices and boundary</span>
<span class="sd">        vertices cannot be derived from a single list of vertices.</span>

<span class="sd">        Args:</span>
<span class="sd">            identifier: Text string for a unique Room2D ID. Must be &lt; 100 characters</span>
<span class="sd">                and not contain any spaces or special characters.</span>
<span class="sd">            vertices: A flattened list of 2 or more vertices as (x, y) that trace</span>
<span class="sd">                the outline of the floor plate.</span>
<span class="sd">            floor_height: A float value to place the polygon within 3D space.</span>
<span class="sd">            floor_to_ceiling_height: A number for the height above the floor where the</span>
<span class="sd">                ceiling begins. Typical values range from 3 to 5 meters.</span>
<span class="sd">            boundary_conditions: A list of boundary conditions that match the number of</span>
<span class="sd">                segments in the input floor_geometry. These will be used to assign</span>
<span class="sd">                boundary conditions to each of the walls of the Room in the resulting</span>
<span class="sd">                model. If None, all boundary conditions will be Outdoors or Ground</span>
<span class="sd">                depending on whether ceiling of the room is below 0 (the assumed</span>
<span class="sd">                ground plane). Default: None.</span>
<span class="sd">            window_parameters: A list of WindowParameter objects that dictate how the</span>
<span class="sd">                window geometries will be generated for each of the walls. If None,</span>
<span class="sd">                no windows will exist over the entire Room2D. Default: None.</span>
<span class="sd">            shading_parameters: A list of ShadingParameter objects that dictate how the</span>
<span class="sd">                shade geometries will be generated for each of the walls. If None,</span>
<span class="sd">                no shades will exist over the entire Room2D. Default: None.</span>
<span class="sd">            is_ground_contact: A boolean to note whether this Room2D has its floor</span>
<span class="sd">                in contact with the ground. Default: False.</span>
<span class="sd">            is_top_exposed: A boolean to note whether this Room2D has its ceiling</span>
<span class="sd">                exposed to the outdoors. Default: False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Point2D</span><span class="p">(</span><span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_polygon</span><span class="p">(</span>
            <span class="n">identifier</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">floor_height</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="p">,</span>
            <span class="n">boundary_conditions</span><span class="p">,</span> <span class="n">window_parameters</span><span class="p">,</span> <span class="n">shading_parameters</span><span class="p">,</span>
            <span class="n">is_ground_contact</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A horizontal Face3D object representing the floor plate of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_to_ceiling_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a number for the distance between the floor and the ceiling.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span>

    <span class="nd">@floor_to_ceiling_height</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_to_ceiling_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span> <span class="o">=</span> <span class="n">float_positive</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;floor-to-ceiling height&#39;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Room2D floor-to-ceiling height &#39;</span> \
            <span class="s1">&#39;cannot be zero.&#39;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">boundary_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a tuple of boundary conditions for the wall boundary conditions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">)</span>

    <span class="nd">@boundary_conditions</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">boundary_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;boundary conditions&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">,</span> <span class="s1">&#39;Expected BoundaryCondition. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)),</span> \
                    <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> cannot be assigned to a wall with windows.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">window_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a tuple of WindowParameters describing how to generate windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">)</span>

    <span class="nd">@window_parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">window_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;window_parameters&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">_WindowParameterBase</span><span class="p">),</span> \
                        <span class="s1">&#39;Expected Window Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="p">(</span><span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)),</span> \
                        <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> cannot be assigned to a wall with windows.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shading_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a tuple of ShadingParameters describing how to generate shades.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">)</span>

    <span class="nd">@shading_parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shading_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;shading_parameters&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">_ShadingParameterBase</span><span class="p">),</span> \
                        <span class="s1">&#39;Expected Shading Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">air_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a tuple of booleans for whether each wall has an air boundary type.</span>

<span class="sd">        False values indicate a standard opaque type while True values indicate</span>
<span class="sd">        an AirBoundary type. All walls will be False by default. Note that any</span>
<span class="sd">        walls with a True air boundary must have a Surface boundary condition</span>
<span class="sd">        without any windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">)</span>

    <span class="nd">@air_boundaries</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">air_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_wall_assigned_object</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;air boundaries&#39;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="nb">bool</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
            <span class="n">all_props</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">bnd</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="n">all_props</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bnd</span><span class="p">,</span> <span class="n">Surface</span><span class="p">),</span> <span class="s1">&#39;Air boundaries must be assigned &#39;</span> \
                        <span class="s1">&#39;to walls with Surface boundary conditions. Not </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bnd</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">glz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> \
                        <span class="s1">&#39;Air boundaries cannot be assigned to a wall with windows.&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_ground_contact</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a boolean noting whether the floor is in contact with the ground.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span>

    <span class="nd">@is_ground_contact</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_ground_contact</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_top_exposed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a boolean noting whether the ceiling is exposed to the outdoors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span>

    <span class="nd">@is_top_exposed</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_top_exposed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_floor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a boolean for whether the room has a Floor or an AirBoundary.</span>

<span class="sd">        If False (for AirBoundary), this property will only be meaningful if the</span>
<span class="sd">        model is translated to Honeybee with ceiling adjacency solved and there</span>
<span class="sd">        is a Room2D below this one with a has_ceiling property set to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span>

    <span class="nd">@has_floor</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_floor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_ceiling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a boolean for whether the room has a RoofCeiling or an AirBoundary.</span>

<span class="sd">        If False (for AirBoundary), this property will only be meaningful if the</span>
<span class="sd">        model is translated to Honeybee with ceiling adjacency solved and there</span>
<span class="sd">        is a Room2D above this one with a has_floor property set to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span>

    <span class="nd">@has_ceiling</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_ceiling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ceiling_plenum_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a number for the depth that a ceiling plenum extends into the room.</span>

<span class="sd">        Setting this to a positive value will result in a separate plenum room being</span>
<span class="sd">        split off of the Room2D volume during translation from Dragonfly to Honeybee.</span>
<span class="sd">        The bottom of this ceiling plenum will always be at this Room2D&#39;s ceiling_height</span>
<span class="sd">        minus the ceiling_plenum_depth specified here. Setting this to zero indicates</span>
<span class="sd">        that the room has no ceiling plenum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span>

    <span class="nd">@ceiling_plenum_depth</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ceiling_plenum_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="n">float_positive</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;ceiling plenum depth&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_plenum_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set a number for the depth that a floor plenum extends into the room.</span>

<span class="sd">        Setting this to a positive value will result in a separate plenum room being</span>
<span class="sd">        split off of the Room2D volume during translation from Dragonfly to Honeybee.</span>
<span class="sd">        The top of this floor plenum will always be at this Room2D&#39;s floor_height</span>
<span class="sd">        plus the floor_plenum_depth specified here. Setting this to zero indicates</span>
<span class="sd">        that the room has no floor plenum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span>

    <span class="nd">@floor_plenum_depth</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_plenum_depth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="n">float_positive</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;floor plenum depth&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set text for the zone identifier to which this Room2D belongs.</span>

<span class="sd">        Room2Ds sharing the same zone identifier are considered part of the same</span>
<span class="sd">        zone in a Building. If the zone identifier has not been specified, it</span>
<span class="sd">        will be the same as the Room2D identifier.</span>

<span class="sd">        Note that the zone identifier has no character restrictions much</span>
<span class="sd">        like display_name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identifier</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span>

    <span class="nd">@zone</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>  <span class="c1"># Python 2 machine lacking the character set</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># keep it as unicode</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">skylight_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get or set SkylightParameters describing how to generate skylights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span>

    <span class="nd">@skylight_parameters</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">skylight_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_SkylightParameterBase</span><span class="p">),</span> \
                <span class="s1">&#39;Expected Skylight Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the parent Story if it is assigned. None if it is not assigned.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a boolean noting whether this Room2D has a parent Story.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of LineSegment3D objects for each wall of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> \
            <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">hole_segments</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_segments_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of LineSegment2D objects for each wall of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">segments</span> <span class="k">if</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">hole_polygon2d</span>
                  <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">segment_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of segments making up the floor geometry.</span>

<span class="sd">        This is equal to the number of walls making up the Room.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">segment_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of Vector2D objects for the normal of each segment.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Vector2D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number for the height of the floor above the ground.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ceiling_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number for the height of the ceiling above the ground.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">highest_plenum_floor_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number for the highest floor height in the Room2D including plenums.</span>

<span class="sd">        When the Room2D has a ceiling plenum, this will be the floor height of</span>
<span class="sd">        the plenum. Otherwise, it is the floor height of the base room. This</span>
<span class="sd">        property is useful for checking that roof geometries do not collide with</span>
<span class="sd">        a room floor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_plenum_depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_height</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_plenum_depth</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_plenum_depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_plenum_depth</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number for the volume of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_area</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number for the floor area of the Room.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">area</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">exterior_wall_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the total area of the Room walls with an Outdoors boundary condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wall_areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">):</span>
                <span class="n">wall_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">wall_areas</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interior_wall_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the total area of the Room walls without an Outdoors or Ground BC.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wall_areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="p">(</span><span class="n">Outdoors</span><span class="p">,</span> <span class="n">Ground</span><span class="p">)):</span>
                <span class="n">wall_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">wall_areas</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">exterior_window_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the total area of the Room Apertures in walls with an Outdoors BC.</span>

<span class="sd">        This only refers to Apertures and excludes Doors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">glz_areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span> <span class="ow">and</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">glz</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                    <span class="n">area</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">aperture_area_from_segment</span><span class="p">(</span>
                        <span class="n">seg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">area</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">area_from_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
                <span class="n">glz_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">glz_areas</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">skylight_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the total aperture area of Room&#39;s skylights.</span>

<span class="sd">        This only refers to Apertures and excludes overhead Doors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sky_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span>
            <span class="k">return</span> <span class="n">sky_par</span><span class="o">.</span><span class="n">area_from_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">)</span> \
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sky_par</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">)</span> <span class="k">else</span> \
                <span class="n">sky_par</span><span class="o">.</span><span class="n">aperture_area_from_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">exterior_aperture_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the total Aperture area of the Room with an Outdoors boundary condition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exterior_window_area</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_area</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wall_sub_face_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a the total sub-face area of the Room&#39;s walls.</span>

<span class="sd">        This includes both Apertures and Doors in both interior and exterior walls.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">glz_areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">area</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">area_from_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
                <span class="n">glz_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">glz_areas</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">roof_sub_face_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a the total sub-face area of the Room&#39;s roofs.</span>

<span class="sd">        This includes both Apertures and overhead Doors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sky_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span>
            <span class="k">return</span> <span class="n">sky_par</span><span class="o">.</span><span class="n">area_from_face</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sub_face_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a the total sub-face area of the Room.</span>

<span class="sd">        This includes both Apertures and Doors in both walls and roofs for all</span>
<span class="sd">        accepted boundary conditions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wall_sub_face_area</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">roof_sub_face_area</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_core</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a boolean for whether the Room2D is in the core of a story.</span>

<span class="sd">        Core Room2Ds have no walls exposed to the outdoors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exterior_wall_area</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a boolean for whether the Room2D is on the perimeter of a story.</span>

<span class="sd">        Perimeter Room2Ds have walls exposed to the outdoors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exterior_wall_area</span> <span class="o">!=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Point2D for the min bounding rectangle vertex in the XY plane.</span>

<span class="sd">        This is useful in calculations to determine if this Room2D is in proximity</span>
<span class="sd">        to other Room2Ds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">min</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Point2D for the max bounding rectangle vertex in the XY plane.</span>

<span class="sd">        This is useful in calculations to determine if this Room2D is in proximity</span>
<span class="sd">        to other Room2Ds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">max</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Point2D for the center bounding rectangle vertex in the XY plane.</span>

<span class="sd">        This is useful in calculations to determine if this Room2D is inside</span>
<span class="sd">        other polygons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">center</span>

<div class="viewcode-block" id="Room2D.label_point">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.label_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">label_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Point3D to label this Room2D in 3D space.</span>

<span class="sd">        This point will always lie within the polygon formed by the floor_geometry</span>
<span class="sd">        regardless of whether this geometry is concave or has holes.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The tolerance to which the pole_of_inaccessibility will</span>
<span class="sd">                be computed in the event that the floor_geometry is concave or</span>
<span class="sd">                has holes. Note that this does not need to be equal to the Model</span>
<span class="sd">                tolerance and should usually be larger than the Model tolerance</span>
<span class="sd">                to avoid long calculation times. (Default: 0.01).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">center</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">is_convex</span> <span class="k">else</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">pole_of_inaccessibility</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.segment_orientations">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.segment_orientations">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">segment_orientations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">north_vector</span><span class="o">=</span><span class="n">Vector2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A list of numbers between 0 and 360 for the orientation of the segments.</span>

<span class="sd">        0 = North, 90 = East, 180 = South, 270 = West</span>

<span class="sd">        Args:</span>
<span class="sd">            north_vector: A ladybug_geometry Vector2D for the north direction.</span>
<span class="sd">                Default is the Y-axis (0, 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="p">(</span><span class="n">Vector2D</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">sg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">north_vector</span><span class="o">.</span><span class="n">angle_clockwise</span><span class="p">(</span><span class="n">norm</span><span class="p">))</span> <span class="k">for</span> <span class="n">norm</span> <span class="ow">in</span> <span class="n">normals</span><span class="p">]</span></div>


<div class="viewcode-block" id="Room2D.average_orientation">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.average_orientation">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">average_orientation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">north_vector</span><span class="o">=</span><span class="n">Vector2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a number between 0 and 360 for the average orientation of exterior walls.</span>

<span class="sd">        0 = North, 90 = East, 180 = South, 270 = West.  Will be None if the room has</span>
<span class="sd">        no exterior walls. Resulting value is weighted by the area of each of the</span>
<span class="sd">        wall faces.</span>

<span class="sd">        Args:</span>
<span class="sd">            north_vector: A ladybug_geometry Vector2D for the north direction.</span>
<span class="sd">                Default is the Y-axis (0, 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orientations</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">seg_lengths</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">):</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">orient</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">north_vector</span><span class="o">.</span><span class="n">angle_clockwise</span><span class="p">(</span><span class="n">norm</span><span class="p">))</span>
                <span class="n">orientations</span> <span class="o">+=</span> <span class="n">orient</span> <span class="o">*</span> <span class="n">seg</span><span class="o">.</span><span class="n">length</span>
                <span class="n">seg_lengths</span> <span class="o">+=</span> <span class="n">seg</span><span class="o">.</span><span class="n">length</span>
        <span class="k">return</span> <span class="n">orientations</span> <span class="o">/</span> <span class="n">seg_lengths</span> <span class="k">if</span> <span class="n">seg_lengths</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Room2D.segment_indices_by_guide_lines">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.segment_indices_by_guide_lines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">segment_indices_by_guide_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the indices of segments in this Room2D that lie along given guide lines.</span>

<span class="sd">        The resulting indices can be used to set boundary conditions, windows,</span>
<span class="sd">        adjacencies, etc. for segments on this Room2D.</span>

<span class="sd">        Args:</span>
<span class="sd">            lines: A list of LineSegment2D objects to note which segment indices</span>
<span class="sd">                should be returned.</span>
<span class="sd">            tolerance: The maximum difference in coordinate values for them</span>
<span class="sd">                to be considered touching. (Default: 0.01).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seg_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seg_on_guide_lines</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                <span class="n">seg_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seg_indices</span></div>


<div class="viewcode-block" id="Room2D.overlap_area">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.overlap_area">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlap_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_room2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the area of this Room2D that overlaps with another Room2D.</span>

<span class="sd">        This is useful for helping identify cases where a given Room2D might be an</span>
<span class="sd">        updated version of this Room2D (in the same location within a larger Story)</span>
<span class="sd">        and should therefore replace this Room2D. This method first performs a</span>
<span class="sd">        bounding rectangle check between the Room2Ds to evaluate whether an overlap</span>
<span class="sd">        is possible before computing the percentage, making it efficient to run</span>
<span class="sd">        with large groups of Room2Ds.</span>

<span class="sd">        Args:</span>
<span class="sd">            other_room_2d: Another Room2D object to be checked for overlap with</span>
<span class="sd">                this one.</span>
<span class="sd">            tolerance: The maximum difference in coordinate values that the</span>
<span class="sd">                room vertices must have for them to be considered</span>
<span class="sd">                overlapping. (Default: 0.01).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check whether the bounding rectangles around the geometry overlap</span>
        <span class="n">self_face</span><span class="p">,</span> <span class="n">other_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">other_room2d</span><span class="o">.</span><span class="n">floor_geometry</span>
        <span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span> <span class="o">=</span> <span class="n">self_face</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">other_face</span><span class="o">.</span><span class="n">boundary_polygon2d</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">overlapping_bounding_rect</span><span class="p">(</span><span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># no overlap in bounding rect; gap impossible</span>
        <span class="c1"># perform a boolean intersection operation between the two floor Face3Ds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span>
        <span class="n">ang_tol</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">m_vec</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">-</span> <span class="n">other_room2d</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span>
        <span class="n">new_geos</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">coplanar_intersection</span><span class="p">(</span>
            <span class="n">self_face</span><span class="p">,</span> <span class="n">other_face</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">m_vec</span><span class="p">),</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">ang_tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_geos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>  <span class="c1"># the Face3Ds did not overlap with one another</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_geos</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.relevant_roof_geometry">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.relevant_roof_geometry">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">relevant_roof_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of Face3D for roof geometries that are relevant for this Room2D.</span>

<span class="sd">        This will be an empty list if the room has not parent Story, the parent</span>
<span class="sd">        Story has no roof or the roof of the parent story has no geometries that</span>
<span class="sd">        lie above the Room2D.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The maximum difference in coordinate values that the</span>
<span class="sd">                room vertices must have for them to be considered</span>
<span class="sd">                overlapping. (Default: 0.01).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check that there&#39;s a parent roof</span>
        <span class="n">rel_roofs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_parent</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">roof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">rel_roofs</span>
        <span class="c1"># loop through the roof geometries and grab all that overlap</span>
        <span class="n">roof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">roof</span>
        <span class="k">for</span> <span class="n">r_geo</span><span class="p">,</span> <span class="n">r_poly</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">roof</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">roof</span><span class="o">.</span><span class="n">boundary_geometry_2d</span><span class="p">):</span>
            <span class="n">self_poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span>
            <span class="k">if</span> <span class="n">self_poly</span><span class="o">.</span><span class="n">polygon_relationship</span><span class="p">(</span><span class="n">r_poly</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rel_roofs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_geo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rel_roofs</span></div>


<div class="viewcode-block" id="Room2D.unconforming_vertex_map">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.unconforming_vertex_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">unconforming_vertex_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Analyze this Room2D&#39;s vertices for conformity with a plane&#39;s XY axes.</span>

<span class="sd">        Vertices of this Room2D that do not conform to the plane will be</span>
<span class="sd">        highted in the result.</span>

<span class="sd">        Args:</span>
<span class="sd">            plane: A ladybug-geometry Plane that will be used to evaluate whether</span>
<span class="sd">                each Room2D vertex conforms to the plane or not.</span>
<span class="sd">            angle_tolerance: A number for the maximum difference in degrees that the</span>
<span class="sd">                Room2D segments can differ from the XY axes of the plane for it</span>
<span class="sd">                to be considered non-conforming. (Default: 1.0).</span>
<span class="sd">            min_length: A number for the minimum length that a Room2D segment must</span>
<span class="sd">                be for it to be considered for non-conformity. Setting this to</span>
<span class="sd">                zero will evaluate all Room2D segments. (Default: 0).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of lists where each sub-list represents a loop of the Room2D</span>
<span class="sd">            floor_geometry. The first sub-list represents the boundary and subsequent</span>
<span class="sd">            sub-lists represent holes. Each item in each sub-list represents a</span>
<span class="sd">            vertex. If a given vertex is conforming to the plane, it will show</span>
<span class="sd">            up as None in the sub-list. Otherwise, the Point3D for the non-conforming</span>
<span class="sd">            vertex will appear in the sub-list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># define variables to be used throughout the evaluation</span>
        <span class="n">min_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">max_ang</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">min_ang</span>
        <span class="n">x_axis</span><span class="p">,</span> <span class="n">y_axis</span> <span class="o">=</span> <span class="n">plane</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">y</span>
        <span class="n">seg_loops</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">seg_loops</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">hole_segments</span><span class="p">)</span>

        <span class="c1"># loop through the segments and evaluate their non-conformity</span>
        <span class="n">conform</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg_loop</span> <span class="ow">in</span> <span class="n">seg_loops</span><span class="p">:</span>
            <span class="n">loop_conform</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">seg_loop</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">min_length</span><span class="p">:</span>
                    <span class="n">loop_conform</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>  <span class="c1"># duplicate vertex</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">ang</span> <span class="o">&lt;</span> <span class="n">min_ang</span> <span class="ow">or</span> <span class="n">ang</span> <span class="o">&gt;</span> <span class="n">max_ang</span><span class="p">:</span>
                    <span class="n">loop_conform</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">ang</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">y_axis</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ang</span> <span class="o">&lt;</span> <span class="n">min_ang</span> <span class="ow">or</span> <span class="n">ang</span> <span class="o">&gt;</span> <span class="n">max_ang</span><span class="p">:</span>
                    <span class="n">loop_conform</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">loop_conform</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">conform</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_conform</span><span class="p">)</span>

        <span class="c1"># evaluate vertices in relation to surrounding segments</span>
        <span class="n">points_to_keep</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg_loop</span><span class="p">,</span> <span class="n">conformity</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">seg_loops</span><span class="p">,</span> <span class="n">conform</span><span class="p">):</span>
            <span class="n">loop_points</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">con</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">seg_loop</span><span class="p">,</span> <span class="n">conformity</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">con</span> <span class="ow">or</span> <span class="n">conformity</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">loop_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">loop_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
            <span class="n">points_to_keep</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_points</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">points_to_keep</span></div>


<div class="viewcode-block" id="Room2D.apply_vertex_map">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.apply_vertex_map">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">apply_vertex_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex_map</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply a vertex map to this Room2D&#39;s vertices.</span>

<span class="sd">        Vertex maps are helpful for restoring vertices in Room2D geometry after</span>
<span class="sd">        performing a series of complex operations. For example, when performing</span>
<span class="sd">        a series of operations that edit the geometry in relation to a plane, a</span>
<span class="sd">        Room2D.unconforming_vertex_map() can be generated to put back the vertices</span>
<span class="sd">        that did not relate to the plane of the grid.</span>

<span class="sd">        Args:</span>
<span class="sd">            vertex_map: A list of lists where each sub-list represents a loop of</span>
<span class="sd">                the Room2D floor_geometry. The first sub-list represents the boundary</span>
<span class="sd">                and subsequent sub-lists represent holes. Each item in each sub-list</span>
<span class="sd">                represents a vertex. If a given vertex on this Room2D is to be left</span>
<span class="sd">                as it is, it should be represented as None in the sub-list.</span>
<span class="sd">                Otherwise, the Point3D to replace the vertex on this Room2D should</span>
<span class="sd">                appear in the sub-list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">pt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">sub_l</span> <span class="ow">in</span> <span class="n">vertex_map</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">sub_l</span><span class="p">):</span>
            <span class="k">return</span>
        <span class="n">final_boundary</span><span class="p">,</span> <span class="n">final_holes</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">new_pt</span><span class="p">,</span> <span class="n">old_pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">vertex_map</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">final_pt</span> <span class="o">=</span> <span class="n">new_pt</span> <span class="k">if</span> <span class="n">old_pt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">old_pt</span>
            <span class="n">final_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_pt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">final_holes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">new_hole</span><span class="p">,</span> <span class="n">old_hole</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">,</span> <span class="n">vertex_map</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">final_hole</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">new_pt</span><span class="p">,</span> <span class="n">old_pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_hole</span><span class="p">,</span> <span class="n">old_hole</span><span class="p">):</span>
                    <span class="n">final_pt</span> <span class="o">=</span> <span class="n">new_pt</span> <span class="k">if</span> <span class="n">old_pt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">old_pt</span>
                    <span class="n">final_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_pt</span><span class="p">)</span>
                <span class="n">final_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">final_hole</span><span class="p">)</span>
        <span class="n">f_pl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">final_boundary</span><span class="p">,</span> <span class="n">f_pl</span><span class="p">,</span> <span class="n">final_holes</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.set_outdoor_window_parameters">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_outdoor_window_parameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_outdoor_window_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window_parameter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all of the outdoor walls to have the same window parameters.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">window_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_parameter</span><span class="p">,</span> <span class="n">_WindowParameterBase</span><span class="p">),</span> \
                <span class="s1">&#39;Expected Window Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">window_parameter</span><span class="p">))</span>
        <span class="n">glz_ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">:</span>
            <span class="n">glz_p</span> <span class="o">=</span> <span class="n">window_parameter</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">glz_ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glz_p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">glz_ps</span></div>


<div class="viewcode-block" id="Room2D.set_outdoor_shading_parameters">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_outdoor_shading_parameters">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_outdoor_shading_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shading_parameter</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all of the outdoor walls to have the same shading parameters.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shading_parameter</span><span class="p">,</span> <span class="n">_ShadingParameterBase</span><span class="p">),</span> \
            <span class="s1">&#39;Expected Window Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">shading_parameter</span><span class="p">))</span>
        <span class="n">shd_ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">:</span>
            <span class="n">shd_p</span> <span class="o">=</span> <span class="n">shading_parameter</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">shd_ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shd_p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">shd_ps</span></div>


<div class="viewcode-block" id="Room2D.remove_doors">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_doors">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_doors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all doors from this Room2D.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg_indices: An optional list of integers for the wall segments of</span>
<span class="sd">                this Room2D for which doors should be removed. If None, all</span>
<span class="sd">                segments will be checked for doors to remove. (Default: None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_wp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">glz</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seg_indices</span><span class="p">:</span>
                    <span class="n">glz</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">remove_doors</span><span class="p">()</span>
            <span class="n">new_wp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">new_wp</span></div>


<div class="viewcode-block" id="Room2D.remove_small_windows">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_small_windows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_small_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_threshold</span><span class="p">,</span> <span class="n">seg_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove windows of the room that are smaller than a specified area threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_threshold: The area of a window below which it will be removed.</span>
<span class="sd">            seg_indices: An optional list of integers for the wall segments of</span>
<span class="sd">                this Room2D for which small windows should be removed. If None, all</span>
<span class="sd">                segments will be checked for small windows to remove. (Default: None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_wp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seg_indices</span><span class="p">:</span>
                    <span class="n">wp</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">remove_small_windows</span><span class="p">(</span><span class="n">area_threshold</span><span class="p">)</span>
            <span class="n">new_wp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">new_wp</span></div>


<div class="viewcode-block" id="Room2D.remove_small_skylights">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_small_skylights">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_small_skylights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove skylights of the room that are smaller than a specified area threshold.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_threshold: The area of a skylight below which it will be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span><span class="o">.</span><span class="n">remove_small_skylights</span><span class="p">(</span><span class="n">area_threshold</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.to_rectangular_windows">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_rectangular_windows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_rectangular_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert all of the windows of the Room2D to the RectangularWindows format.&quot;&quot;&quot;</span>
        <span class="n">glz_ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">glz</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">to_rectangular_windows</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
            <span class="n">glz_ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">glz_ps</span></div>


<div class="viewcode-block" id="Room2D.to_detailed_windows">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_detailed_windows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_detailed_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert all of the windows of the Room2D to the DetailedWindows format.&quot;&quot;&quot;</span>
        <span class="n">glz_ps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">glz</span><span class="p">,</span> <span class="n">DetailedWindows</span><span class="p">):</span>
                <span class="n">glz</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">to_rectangular_windows</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
                <span class="n">glz</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">to_detailed_windows</span><span class="p">()</span>
            <span class="n">glz_ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">glz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">glz_ps</span></div>


<div class="viewcode-block" id="Room2D.rectangularize_windows">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.rectangularize_windows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rectangularize_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percent_area_change_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">seg_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert detailed windows of the Room2D to rectangles.</span>

<span class="sd">        Note that rectangular conversion is done simply by taking the bounding</span>
<span class="sd">        rectangle around each polygon. If this bounding rectangle representation</span>
<span class="sd">        changes the area by more than the percent_area_change_threshold, it will</span>
<span class="sd">        not be converted to a rectangle.</span>

<span class="sd">        Args:</span>
<span class="sd">            percent_area_change_threshold: A positive number for the maximum permitted</span>
<span class="sd">                change in area that is allowed by the operation. For example, setting</span>
<span class="sd">                it to 100 will allow windows to double in size by this operation.</span>
<span class="sd">                Set to None to have all windows rectangularized no matter the</span>
<span class="sd">                change in area that this causes. (Default: None).</span>
<span class="sd">            seg_indices: An optional list of integers for the wall segments of</span>
<span class="sd">                this Room2D for which windows should be rectangularized. If None,</span>
<span class="sd">                all segments will have their windows rectangularized. (Default: None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">glz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">glz</span><span class="p">,</span> <span class="n">DetailedWindows</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seg_indices</span><span class="p">:</span>
                    <span class="n">glz</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">rectangularize</span><span class="p">(</span><span class="n">percent_area_change_threshold</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.assign_sub_faces">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.assign_sub_faces">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">assign_sub_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub_faces</span><span class="p">,</span> <span class="n">projection_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assign a list of orphaned SubFaces (Apertures and Doors) to this Room2D.</span>

<span class="sd">        The geometry of the SubFaces will automatically be converted to</span>
<span class="sd">        WindowParameters in the plane of each wall segment and appropriate is_door</span>
<span class="sd">        properties will be used to denote whether the projected SubFace is an</span>
<span class="sd">        Aperture vs. a Door. Doors with True is_glass properties will get a</span>
<span class="sd">        False is_door property such that they will transmit light in destination</span>
<span class="sd">        simulation engines.</span>

<span class="sd">        Args:</span>
<span class="sd">            sub_faces: A list of orphaned Honeybee Apertures and/or Doors to be</span>
<span class="sd">                assigned to this Room2D as WindowParameters and/or SkylightParameters.</span>
<span class="sd">                Large lists of all Apertures/Doors in a building can be plugged</span>
<span class="sd">                in here since fast bounding box checks are used to rule out any</span>
<span class="sd">                un-applicable geometries.</span>
<span class="sd">            projection_distance: An optional number to be used to project the</span>
<span class="sd">                Aperture/Door geometry onto parent wall segments. If specified,</span>
<span class="sd">                then SubFaces within this distance of the parent wall will be</span>
<span class="sd">                projected and added. Otherwise, Apertures/Doors will only be</span>
<span class="sd">                added if they are coplanar with the parent wall segment.</span>
<span class="sd">            overwrite: A boolean to note whether the existing window parameters</span>
<span class="sd">                should be overwritten with the newly-supplied sub faces or</span>
<span class="sd">                whether an attempt should be made to preserve existing windows/doors</span>
<span class="sd">                in which case sub-faces will only be replaced if they are perfectly</span>
<span class="sd">                duplicated between the current sub-faces and the newly-supplied</span>
<span class="sd">                sub-faces. Note that setting this to False can significantly</span>
<span class="sd">                increase the runtime since it requires translation to Honeybee</span>
<span class="sd">                to be able to sense when windows/doors are duplicated. (Default: True).</span>
<span class="sd">            tolerance: The minimum difference in coordinate values for them</span>
<span class="sd">                to be considered distinct from one another. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">            angle_tolerance: The max angle difference in degrees that wall segments</span>
<span class="sd">                and sub-faces can differ from one another in order for the sub-face</span>
<span class="sd">                to be projected onto the geometry. (Default: 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process the angle tolerance into criteria to be used to categorize sub-faces</span>
        <span class="n">a_tol_min</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">a_tol_max</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">a_tol_min</span>
        <span class="n">perp</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">perp_min</span><span class="p">,</span> <span class="n">perp_max</span> <span class="o">=</span> <span class="n">perp</span> <span class="o">-</span> <span class="n">a_tol_min</span><span class="p">,</span> <span class="n">perp</span> <span class="o">+</span> <span class="n">a_tol_min</span>

        <span class="c1"># determine criteria for the bounding box around the room</span>
        <span class="n">floor_segments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">ftc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_parent</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">roof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rel_roofs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">roof</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">roof</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">overlapping_bounding_rect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">roof</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                    <span class="n">rel_roofs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roof</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel_roofs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">max_roof</span> <span class="o">=</span> <span class="n">rel_roofs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>
                <span class="k">for</span> <span class="n">r_geo</span> <span class="ow">in</span> <span class="n">rel_roofs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="n">r_geo</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">max_roof</span><span class="p">:</span>
                        <span class="n">max_roof</span> <span class="o">=</span> <span class="n">r_geo</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>
                <span class="n">roof_ftc</span> <span class="o">=</span> <span class="n">max_roof</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span>
                <span class="k">if</span> <span class="n">roof_ftc</span> <span class="o">&gt;</span> <span class="n">ftc</span><span class="p">:</span>
                    <span class="n">ftc</span> <span class="o">=</span> <span class="n">roof_ftc</span>

        <span class="c1"># search all of the sub-faces that could be relevant</span>
        <span class="n">r_min_pt</span><span class="p">,</span> <span class="n">max_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">max</span>
        <span class="n">r_max_pt</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">max_pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max_pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">max_pt</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">ftc</span><span class="p">)</span>
        <span class="n">bb_diagonal</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">r_min_pt</span><span class="p">,</span> <span class="n">r_max_pt</span><span class="p">)</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">projection_distance</span> <span class="k">if</span> <span class="n">projection_distance</span> <span class="o">&gt;</span> <span class="n">tolerance</span> <span class="k">else</span> <span class="n">tolerance</span>
        <span class="n">sf_to_add</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">sub_faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">overlapping_bounding_boxes</span><span class="p">(</span><span class="n">bb_diagonal</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
                <span class="n">sf_to_add</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span>

        <span class="c1"># translate existing windows/doors and get a unique set if not overwrite</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="n">hb_room</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_honeybee</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">enforce_bc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="n">enforce_solid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">unique_ap</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e_ap</span> <span class="ow">in</span> <span class="n">hb_room</span><span class="o">.</span><span class="n">apertures</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n_sf</span> <span class="ow">in</span> <span class="n">sf_to_add</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_sf</span><span class="p">,</span> <span class="n">Aperture</span><span class="p">)</span> <span class="ow">and</span> \
                            <span class="n">n_sf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is_centered_adjacent</span><span class="p">(</span><span class="n">e_ap</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="k">break</span>  <span class="c1"># it&#39;s a duplicated in the input sub-faces</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unique_ap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_ap</span><span class="p">)</span>
            <span class="n">unique_dr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e_dr</span> <span class="ow">in</span> <span class="n">hb_room</span><span class="o">.</span><span class="n">doors</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n_sf</span> <span class="ow">in</span> <span class="n">sf_to_add</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n_sf</span><span class="p">,</span> <span class="n">Door</span><span class="p">)</span> <span class="ow">and</span> \
                            <span class="n">n_sf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">is_centered_adjacent</span><span class="p">(</span><span class="n">e_dr</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="k">break</span>  <span class="c1"># it&#39;s a duplicated in the input sub-faces</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unique_dr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e_dr</span><span class="p">)</span>
            <span class="n">sf_to_add</span> <span class="o">=</span> <span class="n">unique_ap</span> <span class="o">+</span> <span class="n">unique_dr</span> <span class="o">+</span> <span class="n">sf_to_add</span>

        <span class="c1"># add the apertures to the room if any were found</span>
        <span class="n">wps</span><span class="p">,</span> <span class="n">skylight_sfs</span><span class="p">,</span> <span class="n">user_dts</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">floor_segments</span><span class="p">:</span>
            <span class="n">wps</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
            <span class="n">user_dts</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;__identifier__&#39;</span><span class="p">:</span> <span class="p">[]})</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sf_to_add</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ext_vec</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ftc</span><span class="p">)</span>
            <span class="n">walls</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">floor_segments</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="n">walls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">ext_vec</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># sliver wall to ignore</span>
                    <span class="n">walls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">already_assigned</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">walls</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">sf_to_add</span><span class="p">:</span>
                <span class="c1"># first check if the sub-face might be a skylight</span>
                <span class="n">v_ang</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">ext_vec</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">v_ang</span> <span class="o">&lt;</span> <span class="n">perp_min</span> <span class="ow">or</span> <span class="n">v_ang</span> <span class="o">&gt;</span> <span class="n">perp_max</span><span class="p">:</span>
                    <span class="n">skylight_sfs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># check if the sub-face belongs in any of the walls</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">face</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">walls</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">face</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">overlapping_bounding_boxes</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span>
                            <span class="n">ang</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">normal</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">ang</span> <span class="o">&lt;</span> <span class="n">a_tol_min</span> <span class="ow">or</span> <span class="n">ang</span> <span class="o">&gt;</span> <span class="n">a_tol_max</span><span class="p">:</span>
                                <span class="n">bpts</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">boundary</span>
                                <span class="n">clean_pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">face</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">bpts</span><span class="p">]</span>
                                <span class="k">if</span> <span class="n">clean_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">bpts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">dist</span><span class="p">:</span>
                                    <span class="n">pj_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">clean_pts</span><span class="p">)</span>
                                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">pj_geo</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span>
                                           <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">already_assigned</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                                        <span class="k">continue</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">isd</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sf</span><span class="p">,</span> <span class="n">Door</span><span class="p">)</span> \
                                            <span class="ow">and</span> <span class="ow">not</span> <span class="n">sf</span><span class="o">.</span><span class="n">is_glass</span> <span class="k">else</span> <span class="kc">False</span>
                                        <span class="n">wps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pj_geo</span><span class="p">,</span> <span class="n">isd</span><span class="p">))</span>
                                        <span class="n">already_assigned</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pj_geo</span><span class="o">.</span><span class="n">center</span><span class="p">)</span>
                                        <span class="n">ud</span> <span class="o">=</span> <span class="n">user_dts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                        <span class="n">ud</span><span class="p">[</span><span class="s1">&#39;__identifier__&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
                                        <span class="k">if</span> <span class="n">sf</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">sf</span><span class="o">.</span><span class="n">user_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                                <span class="k">try</span><span class="p">:</span>
                                                    <span class="n">ud</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                                                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>  <span class="c1"># first time attribute</span>
                                                    <span class="n">ud</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="p">]</span>

        <span class="c1"># convert any projected Face3Ds to DetailedWindows and assign them</span>
        <span class="n">sliver_tol</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">tolerance</span>
        <span class="n">new_win_pars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">wp</span><span class="p">,</span> <span class="n">u_data</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wps</span><span class="p">,</span> <span class="n">user_dts</span><span class="p">,</span> <span class="n">floor_segments</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">win_to_add</span><span class="p">,</span> <span class="n">are_doors</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">wp</span><span class="p">)</span>
                <span class="n">det_win</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">from_face3ds</span><span class="p">(</span><span class="n">win_to_add</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">are_doors</span><span class="p">)</span>
                <span class="n">det_win</span> <span class="o">=</span> <span class="n">det_win</span><span class="o">.</span><span class="n">adjust_for_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">ftc</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">sliver_tol</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">det_win</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">det_win</span><span class="o">.</span><span class="n">user_data</span> <span class="o">=</span> <span class="n">u_data</span>
                <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">det_win</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">new_win_pars</span>

        <span class="c1"># search the remaining un-assigned sub-faces to see if they should be a skylight</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">skylight_sfs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="n">DetailedSkylights</span><span class="o">.</span><span class="n">from_honeybee</span><span class="p">(</span><span class="n">skylight_sfs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">offset_skylights_from_edges</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">overwrite</span><span class="p">:</span>  <span class="c1"># remove existing skylights</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Room2D.add_prefix">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.add_prefix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_prefix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the identifier of this object by inserting a prefix.</span>

<span class="sd">        This is particularly useful in workflows where you duplicate and edit</span>
<span class="sd">        a starting object and then want to combine it with the original object</span>
<span class="sd">        into one Model (like making a model of repeated rooms) since all objects</span>
<span class="sd">        within a Model must have unique identifiers.</span>

<span class="sd">        Args:</span>
<span class="sd">            prefix: Text that will be inserted at the start of this object&#39;s</span>
<span class="sd">                (and child segments&#39;) identifier and display_name. It is recommended</span>
<span class="sd">                that this prefix be short to avoid maxing out the 100 allowable</span>
<span class="sd">                characters for dragonfly identifiers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_identifier</span> <span class="o">=</span> <span class="n">clean_string</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">add_prefix</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">new_face_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">new_room_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">Surface</span><span class="p">((</span><span class="n">new_face_id</span><span class="p">,</span> <span class="n">new_room_id</span><span class="p">))</span></div>


<div class="viewcode-block" id="Room2D.generate_grid">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.generate_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a gridded Mesh3D object offset from the floor of this room.</span>

<span class="sd">        Note that the x_dim and y_dim refer to dimensions within the XY coordinate</span>
<span class="sd">        system of the floor Faces&#39;s plane. So rotating the planes of the floor geometry</span>
<span class="sd">        will result in rotated grid cells.</span>

<span class="sd">        Args:</span>
<span class="sd">            x_dim: The x dimension of the grid cells as a number.</span>
<span class="sd">            y_dim: The y dimension of the grid cells as a number. Default is None,</span>
<span class="sd">                which will assume the same cell dimension for y as is set for x.</span>
<span class="sd">            offset: A number for how far to offset the grid from the base face.</span>
<span class="sd">                Default is 1.0, which will not offset the grid to be 1 unit above</span>
<span class="sd">                the floor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">mesh_grid</span><span class="p">(</span><span class="n">x_dim</span><span class="p">,</span> <span class="n">y_dim</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.set_adjacency">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_adjacency">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_adjacency</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">other_room_2d</span><span class="p">,</span> <span class="n">self_seg_index</span><span class="p">,</span> <span class="n">other_seg_index</span><span class="p">,</span>
            <span class="n">resolve_window_conflicts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a segment of this Room2D to be adjacent to another and vice versa.</span>

<span class="sd">        Note that, adjacent segments must possess matching WindowParameters in</span>
<span class="sd">        order to be valid.</span>

<span class="sd">        Args:</span>
<span class="sd">            other_room_2d: Another Room2D object to be set adjacent to this one.</span>
<span class="sd">            self_seg_index: An integer for the wall segment of this Room2D that</span>
<span class="sd">                will be set adjacent to the other_room_2d.</span>
<span class="sd">            other_seg_index:An integer for the wall segment of the other_room_2d</span>
<span class="sd">                that will be set adjacent to this Room2D.</span>
<span class="sd">            resolve_window_conflicts: Boolean to note whether conflicts between</span>
<span class="sd">                window parameters of adjacent segments should be resolved during</span>
<span class="sd">                adjacency setting or an error should be raised about the mismatch.</span>
<span class="sd">                Resolving conflicts will default to the window parameters with the</span>
<span class="sd">                larger are and assign them to the other segment. (Default: True).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_room_2d</span><span class="p">,</span> <span class="n">Room2D</span><span class="p">),</span> \
            <span class="s1">&#39;Expected dragonfly Room2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other_room_2d</span><span class="p">))</span>
        <span class="c1"># set the boundary conditions of the segments</span>
        <span class="n">ids_1</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">..Face</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">self_seg_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
        <span class="n">ids_2</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">..Face</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">other_room_2d</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">other_seg_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                 <span class="n">other_room_2d</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">self_seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">ids_2</span><span class="p">)</span>
        <span class="n">other_room_2d</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">other_seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">Surface</span><span class="p">(</span><span class="n">ids_1</span><span class="p">)</span>
        <span class="c1"># check that the window parameters match between segments</span>
        <span class="n">wp1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">self_seg_index</span><span class="p">]</span>
        <span class="n">wp2</span> <span class="o">=</span> <span class="n">other_room_2d</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">other_seg_index</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">wp1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">wp2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">wp1</span> <span class="o">!=</span> <span class="n">wp2</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp1</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">resolve_window_conflicts</span><span class="p">:</span>
                    <span class="n">ftc1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>
                    <span class="n">ftc2</span> <span class="o">=</span> <span class="n">other_room_2d</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>
                    <span class="n">min_ftc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">ftc1</span><span class="p">,</span> <span class="n">ftc2</span><span class="p">))</span>
                    <span class="n">seg1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">[</span><span class="n">self_seg_index</span><span class="p">]</span>
                    <span class="n">a1</span> <span class="o">=</span> <span class="n">wp1</span><span class="o">.</span><span class="n">area_from_segment</span><span class="p">(</span><span class="n">seg1</span><span class="p">,</span> <span class="n">min_ftc</span><span class="p">)</span> <span class="k">if</span> <span class="n">wp1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="n">seg2</span> <span class="o">=</span> <span class="n">other_room_2d</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">[</span><span class="n">other_seg_index</span><span class="p">]</span>
                    <span class="n">a2</span> <span class="o">=</span> <span class="n">wp2</span><span class="o">.</span><span class="n">area_from_segment</span><span class="p">(</span><span class="n">seg2</span><span class="p">,</span> <span class="n">min_ftc</span><span class="p">)</span> <span class="k">if</span> <span class="n">wp2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">a1</span> <span class="o">&gt;</span> <span class="n">a2</span><span class="p">:</span>
                        <span class="n">other_room_2d</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">other_seg_index</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">wp1</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp1</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">)</span> \
                            <span class="k">else</span> <span class="n">wp1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">self_seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">wp2</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">seg1</span><span class="o">.</span><span class="n">length</span><span class="p">)</span> \
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp2</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">)</span> <span class="k">else</span> <span class="n">wp2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">wp1</span> <span class="o">!=</span> <span class="n">wp2</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Window parameters do not match between adjacent &#39;</span> \
                            <span class="s1">&#39;Rooms &quot;</span><span class="si">{}</span><span class="s1">&quot; and &quot;</span><span class="si">{}</span><span class="s1">&quot;.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">other_room_2d</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.reset_adjacency">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.reset_adjacency">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set all Surface boundary conditions of this Room2D to be Outdoors.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span></div>


<div class="viewcode-block" id="Room2D.find_segment_adjacency">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.find_segment_adjacency">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_segment_adjacency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate each of the segments of this Room2D for adjacency with other Room2Ds.</span>

<span class="sd">        This is purely a geometric analysis and is separate from any boundary</span>
<span class="sd">        conditions that may or may not be assigned to the Room2Ds.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which adjacencies with this Room2D will</span>
<span class="sd">                be evaluated.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered adjacent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list with one item for each of this Room2D&#39;s floor_segments. If a</span>
<span class="sd">            given segment isn&#39;t adjacent to anything, the corresponding item in</span>
<span class="sd">            this list will be None. Otherwise, it will be a tuple with two items.</span>
<span class="sd">            The first is the adjacent Room2D to the segment and the second is</span>
<span class="sd">            the index of the wall segment that is adjacent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">self_floor_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments_2d</span>
        <span class="n">adj_info</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">self_floor_segs</span><span class="p">)</span>  <span class="c1"># lists of adjacencies to track</span>
        <span class="k">for</span> <span class="n">room_2</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">overlapping_bounding_rect</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span>
                    <span class="n">room_2</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                <span class="k">continue</span>  <span class="c1"># no overlap in bounding rect; adjacency impossible</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">seg_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">self_floor_segs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                            <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                        <span class="n">adj_info</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">room_2</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">return</span> <span class="n">adj_info</span></div>


<div class="viewcode-block" id="Room2D.set_boundary_condition">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_boundary_condition">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_boundary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg_index</span><span class="p">,</span> <span class="n">boundary_condition</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a single segment of this Room2D to have a certain boundary condition.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg_index: An integer for the wall segment of this Room2D for which</span>
<span class="sd">                the boundary condition will be set.</span>
<span class="sd">            boundary_condition: A boundary condition object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">boundary_condition</span> <span class="ow">in</span> <span class="n">bcs</span><span class="p">,</span> \
            <span class="s1">&#39;Expected boundary condition. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">boundary_condition</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">boundary_condition</span><span class="p">,</span> <span class="p">(</span><span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)),</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> cannot be &#39;</span> \
                <span class="s1">&#39;assigned to a wall with windows.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">boundary_condition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">boundary_condition</span></div>


<div class="viewcode-block" id="Room2D.set_air_boundary">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_air_boundary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_air_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a single segment of this Room2D to have an air boundary type.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg_index: An integer for the wall segment of this Room2D for which</span>
<span class="sd">                the boundary condition will be set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span>  <span class="c1"># trigger generation of values if they don&#39;t exist</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> \
            <span class="s1">&#39;Air boundaries cannot be assigned to a wall with windows.&#39;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_index</span><span class="p">],</span> <span class="n">Surface</span><span class="p">),</span> \
            <span class="s1">&#39;Air boundaries must be assigned to walls with Surface boundary conditions.&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="Room2D.set_window_parameter">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.set_window_parameter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_window_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seg_index</span><span class="p">,</span> <span class="n">window_parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a single segment of this Room2D to have a certain window parameter.</span>

<span class="sd">        Args:</span>
<span class="sd">            seg_index: An integer for the wall segment of this Room2D for which</span>
<span class="sd">                the window parameter will be set.</span>
<span class="sd">            window_parameter: A window parameter object to be assigned to the segment.</span>
<span class="sd">                If None, any existing WindowParameters assigned to the segment</span>
<span class="sd">                will be removed. (Default: None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">window_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window_parameter</span><span class="p">,</span> <span class="n">_WindowParameterBase</span><span class="p">),</span> \
                <span class="s1">&#39;Expected Window Parameters. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">window_parameter</span><span class="p">))</span>
            <span class="n">accept_bc</span> <span class="o">=</span> <span class="p">(</span><span class="n">Outdoors</span><span class="p">,</span> <span class="n">Surface</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_index</span><span class="p">],</span> <span class="n">accept_bc</span><span class="p">),</span> \
                <span class="s1">&#39;Windows cannot be assigned to a wall with </span><span class="si">{}</span><span class="s1"> boundary &#39;</span> \
                <span class="s1">&#39;condition.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_index</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">window_parameter</span></div>


<div class="viewcode-block" id="Room2D.offset_windows">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.offset_windows">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">offset_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_distance</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">seg_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Offset detailed windows by a certain distance.</span>

<span class="sd">        This is useful for translating between interfaces that expect the window</span>
<span class="sd">        frame to be included within or excluded from the geometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            offset_distance: Distance with which the edges of each window will</span>
<span class="sd">                be offset from the original geometry. Positive values will</span>
<span class="sd">                offset the geometry outwards and negative values will offset the</span>
<span class="sd">                geometries inwards.</span>
<span class="sd">            tolerance: The minimum difference between point values for them to be</span>
<span class="sd">                considered the distinct. (Default: 0.01, suitable for objects</span>
<span class="sd">                in meters).</span>
<span class="sd">            seg_indices: An optional list of integers for the wall segments of</span>
<span class="sd">                this Room2D for which windows should be offset. If None,</span>
<span class="sd">                all segments will have their windows offset. (Default: None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seg_indices</span><span class="p">:</span>
                    <span class="n">wp</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">offset_distance</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.offset_skylights">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.offset_skylights">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">offset_skylights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_distance</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Offset detailed skylights by a certain distance.</span>

<span class="sd">        This is useful for translating between interfaces that expect the window</span>
<span class="sd">        frame to be included within or excluded from the geometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            offset_distance: Distance with which the edges of each window will</span>
<span class="sd">                be offset from the original geometry. Positive values will</span>
<span class="sd">                offset the geometry outwards and negative values will offset the</span>
<span class="sd">                geometries inwards.</span>
<span class="sd">            tolerance: The minimum difference between point values for them to be</span>
<span class="sd">                considered the distinct. (Default: 0.01, suitable for objects</span>
<span class="sd">                in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">offset_distance</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.offset_skylights_from_edges">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.offset_skylights_from_edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">offset_skylights_from_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset_distance</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Offset detailed skylights so all vertices lie inside the Room2D boundary.</span>

<span class="sd">        Args:</span>
<span class="sd">            offset_distance: Distance from the edge of the room that</span>
<span class="sd">                the polygons will be offset to. (Default: 0.05, suitable for</span>
<span class="sd">                objects in meters).</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct. (Default: 0.01, suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">offset_polygons_for_face</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">offset_distance</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Room2D.make_windows_flush">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.make_windows_flush">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_windows_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame_distance</span><span class="p">,</span> <span class="n">offset_boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">seg_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make the edges of window geometry flush if they lie within the frame_distance.</span>

<span class="sd">        This is useful for translating between interfaces that expect the window</span>
<span class="sd">        frame to be included within the geometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            frame_distance: Distance with which the edges of each window will</span>
<span class="sd">                be moved in order to make them flush with neighboring windows.</span>
<span class="sd">            offset_boundary: Boolean to note whether the outer boundary of window</span>
<span class="sd">                groups that have been made flush with one another should be offset</span>
<span class="sd">                after all windows within the group have been made flush (True)</span>
<span class="sd">                or the boundary around the group should be left unchanged (False).</span>
<span class="sd">                Set to True when the intended result is more like an offset of</span>
<span class="sd">                window geometries to account for the frame rather than just making</span>
<span class="sd">                the windows flush. (Default: True).</span>
<span class="sd">            tolerance: The minimum difference between point values for them to be</span>
<span class="sd">                considered the distinct. (Default: 0.01, suitable for objects</span>
<span class="sd">                in meters).</span>
<span class="sd">            angle_tolerance: The max angle difference in degrees that a window</span>
<span class="sd">                segment direction can differ from the X or Y axis before it is</span>
<span class="sd">                excluded from being made flush. (Default: 1).</span>
<span class="sd">            seg_indices: An optional list of integers for the wall segments of</span>
<span class="sd">                this Room2D for which windows should be made flush. If None,</span>
<span class="sd">                all segments will have their windows made flush. (Default: None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">DetailedWindows</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seg_indices</span><span class="p">:</span>
                    <span class="n">wp</span><span class="o">.</span><span class="n">make_flush</span><span class="p">(</span><span class="n">frame_distance</span><span class="p">,</span> <span class="n">offset_boundary</span><span class="p">,</span>
                                  <span class="n">tolerance</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">offset_boundary</span><span class="p">:</span>
                        <span class="n">wp</span><span class="o">.</span><span class="n">adjust_for_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                                              <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.make_skylights_flush">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.make_skylights_flush">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">make_skylights_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame_distance</span><span class="p">,</span> <span class="n">offset_boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make the edges of skylight geometry flush if they lie within frame_distance.</span>

<span class="sd">        This is useful for translating between interfaces that expect the skylight</span>
<span class="sd">        frame to be included within the geometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            frame_distance: Distance with which the edges of each skylight will</span>
<span class="sd">                be moved in order to make them flush with neighboring skylights.</span>
<span class="sd">            offset_boundary: Boolean to note whether the outer boundary of skylight</span>
<span class="sd">                groups that have been made flush with one another should be offset</span>
<span class="sd">                after all skylights within the group have been made flush (True)</span>
<span class="sd">                or the boundary around the group should be left unchanged (False).</span>
<span class="sd">                Set to True when the intended result is more like an offset of</span>
<span class="sd">                skylight geometries to account for the frame rather than just making</span>
<span class="sd">                the skylights flush. (Default: True).</span>
<span class="sd">            tolerance: The minimum difference between point values for them to be</span>
<span class="sd">                considered the distinct. (Default: 0.01, suitable for objects</span>
<span class="sd">                in meters).</span>
<span class="sd">            angle_tolerance: The max angle difference in degrees that a skylight</span>
<span class="sd">                segment direction can differ from the X or Y axis before it is</span>
<span class="sd">                excluded from being made flush. (Default: 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">make_flush</span><span class="p">(</span><span class="n">frame_distance</span><span class="p">,</span> <span class="n">offset_boundary</span><span class="p">,</span>
                                                 <span class="n">tolerance</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">offset_boundary</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">offset_skylights_from_edges</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.move">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.move">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moving_vec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move this Room2D along a vector.</span>

<span class="sd">        Args:</span>
<span class="sd">            moving_vec: A ladybug_geometry Vector3D with the direction and distance</span>
<span class="sd">                to move the room.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">moved_floor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">moving_vec</span><span class="p">)</span>
        <span class="n">o_pl</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">moved_floor</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">moved_floor</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">o_pl</span><span class="p">,</span> <span class="n">moved_floor</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">moving_vec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">moving_vec</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.rotate_xy">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.rotate_xy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate this Room2D counterclockwise in the XY plane by a certain angle.</span>

<span class="sd">        Args:</span>
<span class="sd">            angle: An angle in degrees.</span>
<span class="sd">            origin: A ladybug_geometry Point3D for the origin around which the</span>
<span class="sd">                object will be rotated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotated_floor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">o_pl</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rotated_floor</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">rotated_floor</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">o_pl</span><span class="p">,</span> <span class="n">rotated_floor</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.reflect">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.reflect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reflect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reflect this Room2D across a plane.</span>

<span class="sd">        Args:</span>
<span class="sd">            plane: A ladybug_geometry Plane across which the object will be reflected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">plane</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">z</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="s1">&#39;Plane normal must be in XY plane to use it on Room2D.reflect.&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">plane</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ensure upward-facing Face3D</span>
            <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win_pars</span><span class="p">,</span> <span class="n">new_shd_pars</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_flip_wall_assigned_objects</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_win_pars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">new_shd_pars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="n">o_pl</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">o_pl</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">reflect</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.scale">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.scale">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scale this Room2D by a factor from an origin point.</span>

<span class="sd">        Note that this will scale both the Room2D geometry and the WindowParameters</span>
<span class="sd">        and FacadeParameters assigned to this Room2D.</span>

<span class="sd">        Args:</span>
<span class="sd">            factor: A number representing how much the object should be scaled.</span>
<span class="sd">            origin: A ladybug_geometry Point3D representing the origin from which</span>
<span class="sd">                to scale. If None, it will be scaled from the World origin (0, 0, 0).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># scale the Room2D geometry</span>
        <span class="n">scaled_floor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="n">o_pl</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scaled_floor</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">scaled_floor</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">o_pl</span><span class="p">,</span> <span class="n">scaled_floor</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span> <span class="o">*</span> <span class="n">factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">*</span> <span class="n">factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">*</span> <span class="n">factor</span>

        <span class="c1"># scale the window parameters</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">win_par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">win_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">win_par</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="c1"># scale the shading parameters</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">shd_par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">shd_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shd_par</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="c1"># scale the skylight parameters</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span> \
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">)</span> <span class="k">else</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.snap_to_grid">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.snap_to_grid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">snap_to_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_increment</span><span class="p">,</span> <span class="n">base_plane</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Snap this Room2D&#39;s vertices to the nearest grid node defined by an increment.</span>

<span class="sd">        All properties assigned to the Room2D will be preserved and the number of</span>
<span class="sd">        vertices will remain constant. This means that this method can often create</span>
<span class="sd">        duplicate vertices and it might be desirable to run the remove_duplicate_vertices</span>
<span class="sd">        method after running this one.</span>

<span class="sd">        Args:</span>
<span class="sd">            grid_increment: A positive number for dimension of each grid cell. This</span>
<span class="sd">                typically should be equal to the tolerance or larger but should</span>
<span class="sd">                not be larger than the smallest detail of the Room2D that you</span>
<span class="sd">                wish to resolve.</span>
<span class="sd">            base_plane: An optional ladybug-geometry Plane object to set the coordinate</span>
<span class="sd">                system of the grid in which this Room will be snapped. If None, the</span>
<span class="sd">                World XY coordinate system will be used. (Default: None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if the base plane is specified, convert to the plane&#39;s coordinate system</span>
        <span class="n">original_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">boundary</span><span class="p">,</span> <span class="n">holes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span>
        <span class="n">z_val</span><span class="p">,</span> <span class="n">pl_ang</span><span class="p">,</span> <span class="n">t_vec</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">base_plane</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">o</span>
            <span class="n">t_vec</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="o">-</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">x_axis</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="n">base_plane</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">base_plane</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="n">pl_ang</span> <span class="o">=</span> <span class="n">x_axis</span><span class="o">.</span><span class="n">angle_counterclockwise</span><span class="p">(</span><span class="n">Vector2D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">boundary</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="n">pl_ang</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">t_vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">boundary</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">holes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">pt</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="n">pl_ang</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">t_vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span>
                         <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">holes</span><span class="p">]</span>

        <span class="c1"># loop through the vertices and snap them</span>
        <span class="n">new_boundary</span><span class="p">,</span> <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">boundary</span><span class="p">:</span>
            <span class="n">new_x</span> <span class="o">=</span> <span class="n">grid_increment</span> <span class="o">*</span> <span class="nb">round</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">grid_increment</span><span class="p">)</span>
            <span class="n">new_y</span> <span class="o">=</span> <span class="n">grid_increment</span> <span class="o">*</span> <span class="nb">round</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">grid_increment</span><span class="p">)</span>
            <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">,</span> <span class="n">z_val</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">holes</span><span class="p">:</span>
                <span class="n">new_hole</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">:</span>
                    <span class="n">new_x</span> <span class="o">=</span> <span class="n">grid_increment</span> <span class="o">*</span> <span class="nb">round</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">grid_increment</span><span class="p">)</span>
                    <span class="n">new_y</span> <span class="o">=</span> <span class="n">grid_increment</span> <span class="o">*</span> <span class="nb">round</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">grid_increment</span><span class="p">)</span>
                    <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">,</span> <span class="n">z_val</span><span class="p">))</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hole</span><span class="p">)</span>

        <span class="c1"># if the base plane is specified, convert back to the world coordinate system</span>
        <span class="k">if</span> <span class="n">pl_ang</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">r_vec</span> <span class="o">=</span> <span class="o">-</span><span class="n">t_vec</span>
            <span class="n">new_boundary</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">r_vec</span><span class="p">)</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="o">-</span><span class="n">pl_ang</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">new_boundary</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">new_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">pt</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">r_vec</span><span class="p">)</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="o">-</span><span class="n">pl_ang</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">new_holes</span><span class="p">]</span>

        <span class="c1"># rebuild the new floor geometry and assign it to the Room2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
            <span class="n">new_boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span>

        <span class="c1"># if the dimension of segments has changed substantially, re-center windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_re_center_windows</span><span class="p">(</span><span class="n">original_segs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.snap_to_points">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.snap_to_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">snap_to_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Snap this Room2D&#39;s vertices to a list of points.</span>

<span class="sd">        All properties assigned to this Room2D will be preserved and the number of</span>
<span class="sd">        vertices will remain constant. This means that this method can often create</span>
<span class="sd">        duplicate vertices and it might be desirable to run the remove_duplicate_vertices</span>
<span class="sd">        method after running this one.</span>

<span class="sd">        Args:</span>
<span class="sd">            points: A list of ladybug_geometry Point2Ds to which the Room2D</span>
<span class="sd">                vertices will be snapped if they are near.</span>
<span class="sd">            distance: The maximum distance between a Room2D vertex and the input</span>
<span class="sd">                point where the vertex will be moved to lie on the polyline.</span>
<span class="sd">                Vertices beyond this distance will be left as they are.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the points</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">points</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">Point2D</span><span class="p">):</span>
                <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected point2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pt</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># get lists of vertices for the Room2D.floor_geometry to be edited</span>
        <span class="n">original_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">edit_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span>
        <span class="n">edit_holes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># perform the snapping operation</span>
        <span class="n">new_boundary</span><span class="p">,</span> <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">edit_boundary</span><span class="p">:</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_3d</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
            <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">vertices</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edit_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">edit_holes</span><span class="p">:</span>
                <span class="n">new_hole</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">:</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_3d</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
                    <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">vertices</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hole</span><span class="p">)</span>

        <span class="c1"># rebuild the new floor geometry and assign it to the Room2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
            <span class="n">new_boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span>

        <span class="c1"># if the dimension of segments has changed substantially, re-center windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_re_center_windows</span><span class="p">(</span><span class="n">original_segs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.snap_to_line_end_points">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.snap_to_line_end_points">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">snap_to_line_end_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Snap this Room2D&#39;s vertices to the endpoints of a line segment.</span>

<span class="sd">        All properties assigned to this Room2D will be preserved and the number of</span>
<span class="sd">        vertices will remain constant. This means that this method can often create</span>
<span class="sd">        duplicate vertices and it might be desirable to run the remove_duplicate_vertices</span>
<span class="sd">        method after running this one.</span>

<span class="sd">        Args:</span>
<span class="sd">            line: A ladybug_geometry LineSegment2D to which the Room2D</span>
<span class="sd">                vertices will be snapped if they are near the end points.</span>
<span class="sd">            distance: The maximum distance between a Room2D vertex and the polyline where</span>
<span class="sd">                the vertex will be moved to lie on the polyline. Vertices beyond</span>
<span class="sd">                this distance will be left as they are.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the line segment</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LineSegment2D</span><span class="p">):</span>
            <span class="n">line_ray_3d</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="p">(</span>
                <span class="n">Point3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">),</span>
                <span class="n">Vector3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected LineSegment2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># get lists of vertices for the Room2D.floor_geometry to be edited</span>
        <span class="n">original_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">edit_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span>
        <span class="n">edit_holes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># perform the snapping operation</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">line_ray_3d</span><span class="o">.</span><span class="n">endpoints</span>
        <span class="n">new_boundary</span><span class="p">,</span> <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">edit_boundary</span><span class="p">:</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_3d</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
            <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">vertices</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">edit_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">edit_holes</span><span class="p">:</span>
                <span class="n">new_hole</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">:</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_3d</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
                    <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">vertices</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hole</span><span class="p">)</span>

        <span class="c1"># rebuild the new floor geometry and assign it to the Room2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
            <span class="n">new_boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span>

        <span class="c1"># if the dimension of segments has changed substantially, re-center windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_re_center_windows</span><span class="p">(</span><span class="n">original_segs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.align">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.align">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_ray</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move any Room2D vertices within a given distance of a line to be on that line.</span>

<span class="sd">        This is useful to clean up cases where wall segments have a lot of</span>
<span class="sd">        zig zags in them.</span>

<span class="sd">        All properties assigned to the Room2D will be preserved and the number of</span>
<span class="sd">        vertices will remain constant. This means that this method can often create</span>
<span class="sd">        duplicate vertices and it might be desirable to run the remove_duplicate_vertices</span>
<span class="sd">        method after running this one.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_ray: A ladybug_geometry Ray2D or LineSegment2D to which the Room2D</span>
<span class="sd">                vertices will be aligned. Ray2Ds will be interpreted as being infinite</span>
<span class="sd">                in both directions while LineSegment2Ds will be interpreted as only</span>
<span class="sd">                existing between two points.</span>
<span class="sd">            distance: The maximum distance between a vertex and the line_ray where</span>
<span class="sd">                the vertex will be moved to lie on the line_ray. Vertices beyond</span>
<span class="sd">                this distance will be left as they are.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the line_ray for the closest point calculation</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_ray</span><span class="p">,</span> <span class="n">Ray2D</span><span class="p">):</span>
            <span class="n">line_ray_3d</span> <span class="o">=</span> <span class="n">Ray3D</span><span class="p">(</span>
                <span class="n">Point3D</span><span class="p">(</span><span class="n">line_ray</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_ray</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">),</span>
                <span class="n">Vector3D</span><span class="p">(</span><span class="n">line_ray</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_ray</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">closest_func</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d_infinite</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_ray</span><span class="p">,</span> <span class="n">LineSegment2D</span><span class="p">):</span>
            <span class="n">line_ray_3d</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="p">(</span>
                <span class="n">Point3D</span><span class="p">(</span><span class="n">line_ray</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_ray</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">),</span>
                <span class="n">Vector3D</span><span class="p">(</span><span class="n">line_ray</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line_ray</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">closest_func</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected Ray2D or LineSegment2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">line_ray</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># loop through the vertices and align them</span>
        <span class="n">original_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">new_boundary</span><span class="p">,</span> <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">:</span>
            <span class="n">close_pt</span> <span class="o">=</span> <span class="n">closest_func</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line_ray_3d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="n">new_hole</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">:</span>
                    <span class="n">close_pt</span> <span class="o">=</span> <span class="n">closest_func</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line_ray_3d</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hole</span><span class="p">)</span>

        <span class="c1"># rebuild the new floor geometry and assign it to the Room2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
            <span class="n">new_boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span>

        <span class="c1"># if the dimension of segments has changed substantially, re-center windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_re_center_windows</span><span class="p">(</span><span class="n">original_segs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.pull_to_segments">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.pull_to_segments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pull_to_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segments</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">snap_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">constrain_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pull this Room2D&#39;s vertices to several LineSegment2D.</span>

<span class="sd">        This includes both an alignment to the line segments as well as an optional</span>
<span class="sd">        snapping to the line end points.</span>

<span class="sd">        All properties assigned to this Room2D will be preserved.</span>

<span class="sd">        The benefit of calling this method as opposed to iterating over the</span>
<span class="sd">        segments and calling align (and snap_to_line_end_points) is that this</span>
<span class="sd">        method will only align (and snap) to the closest segment across all of</span>
<span class="sd">        the input line_segments. This often helps avoid snapping to undesirable</span>
<span class="sd">        line segments, particularly when there are two ore more segments that</span>
<span class="sd">        are within the distance.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_segments: A list of ladybug_geometry LineSegment2D to which this</span>
<span class="sd">                Room2D&#39;s vertices will be pulled.</span>
<span class="sd">            distance: The maximum distance between a Room2D vertex and the line_segments</span>
<span class="sd">                where the vertex will be moved to lie on the segments. Vertices beyond</span>
<span class="sd">                this distance will be left as they are.</span>
<span class="sd">            snap_vertices: A boolean to note whether Room2D vertices that are</span>
<span class="sd">                close to the segment end points within the distance should be snapped</span>
<span class="sd">                to the end point instead of simply being aligned to the nearest</span>
<span class="sd">                segment. (Default: True).</span>
<span class="sd">            constrain_edges: A boolean to note whether all axes of the edges that</span>
<span class="sd">                were not pulled to the Room2D should be preserved. This is</span>
<span class="sd">                accomplished by evaluating the changed vertices after all pulling</span>
<span class="sd">                operations are performed and identifying stretches of vertices</span>
<span class="sd">                that changed. For each stretch of changed vertices, the start and end</span>
<span class="sd">                points of this stretch will be moved to the intersection between</span>
<span class="sd">                the new pulled room segment and the adjacent original room</span>
<span class="sd">                segment whose axis is to be preserved. (Default: False).</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which they are considered co-located. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the relevant line segments</span>
        <span class="n">lines_3d</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">line_segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LineSegment2D</span><span class="p">):</span>
                <span class="n">line_3d</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="p">(</span>
                    <span class="n">Point3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">),</span>
                    <span class="n">Vector3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">lines_3d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_3d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected LineSegment2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines_3d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># get lists of vertices for the Room2D.floor_geometry to be edited</span>
        <span class="n">original_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">edit_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span>
        <span class="n">edit_holes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># loop through the Room2D vertices and align them to the segments</span>
        <span class="n">new_boundary</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">edit_boundary</span><span class="p">:</span>
            <span class="n">dists</span><span class="p">,</span> <span class="n">c_pts</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line_ray_3d</span> <span class="ow">in</span> <span class="n">lines_3d</span><span class="p">:</span>
                <span class="n">close_pt</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line_ray_3d</span><span class="p">)</span>
                <span class="n">c_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span>
                <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">close_pt</span><span class="p">))</span>
            <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">c_pts</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="n">edit_boundary</span> <span class="o">=</span> <span class="n">new_boundary</span>
        <span class="k">if</span> <span class="n">edit_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">edit_holes</span><span class="p">:</span>
                <span class="n">new_hole</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">:</span>
                    <span class="n">dists</span><span class="p">,</span> <span class="n">c_pts</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">line_ray_3d</span> <span class="ow">in</span> <span class="n">lines_3d</span><span class="p">:</span>
                        <span class="n">close_pt</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line_ray_3d</span><span class="p">)</span>
                        <span class="n">c_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span>
                        <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">close_pt</span><span class="p">))</span>
                    <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">c_pts</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hole</span><span class="p">)</span>
            <span class="n">edit_holes</span> <span class="o">=</span> <span class="n">new_holes</span>

        <span class="c1"># if snap_vertices was requested, perform an additional operation to snap them</span>
        <span class="k">if</span> <span class="n">snap_vertices</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines_3d</span><span class="p">:</span>
                <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span>
                <span class="n">vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
            <span class="n">new_boundary</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">edit_boundary</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_3d</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
                <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">vertices</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                    <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
            <span class="n">edit_boundary</span> <span class="o">=</span> <span class="n">new_boundary</span>
            <span class="k">if</span> <span class="n">edit_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">edit_holes</span><span class="p">:</span>
                    <span class="n">new_hole</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">:</span>
                        <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_3d</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
                        <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">vertices</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                            <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                    <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hole</span><span class="p">)</span>
                <span class="n">edit_holes</span> <span class="o">=</span> <span class="n">new_holes</span>

        <span class="c1"># rebuild the new floor geometry and assign it to the Room2D</span>
        <span class="n">f_geo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">edit_boundary</span><span class="p">,</span> <span class="n">f_geo</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">edit_holes</span><span class="p">)</span>
        <span class="c1"># if constrain_edges is true, move the end points of each stretch</span>
        <span class="k">if</span> <span class="n">constrain_edges</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constrain_edges</span><span class="p">(</span><span class="n">f_geo</span><span class="p">,</span> <span class="n">line_segments</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># if the dimension of segments has changed substantially, re-center windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_re_center_windows</span><span class="p">(</span><span class="n">original_segs</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.pull_to_polyline">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.pull_to_polyline">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pull_to_polyline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polyline</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">snap_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">constrain_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pull this Room2D&#39;s vertices to a Polyline2D.</span>

<span class="sd">        This includes both an alignment to the polyline&#39;s segments as well as an</span>
<span class="sd">        optional snapping to the polyline&#39;s vertices.</span>

<span class="sd">        All properties assigned to this Room2D will be preserved.</span>

<span class="sd">        Note that this method can often create duplicate vertices and degenerate</span>
<span class="sd">        geometry. So it might be desirable to run the remove_colinear_vertices or the</span>
<span class="sd">        remove_degenerate_holes method after running this one.</span>

<span class="sd">        Args:</span>
<span class="sd">            polyline: A ladybug_geometry Polyline2D to which this Room2D&#39;s vertices</span>
<span class="sd">                will be pulled.</span>
<span class="sd">            distance: The maximum distance between a Room2D vertex and the polyline where</span>
<span class="sd">                the vertex will be moved to lie on the polyline. Vertices beyond</span>
<span class="sd">                this distance will be left as they are.</span>
<span class="sd">            snap_vertices: A boolean to note whether Room2D vertices that are</span>
<span class="sd">                close to the polyline vertices within the distance should be snapped</span>
<span class="sd">                to the polyline vertex instead of simply being aligned to the nearest</span>
<span class="sd">                polyline segment. (Default: True).</span>
<span class="sd">            constrain_edges: A boolean to note whether all axes of the edges that</span>
<span class="sd">                were not pulled to the Room2D should be preserved. This is</span>
<span class="sd">                accomplished by evaluating the changed vertices after all pulling</span>
<span class="sd">                operations are performed and identifying stretches of vertices</span>
<span class="sd">                that changed. For each stretch of changed vertices, the start and end</span>
<span class="sd">                points of this stretch will be moved to the intersection between</span>
<span class="sd">                the new pulled room segment and the adjacent original room</span>
<span class="sd">                segment whose axis is to be preserved. (Default: False).</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which they are considered co-located. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create LineSegment3Ds from the polyline</span>
        <span class="n">line_segs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">polyline</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="n">pt_3d</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span>
            <span class="n">line_ray_3d</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">,</span> <span class="n">Vector3D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">line_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_ray_3d</span><span class="p">)</span>
        <span class="n">line_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_segs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flip</span><span class="p">())</span>  <span class="c1"># ensure last vertex is counted</span>

        <span class="c1"># pull this Room2D to the segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pull_to_poly_segments</span><span class="p">(</span><span class="n">line_segs</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">snap_vertices</span><span class="p">,</span>
                                    <span class="n">constrain_edges</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.pull_to_polygon">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.pull_to_polygon">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pull_to_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">snap_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">constrain_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pull this Room2D&#39;s vertices to a Polygon2D.</span>

<span class="sd">        This includes both an alignment to the polygon&#39;s segments as well as an</span>
<span class="sd">        optional snapping to the polygon&#39;s vertices.</span>

<span class="sd">        All properties assigned to this Room2D will be preserved.</span>

<span class="sd">        Note that this method can often create duplicate vertices and degenerate</span>
<span class="sd">        geometry. So it might be desirable to run the remove_colinear_vertices or the</span>
<span class="sd">        remove_degenerate_holes method after running this one.</span>

<span class="sd">        Args:</span>
<span class="sd">            polygon: A ladybug_geometry Polygon2D to which this Room2D&#39;s vertices</span>
<span class="sd">                will be pulled.</span>
<span class="sd">            distance: The maximum distance between a Room2D vertex and the polygon where</span>
<span class="sd">                the vertex will be moved to lie on the polygon. Vertices beyond</span>
<span class="sd">                this distance will be left as they are.</span>
<span class="sd">            snap_vertices: A boolean to note whether Room2D vertices that are</span>
<span class="sd">                close to the polygon vertices within the distance should be snapped</span>
<span class="sd">                to the polygon vertex instead of simply being aligned to the nearest</span>
<span class="sd">                polygon segment. (Default: True).</span>
<span class="sd">            constrain_edges: A boolean to note whether all axes of the edges that</span>
<span class="sd">                were not pulled to the Room2D should be preserved. This is</span>
<span class="sd">                accomplished by evaluating the changed vertices after all pulling</span>
<span class="sd">                operations are performed and identifying stretches of vertices</span>
<span class="sd">                that changed. For each stretch of changed vertices, the start and end</span>
<span class="sd">                points of this stretch will be moved to the intersection between</span>
<span class="sd">                the new pulled room segment and the adjacent original room</span>
<span class="sd">                segment whose axis is to be preserved. (Default: False).</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which they are considered co-located. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create LineSegment3Ds from the polygon</span>
        <span class="n">line_segs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">polygon</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="n">pt_3d</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span>
            <span class="n">line_ray_3d</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">,</span> <span class="n">Vector3D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">line_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_ray_3d</span><span class="p">)</span>

        <span class="c1"># pull this Room2D to the segments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pull_to_poly_segments</span><span class="p">(</span><span class="n">line_segs</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">snap_vertices</span><span class="p">,</span>
                                    <span class="n">constrain_edges</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.pull_to_room_2d">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.pull_to_room_2d">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pull_to_room_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room_2d</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">coordinate_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="n">constrain_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pull this Room2D&#39;s vertices to another Room2D.</span>

<span class="sd">        This includes both an alignment to the other Room2D&#39;s segments as well</span>
<span class="sd">        as an optional snapping to the Room2D&#39;s vertices. Furthermore, if</span>
<span class="sd">        coordinate_vertices is True, any vertices of the neighboring input room_2d</span>
<span class="sd">        that are within the specified distance but cannot be matched to a vertex</span>
<span class="sd">        on this Room2D within the tolerance will be inserted into this Room2D,</span>
<span class="sd">        splitting the wall segment in the process.</span>

<span class="sd">        All properties assigned to this Room2D will be preserved.</span>

<span class="sd">        Note that this method can often create duplicate vertices and degenerate</span>
<span class="sd">        geometry. So it might be desirable to run the remove_colinear_vertices or the</span>
<span class="sd">        remove_degenerate_holes method after running this one.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2d: A Room2D to which this Room2D&#39;s vertices will be pulled.</span>
<span class="sd">            distance: The maximum distance between a Room2D vertex and the other</span>
<span class="sd">                Room2D where the vertex will be moved to lie on the other Room2D.</span>
<span class="sd">                Vertices beyond this distance will be left as they are.</span>
<span class="sd">            coordinate_vertices: A boolean to note whether Room2D vertices that are</span>
<span class="sd">                close to the other Room2D vertices within the distance should be snapped</span>
<span class="sd">                to the Room2D vertex instead of simply being aligned to the nearest</span>
<span class="sd">                Room2D segment. Additionally, any vertices of the neighboring room_2d</span>
<span class="sd">                that are within the specified distance but cannot be matched to a vertex</span>
<span class="sd">                on this Room2D within the tolerance will be inserted into this Room2D,</span>
<span class="sd">                splitting the wall segment in the process. (Default: True).</span>
<span class="sd">            constrain_edges: A boolean to note whether all axes of the edges that</span>
<span class="sd">                were not pulled to the Room2D should be preserved. This is</span>
<span class="sd">                accomplished by evaluating the changed vertices after all pulling</span>
<span class="sd">                operations are performed and identifying stretches of vertices</span>
<span class="sd">                that changed. For each stretch of changed vertices, the start and end</span>
<span class="sd">                points of this stretch will be moved to the intersection between</span>
<span class="sd">                the new pulled room segment and the adjacent original room</span>
<span class="sd">                segment whose axis is to be preserved. (Default: False).</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which they are considered co-located. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># convert the other Room2D to a list of polygons</span>
        <span class="n">original_geo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span>
        <span class="n">f_geo</span> <span class="o">=</span> <span class="n">room_2d</span><span class="o">.</span><span class="n">floor_geometry</span>
        <span class="n">other_room_polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">Polygon2D</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">f_geo</span><span class="o">.</span><span class="n">boundary</span><span class="p">])]</span>
        <span class="k">if</span> <span class="n">f_geo</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">f_geo</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="n">h_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">])</span>
                <span class="n">other_room_polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_poly</span><span class="p">)</span>
        <span class="c1"># pull this Room2D to each of the polygons</span>
        <span class="k">for</span> <span class="n">o_poly</span> <span class="ow">in</span> <span class="n">other_room_polys</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pull_to_polygon</span><span class="p">(</span><span class="n">o_poly</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">coordinate_vertices</span><span class="p">)</span>
        <span class="c1"># if coordinate_vertices is True, insert extra vertices</span>
        <span class="k">if</span> <span class="n">coordinate_vertices</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coordinate_room_2d_vertices</span><span class="p">(</span><span class="n">room_2d</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="c1"># if constrain_edges is true, move the end points of each stretch</span>
        <span class="k">if</span> <span class="n">constrain_edges</span><span class="p">:</span>
            <span class="n">pull_segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">other_room_polys</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">segments</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constrain_edges</span><span class="p">(</span><span class="n">original_geo</span><span class="p">,</span> <span class="n">pull_segments</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_pull_to_poly_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segments</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">snap_vertices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                               <span class="n">constrain_edges</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pull this Room2D&#39;s vertices to LineSegment3D originating from a poly-line/gon.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_segments: A list of ladybug_geometry LineSegment3D with Z-values at</span>
<span class="sd">                this Room2D&#39;s floor_height to which this Room2D&#39;s vertices</span>
<span class="sd">                will be pulled.</span>
<span class="sd">            distance: The maximum distance between a Room2D vertex and the line_segments</span>
<span class="sd">                where the vertex will be moved to lie on the segments. Vertices beyond</span>
<span class="sd">                this distance will be left as they are.</span>
<span class="sd">            snap_vertices: A boolean to note whether Room2D vertices that are</span>
<span class="sd">                close to the segment end points within the distance should be snapped</span>
<span class="sd">                to the end point instead of simply being aligned to the nearest</span>
<span class="sd">                segment. (Default: True).</span>
<span class="sd">            constrain_edges: A boolean to note whether all axes of the edges that</span>
<span class="sd">                were not pulled to the Room2D should be preserved. This is</span>
<span class="sd">                accomplished by evaluating the changed vertices after all pulling</span>
<span class="sd">                operations are performed and identifying stretches of vertices</span>
<span class="sd">                that changed. For each stretch of changed vertices, the start and end</span>
<span class="sd">                points of this stretch will be moved to the intersection between</span>
<span class="sd">                the new pulled room segment and the adjacent original room</span>
<span class="sd">                segment whose axis is to be preserved. (Default: False).</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which they are considered co-located. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first make sure that there are line segments to be pulled to</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_segments</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># get lists of vertices for the Room2D.floor_geometry to be edited</span>
        <span class="n">original_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">edit_boundary</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span>
        <span class="n">edit_holes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="c1"># loop through the Room2D vertices and align them to the segments</span>
        <span class="n">new_boundary</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">edit_boundary</span><span class="p">:</span>
            <span class="n">dists</span><span class="p">,</span> <span class="n">c_pts</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">line_ray_3d</span> <span class="ow">in</span> <span class="n">line_segments</span><span class="p">:</span>
                <span class="n">close_pt</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line_ray_3d</span><span class="p">)</span>
                <span class="n">c_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span>
                <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">close_pt</span><span class="p">))</span>
            <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">c_pts</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="n">edit_boundary</span> <span class="o">=</span> <span class="n">new_boundary</span>
        <span class="k">if</span> <span class="n">edit_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">edit_holes</span><span class="p">:</span>
                <span class="n">new_hole</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">:</span>
                    <span class="n">dists</span><span class="p">,</span> <span class="n">c_pts</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">line_ray_3d</span> <span class="ow">in</span> <span class="n">line_segments</span><span class="p">:</span>
                        <span class="n">close_pt</span> <span class="o">=</span> <span class="n">closest_point3d_on_line3d</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">line_ray_3d</span><span class="p">)</span>
                        <span class="n">c_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span>
                        <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">close_pt</span><span class="p">))</span>
                    <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">c_pts</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hole</span><span class="p">)</span>
            <span class="n">edit_holes</span> <span class="o">=</span> <span class="n">new_holes</span>

        <span class="c1"># if snap_vertices was requested, perform an additional operation to snap them</span>
        <span class="k">if</span> <span class="n">snap_vertices</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">p</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">line_segments</span><span class="p">]</span>
            <span class="n">new_boundary</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">edit_boundary</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_3d</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
                <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">vertices</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                    <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
            <span class="n">edit_boundary</span> <span class="o">=</span> <span class="n">new_boundary</span>
            <span class="k">if</span> <span class="n">edit_holes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">edit_holes</span><span class="p">:</span>
                    <span class="n">new_hole</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">:</span>
                        <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt_3d</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">]</span>
                        <span class="n">sort_pt</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">vertices</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">:</span>
                            <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_hole</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                    <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_hole</span><span class="p">)</span>
                <span class="n">edit_holes</span> <span class="o">=</span> <span class="n">new_holes</span>

        <span class="c1"># rebuild the new floor geometry and assign it to the Room2D</span>
        <span class="n">f_geo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">edit_boundary</span><span class="p">,</span> <span class="n">f_geo</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">edit_holes</span><span class="p">)</span>
        <span class="c1"># if constrain_edges is true, move the end points of each stretch</span>
        <span class="k">if</span> <span class="n">constrain_edges</span><span class="p">:</span>
            <span class="n">segs_2d</span> <span class="o">=</span> <span class="p">[</span><span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_array</span><span class="p">(((</span><span class="n">s</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
                       <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">line_segments</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_constrain_edges</span><span class="p">(</span><span class="n">f_geo</span><span class="p">,</span> <span class="n">segs_2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># if the dimension of segments has changed substantially, re-center windows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_re_center_windows</span><span class="p">(</span><span class="n">original_segs</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_constrain_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_floor_geo</span><span class="p">,</span> <span class="n">pull_segments</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move vertices of this Room2D to preserve original edges.&quot;&quot;&quot;</span>
        <span class="c1"># get all of the vertices and segments needed for the operation</span>
        <span class="n">new_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span>
        <span class="n">new_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">segments</span>
        <span class="n">old_segs</span> <span class="o">=</span> <span class="n">original_floor_geo</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">segments</span>

        <span class="c1"># loop through the vertices and figure out which ones are along the pull_segments</span>
        <span class="n">pts_moved</span><span class="p">,</span> <span class="n">any_moved</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">new_segs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">o_seg</span> <span class="ow">in</span> <span class="n">pull_segments</span><span class="p">:</span>
                <span class="n">close_pt</span> <span class="o">=</span> <span class="n">closest_point2d_on_line2d</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">o_seg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">close_pt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="n">pts_moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">any_moved</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pts_moved</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">any_moved</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># set a maximum distance for which constrained points can move</span>
        <span class="n">o_geo</span> <span class="o">=</span> <span class="n">original_floor_geo</span>
        <span class="n">max_dist</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">o_geo</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">o_geo</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o_geo</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">o_geo</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="n">max_d</span> <span class="o">=</span> <span class="n">max_dist</span> <span class="o">*</span> <span class="mi">10</span>

        <span class="c1"># identify the start and end points of each stretch and move them</span>
        <span class="n">edit_boundary</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">last_vert_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">moved</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">new_verts</span><span class="p">,</span> <span class="n">pts_moved</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">moved</span><span class="p">:</span>
                <span class="n">prev_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">next_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">last_vert_i</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">pts_moved</span><span class="p">[</span><span class="n">prev_i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">pts_moved</span><span class="p">[</span><span class="n">next_i</span><span class="p">]:</span>  <span class="c1"># middle of a stretch</span>
                    <span class="n">edit_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">pts_moved</span><span class="p">[</span><span class="n">prev_i</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">pts_moved</span><span class="p">[</span><span class="n">next_i</span><span class="p">]:</span>  <span class="c1"># lone moved point</span>
                    <span class="n">edit_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">pts_moved</span><span class="p">[</span><span class="n">prev_i</span><span class="p">]:</span>  <span class="c1"># the end of a stretch</span>
                    <span class="n">prev_seg</span><span class="p">,</span> <span class="n">next_new_seg</span> <span class="o">=</span> <span class="n">new_segs</span><span class="p">[</span><span class="n">prev_i</span><span class="p">],</span> <span class="n">new_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">o_seg</span> <span class="ow">in</span> <span class="n">old_segs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">o_seg</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">next_new_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                            <span class="n">next_seg</span> <span class="o">=</span> <span class="n">o_seg</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># failed to find the original segment</span>
                        <span class="n">edit_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">ray_1</span> <span class="o">=</span> <span class="n">Ray2D</span><span class="p">(</span><span class="n">prev_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">prev_seg</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">ray_2</span> <span class="o">=</span> <span class="n">Ray2D</span><span class="p">(</span><span class="n">next_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="o">-</span><span class="n">next_seg</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">int_pt</span> <span class="o">=</span> <span class="n">ray_1</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">ray_2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">int_pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">next_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_d</span><span class="p">:</span>
                        <span class="n">edit_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">edit_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">int_pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">int_pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># the beginning of a stretch</span>
                    <span class="n">prev_new_seg</span><span class="p">,</span> <span class="n">next_seg</span> <span class="o">=</span> <span class="n">new_segs</span><span class="p">[</span><span class="n">prev_i</span><span class="p">],</span> <span class="n">new_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">o_seg</span> <span class="ow">in</span> <span class="n">old_segs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">o_seg</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">prev_new_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                            <span class="n">prev_seg</span> <span class="o">=</span> <span class="n">o_seg</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># failed to find the original segment</span>
                        <span class="n">edit_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                        <span class="k">continue</span>
                    <span class="n">ray_1</span> <span class="o">=</span> <span class="n">Ray2D</span><span class="p">(</span><span class="n">prev_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">prev_seg</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">ray_2</span> <span class="o">=</span> <span class="n">Ray2D</span><span class="p">(</span><span class="n">next_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="o">-</span><span class="n">next_seg</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">int_pt</span> <span class="o">=</span> <span class="n">ray_1</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">ray_2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">int_pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">next_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_d</span><span class="p">:</span>
                        <span class="n">edit_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">edit_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">int_pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">int_pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edit_boundary</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

        <span class="c1"># rebuild the floor_geometry of this room and add back any holes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
            <span class="n">edit_boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_re_center_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_segs</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-center window parameters when segment lengths have changed substantially.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">new_wp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">o_seg</span><span class="p">,</span> <span class="n">n_seg</span><span class="p">,</span> <span class="n">wp</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">original_segs</span><span class="p">,</span> <span class="n">new_segs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                <span class="n">new_wp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">delta_len</span> <span class="o">=</span> <span class="n">n_seg</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">o_seg</span><span class="o">.</span><span class="n">length</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">delta_len</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="n">new_wp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">shift_horizontally</span><span class="p">(</span><span class="n">delta_len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_wp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">new_wp</span>

<div class="viewcode-block" id="Room2D.coordinate_room_2d_vertices">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.coordinate_room_2d_vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">coordinate_room_2d_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room_2d</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert vertices to this Room2D to coordinate this Room2D with another Room2D.</span>

<span class="sd">        This is sometimes a useful operation to run after using the pull_to_room_2d</span>
<span class="sd">        method in order to address the case that the Room2D to which this one was</span>
<span class="sd">        pulled has more vertices along the adjacency boundary than this Room2D.</span>
<span class="sd">        In this case, the adjacency between the two Room2Ds will not be clean and</span>
<span class="sd">        extra vertices must be inserted into this Room2D so that geometry matches</span>
<span class="sd">        along the room adjacency.</span>

<span class="sd">        Any vertices of the neighboring input room_2d that are within the specified</span>
<span class="sd">        distance but cannot be matched to a vertex on this Room2D within the tolerance</span>
<span class="sd">        will be inserted into this Room2D, splitting the wall segment in the process.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2d: A Room2D with which the vertices of this Room2D will be coordinated.</span>
<span class="sd">            distance: The maximum distance between a Room2D vertex and the other</span>
<span class="sd">                Room2D where the vertex will be moved to lie on the other Room2D.</span>
<span class="sd">                Vertices beyond this distance will be left as they are.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which they are considered co-located. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># determine all of the vertices of the other Room2D that should be inserted</span>
        <span class="n">self_segs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">)</span>
        <span class="n">self_pts_2d</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">p</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">self_segs</span><span class="p">]</span>
        <span class="n">other_pts_2d</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">p</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">room_2d</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">]</span>
        <span class="n">insert_pts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">o_pt</span> <span class="ow">in</span> <span class="n">other_pts_2d</span><span class="p">:</span>
            <span class="n">possible_insert</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">self_segs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">o_pt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>
                    <span class="n">possible_insert</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">possible_insert</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s_pt</span> <span class="ow">in</span> <span class="n">self_pts_2d</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s_pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">o_pt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">insert_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">o_pt</span><span class="p">))</span>

        <span class="c1"># loop through the segments and split them if insertion points were found</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">insert_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">sort_int_pts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">insert_pts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">edit_code</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;K&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">self_segs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ins_ind</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">sort_int_pts</span><span class="p">:</span>
            <span class="n">split_seg</span> <span class="o">=</span> <span class="n">self_segs</span><span class="p">[</span><span class="n">ins_ind</span><span class="p">]</span>
            <span class="n">new_seg1</span> <span class="o">=</span> <span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">split_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
            <span class="n">new_seg2</span> <span class="o">=</span> <span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">split_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
            <span class="n">self_segs</span><span class="p">[</span><span class="n">ins_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_seg2</span>
            <span class="n">self_segs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ins_ind</span><span class="p">,</span> <span class="n">new_seg1</span><span class="p">)</span>
            <span class="n">edit_code</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ins_ind</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>

        <span class="c1"># create a new floor_geometry Face3D and update the geometry with the edit code</span>
        <span class="n">z_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">self_segs</span><span class="p">]</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">joined_segs</span> <span class="o">=</span> <span class="n">Polyline2D</span><span class="o">.</span><span class="n">join_segments</span><span class="p">(</span><span class="n">self_segs</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="n">new_loops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p_line</span> <span class="ow">in</span> <span class="n">joined_segs</span><span class="p">:</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">p_line</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">new_loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">new_loops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_floor_geometry</span><span class="p">(</span><span class="n">new_geo</span><span class="p">,</span> <span class="n">edit_code</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.coordinate_segment_vertices">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.coordinate_segment_vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">coordinate_segment_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line_segments</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert vertices to this Room2D to coordinate this Room2D with line segments.</span>

<span class="sd">        This is sometimes a useful operation to run after using the pull_to_segments</span>
<span class="sd">        method in order to address the case that the segments to which this Room2D was</span>
<span class="sd">        pulled have more vertices along the adjacency boundary than what this Room2D</span>
<span class="sd">        started with.</span>

<span class="sd">        Any vertices of the line_segments that are within the specified distance but</span>
<span class="sd">        cannot be matched to a vertex on this Room2D within the tolerance will be</span>
<span class="sd">        inserted into this Room2D, splitting the wall segment in the process.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_segments: A list of ladybug_geometry LineSegment2D with which this</span>
<span class="sd">                Room2D&#39;s vertices will be coordinated.</span>
<span class="sd">            distance: The maximum distance between a Room2D vertex and the line</span>
<span class="sd">                segment end points where the vertex will be moved to lie at the</span>
<span class="sd">                end point of the segment. Vertices beyond this distance will be</span>
<span class="sd">                left as they are.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which they are considered co-located. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># determine all of the vertices of the other Room2D that should be inserted</span>
        <span class="n">self_segs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">)</span>
        <span class="n">self_pts_2d</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">p</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">self_segs</span><span class="p">]</span>
        <span class="n">other_pts_2d</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">line_segments</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_pts_2d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> \
                    <span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">other_pts_2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="n">other_pts_2d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span>
            <span class="n">other_pts_2d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
        <span class="n">insert_pts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">o_pt</span> <span class="ow">in</span> <span class="n">other_pts_2d</span><span class="p">:</span>
            <span class="n">possible_insert</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">self_segs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">o_pt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>
                    <span class="n">possible_insert</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">possible_insert</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">s_pt</span> <span class="ow">in</span> <span class="n">self_pts_2d</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s_pt</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">o_pt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">insert_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">o_pt</span><span class="p">))</span>

        <span class="c1"># loop through the segments and split them if insertion points were found</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">insert_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">sort_int_pts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">insert_pts</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">edit_code</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;K&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">self_segs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ins_ind</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">sort_int_pts</span><span class="p">:</span>
            <span class="n">split_seg</span> <span class="o">=</span> <span class="n">self_segs</span><span class="p">[</span><span class="n">ins_ind</span><span class="p">]</span>
            <span class="n">new_seg1</span> <span class="o">=</span> <span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">split_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span>
            <span class="n">new_seg2</span> <span class="o">=</span> <span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">split_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
            <span class="n">self_segs</span><span class="p">[</span><span class="n">ins_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_seg2</span>
            <span class="n">self_segs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ins_ind</span><span class="p">,</span> <span class="n">new_seg1</span><span class="p">)</span>
            <span class="n">edit_code</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ins_ind</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>

        <span class="c1"># create a new floor_geometry Face3D and update the geometry with the edit code</span>
        <span class="n">z_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">self_segs</span><span class="p">]</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">joined_segs</span> <span class="o">=</span> <span class="n">Polyline2D</span><span class="o">.</span><span class="n">join_segments</span><span class="p">(</span><span class="n">self_segs</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="n">new_loops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p_line</span> <span class="ow">in</span> <span class="n">joined_segs</span><span class="p">:</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">p_line</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">new_loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">new_loops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_floor_geometry</span><span class="p">(</span><span class="n">new_geo</span><span class="p">,</span> <span class="n">edit_code</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.remove_duplicate_vertices">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_duplicate_vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_duplicate_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove duplicate vertices from this Room2D.</span>

<span class="sd">        All properties assigned to the Room2D will be preserved.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum distance between a vertex and the line it lies</span>
<span class="sd">                upon at which point the vertex is considered colinear. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of integers for the indices of segments that have been removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loop through the vertices and remove any duplicates</span>
        <span class="n">exist_abs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span>
        <span class="n">new_bound</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">b_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span>
        <span class="n">b_pts</span> <span class="o">=</span> <span class="n">b_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
        <span class="n">removed_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">b_pts</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">vert</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">b_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">):</span>
                <span class="n">new_bound</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">removed_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">new_holes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">new_holes</span><span class="p">,</span> <span class="n">seg_count</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_pts</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="n">new_h_pts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">h_pts</span> <span class="o">=</span> <span class="n">hole</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">hole</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">h_pts</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">vert</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">h_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="n">new_h_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_pts</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                        <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                        <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                        <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">removed_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_h_pts</span><span class="p">)</span>
                <span class="n">seg_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_pts</span><span class="p">)</span>

        <span class="c1"># assign the geometry and properties</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
                <span class="n">new_bound</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># usually a sliver face of some kind</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; is degenerate with dimensions less than the &#39;</span>
                <span class="s1">&#39;tolerance.</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_win</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">new_shd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span>
        <span class="k">return</span> <span class="n">removed_indices</span></div>


<div class="viewcode-block" id="Room2D.remove_degenerate_holes">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_degenerate_holes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_degenerate_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove any holes in this Room2D with an area that evaluates to zero.</span>

<span class="sd">        All properties assigned to the Room2D will be preserved.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which they are considered co-located. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>  <span class="c1"># first identify any zero-area holes</span>
            <span class="n">holes_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hole</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">):</span>
                <span class="n">tf</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span>
                <span class="n">max_dim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="n">tf</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">tf</span><span class="o">.</span><span class="n">area</span> <span class="o">&lt;</span> <span class="n">max_dim</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="n">holes_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># if zero-area holes were found, rebuild the Room2D</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">holes_to_remove</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_remove_holes</span><span class="p">(</span><span class="n">holes_to_remove</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.remove_small_holes">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_small_holes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_small_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">area_threshold</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove any holes in this Room2D that are below a certain area threshold.</span>

<span class="sd">        All properties assigned to the Room2D will be preserved.</span>

<span class="sd">        Args:</span>
<span class="sd">            area_threshold: A number for the area below which holes will be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>  <span class="c1"># first identify any holes to remove</span>
            <span class="n">holes_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">hole</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">):</span>
                <span class="n">tf</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tf</span><span class="o">.</span><span class="n">area</span> <span class="o">&lt;</span> <span class="n">area_threshold</span><span class="p">:</span>
                    <span class="n">holes_to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># if removable holes were found, rebuild the Room2D</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">holes_to_remove</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_remove_holes</span><span class="p">(</span><span class="n">holes_to_remove</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_remove_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">holes_to_remove</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove holes in the Room2D given the indices of the holes.</span>

<span class="sd">        Args:</span>
<span class="sd">            holes_to_remove: A list of integers for the indices of holes to be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first collect the properties of the boundary</span>
        <span class="n">exist_abs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span>
        <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">seg_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">seg_count</span><span class="p">):</span>
            <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># collect the properties of the new holes</span>
        <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">hi</span><span class="p">,</span> <span class="n">hole</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">hi</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">holes_to_remove</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vert</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hole</span><span class="p">):</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                    <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                    <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">seg_count</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span>
                    <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
            <span class="n">seg_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
        <span class="c1"># reset the properties of the Room2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bcs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_win</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">new_shd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span>

<div class="viewcode-block" id="Room2D.update_floor_geometry">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.update_floor_geometry">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_floor_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_floor_geometry</span><span class="p">,</span> <span class="n">edit_code</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Change the floor_geometry of the Room2D with segment-altering specifications.</span>

<span class="sd">        This method is intended to be used when the floor geometry has been edited</span>
<span class="sd">        by some simple operation (eg. adding, removing or moving a vertex).</span>
<span class="sd">        Effectively all properties of the wall segments are preserved, including</span>
<span class="sd">        windows and boundary conditions.</span>

<span class="sd">        The method tries to infer whether an removed floor segment means that an</span>
<span class="sd">        original segment has been merged into another or removed completely using</span>
<span class="sd">        the colinearity of the original segments. A removed segment that is colinear</span>
<span class="sd">        with its neighbor will be merged into it while a removed segment that was</span>
<span class="sd">        not colinear will simply be deleted. Similarly, the method will infer if</span>
<span class="sd">        an added segment indicates a split in an original segment using colinearity.</span>
<span class="sd">        When the result in the new_floor_geometry is two colinear segments,</span>
<span class="sd">        properties of the original segment will be split across the new segments.</span>
<span class="sd">        Otherwise the new segment will receive default properties.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_floor_geometry: A Face3D for the new floor_geometry of this Room2D.</span>
<span class="sd">                Note that this method expects the plane of this Face3D to match</span>
<span class="sd">                the original floor_geometry Face3D.</span>
<span class="sd">            edit_code: A text string that indicates the operations that were</span>
<span class="sd">                performed on the original floor_geometry segments to yield the</span>
<span class="sd">                new_floor_geometry. The following letters are used in this code</span>
<span class="sd">                to indicate the following:</span>

<span class="sd">                * K = a segment that has been kept (possibly moved but not removed)</span>
<span class="sd">                * X = a segment that has been removed</span>
<span class="sd">                * A = a segment that has been added</span>

<span class="sd">                For example, KXKAKKA means that the first segment was kept, the</span>
<span class="sd">                next removed, the next kept, the next added, followed by two kept</span>
<span class="sd">                segments and ending in an added segment.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which they are considered co-located, used to determine</span>
<span class="sd">                colinearity. Default: 0.01, suitable for objects in meters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process the new floor geometry so that it abides by Room2D rules</span>
        <span class="k">if</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ensure upward-facing Face3D</span>
            <span class="n">new_floor_geometry</span> <span class="o">=</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="n">o_pl</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="n">new_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">o_pl</span><span class="p">,</span>
                                    <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>

        <span class="c1"># get the original and the new floor segments</span>
        <span class="n">orig_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">new_segs</span> <span class="o">=</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="k">if</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> \
            <span class="kc">None</span> <span class="k">else</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">hole_segments</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span>

        <span class="c1"># figure out the new properties based on the edit code</span>
        <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">last_o_seg</span> <span class="o">=</span> <span class="n">orig_segs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">orig_i</span><span class="p">,</span> <span class="n">new_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">edit_val</span> <span class="ow">in</span> <span class="n">edit_code</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edit_val</span> <span class="o">==</span> <span class="s1">&#39;K&#39;</span><span class="p">:</span>
                <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">orig_i</span><span class="p">])</span>
                <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">orig_i</span><span class="p">])</span>
                <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">orig_i</span><span class="p">])</span>
                <span class="n">last_o_seg</span> <span class="o">=</span> <span class="n">orig_segs</span><span class="p">[</span><span class="n">orig_i</span><span class="p">]</span>
                <span class="n">orig_i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">new_i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">edit_val</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
                <span class="c1"># determine if the removed segment is colinear</span>
                <span class="n">del_seg</span> <span class="o">=</span> <span class="n">orig_segs</span><span class="p">[</span><span class="n">orig_i</span><span class="p">]</span>
                <span class="n">full_line</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">last_o_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">del_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">full_line</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">del_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>  <span class="c1"># colinear!</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bcs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># TODO: figure out a strategy to merge first to end of the list</span>
                        <span class="n">new_bcs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
                        <span class="n">new_win</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">new_win</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">orig_i</span><span class="p">]),</span>
                            <span class="p">(</span><span class="n">last_o_seg</span><span class="p">,</span> <span class="n">del_seg</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
                    <span class="n">last_o_seg</span> <span class="o">=</span> <span class="n">full_line</span>
                <span class="n">orig_i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">edit_val</span> <span class="o">==</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span>
                <span class="c1"># determine if the added segment is colinear and within the original</span>
                <span class="n">add_seg</span> <span class="o">=</span> <span class="n">new_segs</span><span class="p">[</span><span class="n">new_i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">last_o_seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">add_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                        <span class="n">last_o_seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">add_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># colinear!</span>
                    <span class="n">orig_i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">orig_i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> \
                        <span class="k">else</span> <span class="n">orig_i</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">orig_i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_win</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">new_win</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># TODO: figure out a strategy to split the end of the list</span>
                        <span class="n">p_lin</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">last_o_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">add_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span>
                        <span class="n">a_lin</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">add_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">last_o_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
                        <span class="n">w_to_spl</span> <span class="o">=</span> <span class="n">new_win</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                        <span class="n">new_win</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">w_to_spl</span><span class="o">.</span><span class="n">split</span><span class="p">((</span><span class="n">p_lin</span><span class="p">,</span> <span class="n">a_lin</span><span class="p">),</span> <span class="n">tolerance</span><span class="p">))</span>
                        <span class="n">last_o_seg</span> <span class="o">=</span> <span class="n">a_lin</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[</span><span class="n">orig_i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># not colinear; use default properties</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
                    <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">new_i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># assign the updated properties to this Room2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">new_floor_geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_segs</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_bcs</span><span class="p">),</span> <span class="s1">&#39;The operations in the edit_code &#39;</span> \
            <span class="s1">&#39;denote a geometry with </span><span class="si">{}</span><span class="s1"> segments but the new_floor_geometry has </span><span class="si">{}</span><span class="s1"> &#39;</span> \
            <span class="s1">&#39;segments.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_bcs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_win</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="n">new_shd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># reset to avoid any conflicts</span></div>


<div class="viewcode-block" id="Room2D.replace_floor_geometry">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.replace_floor_geometry">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">replace_floor_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_floor_geometry</span><span class="p">,</span> <span class="n">projection_distance</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                               <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace the floor_geometry of this Room2D while retaining some wall info.</span>

<span class="sd">        This method is intended to be used when the floor geometry has undergone</span>
<span class="sd">        a fairly complex set of edits and some loss of windows or boundary conditions</span>
<span class="sd">        is acceptable or expected when parts of the new floor geometry lie far</span>
<span class="sd">        away from the original room geometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_floor_geometry: A Face3D for the new floor_geometry of this Room2D.</span>
<span class="sd">                Note that this method expects the plane of this Face3D to match</span>
<span class="sd">                the original floor_geometry Face3D.</span>
<span class="sd">            projection_distance: An optional number to be used to project the</span>
<span class="sd">                original window and door geometry onto the wall segments of the</span>
<span class="sd">                new floor geometry. If specified, then windows/doors on the original</span>
<span class="sd">                geometry that have moved within this distance will be preserved</span>
<span class="sd">                as the floor geometry is replaced. Otherwise, windows/doors will</span>
<span class="sd">                only be added if they are on a wall segment that has not moved</span>
<span class="sd">                at all between the original and new floor geometry.</span>
<span class="sd">            tolerance: The minimum difference in coordinate values for them</span>
<span class="sd">                to be considered distinct from one another. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">            angle_tolerance: The max angle difference in degrees that wall segments</span>
<span class="sd">                and sub-faces can differ from one another in order for them to</span>
<span class="sd">                be re-projected onto the new floor geometry. (Default: 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process the new floor geometry so that it abides by Room2D rules</span>
        <span class="k">if</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ensure upward-facing Face3D</span>
            <span class="n">new_floor_geometry</span> <span class="o">=</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="n">o_pl</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="n">new_floor_geometry</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">o_pl</span><span class="p">,</span>
                                    <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>

        <span class="c1"># convert the original geometry to honeybee so we get 3D sub-faces</span>
        <span class="n">hb_room</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_honeybee</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">enforce_bc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="n">enforce_solid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">hb_sub_faces</span> <span class="o">=</span> <span class="n">hb_room</span><span class="o">.</span><span class="n">apertures</span> <span class="o">+</span> <span class="n">hb_room</span><span class="o">.</span><span class="n">doors</span>

        <span class="c1"># match the segments of the floor geometry to walls of the Room</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="k">if</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> \
            <span class="kc">None</span> <span class="k">else</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">new_floor_geometry</span><span class="o">.</span><span class="n">hole_segments</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span>
        <span class="n">new_bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="n">air_bounds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segs</span><span class="p">):</span>
            <span class="n">wall_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_wall_face</span><span class="p">(</span><span class="n">hb_room</span><span class="p">,</span> <span class="n">seg</span><span class="p">,</span> <span class="n">projection_distance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">wall_f</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">boundary_condition</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                    <span class="n">new_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wall_f</span><span class="o">.</span><span class="n">boundary_condition</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wall_f</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">AirBoundary</span><span class="p">):</span>
                    <span class="n">air_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># assign the updated properties to this Room2D</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="n">new_floor_geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shading_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span> <span class="o">=</span> <span class="n">new_bcs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="n">air_bounds</span>

        <span class="c1"># assign the windows back to this room using the 3D version of the originals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assign_sub_faces</span><span class="p">(</span><span class="n">hb_sub_faces</span><span class="p">,</span> <span class="n">projection_distance</span><span class="o">=</span><span class="n">projection_distance</span><span class="p">,</span>
                              <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="n">angle_tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.remove_colinear_vertices">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_colinear_vertices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_colinear_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">preserve_wall_props</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a version of this Room2D without colinear or duplicate vertices.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum distance between a vertex and the line it lies</span>
<span class="sd">                upon at which point the vertex is considered colinear. Default: 0.01,</span>
<span class="sd">                suitable for objects in meters.</span>
<span class="sd">            preserve_wall_props: Boolean to note whether existing window parameters</span>
<span class="sd">                and Ground boundary conditions should be preserved as vertices are</span>
<span class="sd">                removed. If False, all boundary conditions are replaced with Outdoors,</span>
<span class="sd">                all window parameters are erased, and this method will execute quickly.</span>
<span class="sd">                If True, an attempt will be made to merge window parameters together</span>
<span class="sd">                across colinear segments, translating simple window parameters to</span>
<span class="sd">                rectangular ones if necessary. Also, existing Ground boundary</span>
<span class="sd">                conditions will be kept. (Default: True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new Room2D derived from this one with its colinear vertices removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">preserve_wall_props</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># remove colinear vertices from the Room2D</span>
                <span class="n">new_geo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># usually a sliver face of some kind</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; is degenerate with dimensions less than the &#39;</span>
                    <span class="s1">&#39;tolerance.</span><span class="se">\n</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
            <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span>
                <span class="n">is_top_exposed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ftc_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>  <span class="c1"># only need to evaluate one list</span>
                <span class="n">pts_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">vertices</span>
                <span class="n">pts_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">polygon2d</span>
                <span class="n">segs_2d</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="o">.</span><span class="n">segments</span>
                <span class="n">bound_cds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_conditions</span>
                <span class="n">win_pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span>
                <span class="n">bound_verts</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_w_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_colinear_props</span><span class="p">(</span>
                    <span class="n">pts_3d</span><span class="p">,</span> <span class="n">pts_2d</span><span class="p">,</span> <span class="n">segs_2d</span><span class="p">,</span> <span class="n">bound_cds</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="n">holes</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pts_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span>
                <span class="n">pts_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span>
                <span class="n">segs_2d</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="o">.</span><span class="n">segments</span>
                <span class="n">st_i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">)</span>
                <span class="n">bound_cds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_conditions</span><span class="p">[:</span><span class="n">st_i</span><span class="p">]</span>
                <span class="n">win_pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span><span class="p">[:</span><span class="n">st_i</span><span class="p">]</span>
                <span class="n">bound_verts</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_w_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_colinear_props</span><span class="p">(</span>
                    <span class="n">pts_3d</span><span class="p">,</span> <span class="n">pts_2d</span><span class="p">,</span> <span class="n">segs_2d</span><span class="p">,</span> <span class="n">bound_cds</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="n">holes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pts_3d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">):</span>
                    <span class="n">pts_2d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">hole_polygon2d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">segs_2d</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="o">.</span><span class="n">segments</span>
                    <span class="n">bound_cds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_conditions</span><span class="p">[</span><span class="n">st_i</span><span class="p">:</span><span class="n">st_i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">)]</span>
                    <span class="n">win_pars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span><span class="p">[</span><span class="n">st_i</span><span class="p">:</span><span class="n">st_i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">)]</span>
                    <span class="n">st_i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">)</span>
                    <span class="n">h_verts</span><span class="p">,</span> <span class="n">h_bcs</span><span class="p">,</span> <span class="n">h_w_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remove_colinear_props</span><span class="p">(</span>
                        <span class="n">pts_3d</span><span class="p">,</span> <span class="n">pts_2d</span><span class="p">,</span> <span class="n">segs_2d</span><span class="p">,</span> <span class="n">bound_cds</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span>
                        <span class="n">ftc_height</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">h_verts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_verts</span><span class="p">)</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">h_bcs</span><span class="p">)</span>
                    <span class="n">new_w_par</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">h_w_par</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bound_verts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; is degenerate with dimensions less than the &#39;</span>
                    <span class="s1">&#39;tolerance.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">))</span>

            <span class="c1"># create the new Room2D</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">holes</span><span class="p">)</span>
            <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">new_bcs</span><span class="p">,</span> <span class="n">window_parameters</span><span class="o">=</span><span class="n">new_w_par</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span>
                <span class="n">is_top_exposed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>

        <span class="c1"># assign overall properties to the rebuilt room</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_floor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_ceiling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_data</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abridged_properties</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rebuilt_room</span></div>


<div class="viewcode-block" id="Room2D.remove_short_segments">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.remove_short_segments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_short_segments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a version of this Room2D with consecutive short segments removed.</span>

<span class="sd">        To patch over the segments, an attempt will first be made to find the</span>
<span class="sd">        intersection of the two neighboring segments. If these two lines are parallel,</span>
<span class="sd">        they will simply be connected with a segment.</span>

<span class="sd">        Properties assigned to the Room2D will be preserved for the segments that</span>
<span class="sd">        are not removed.</span>

<span class="sd">        Args:</span>
<span class="sd">            distance: The maximum length of a segment below which the segment</span>
<span class="sd">                will be considered for removal.</span>
<span class="sd">            angle_tolerance: The max angle difference in degrees that vertices</span>
<span class="sd">                are allowed to differ from one another in order to consider them</span>
<span class="sd">                colinear. (Default: 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check if there are contiguous short segments to be removed</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_segments</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">hole_segments</span><span class="p">:</span>
                <span class="n">segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
        <span class="n">sh_seg_i</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sg</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">distance</span><span class="p">]</span> <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh_seg_i</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># large distance means the whole Face becomes removed</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sh_seg_i</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># no short segments to remove</span>
        <span class="n">del_seg_i</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sh_seg</span> <span class="ow">in</span> <span class="n">sh_seg_i</span><span class="p">:</span>
            <span class="n">del_seg</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sh_seg</span><span class="p">):</span>
                <span class="n">test_val</span> <span class="o">=</span> <span class="n">seg_i</span> <span class="o">-</span> <span class="n">sh_seg</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">test_val</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">seg_i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">test_val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">del_seg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sh_seg</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">del_seg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">seg_i</span><span class="p">)</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">sh_seg</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh_seg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">sh_seg</span><span class="p">:</span>
                <span class="n">del_seg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">del_seg</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sh_seg</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">del_seg_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">del_seg</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">del_seg_i</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>  <span class="c1"># there are short segments but they&#39;re not contiguous</span>

        <span class="c1"># contiguous short segments found</span>
        <span class="c1"># collect the vertices and indices of properties to be removed</span>
        <span class="n">a_tol</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">prev_i</span><span class="p">,</span> <span class="n">final_pts</span><span class="p">,</span> <span class="n">del_prop_i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p_segs</span><span class="p">,</span> <span class="n">del_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">del_seg_i</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">del_i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># set up variables to handle getting the last vertex to connect to</span>
                <span class="n">new_points</span><span class="p">,</span> <span class="n">in_del</span><span class="p">,</span> <span class="n">post_del</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">del_i</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_segs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">del_i</span><span class="p">:</span>
                    <span class="n">last_i</span><span class="p">,</span> <span class="n">in_del</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">while</span> <span class="n">del_i</span><span class="p">[</span><span class="n">last_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">del_i</span><span class="p">[</span><span class="n">last_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">last_i</span> <span class="o">-=</span> <span class="mi">1</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># entire hole to be removed</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_segs</span><span class="p">)):</span>
                            <span class="n">del_prop_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_i</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">p_segs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># loop through the segments and delete the short ones</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p_segs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">del_i</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">in_del</span><span class="p">:</span>
                            <span class="n">last_i</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="n">in_del</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">del_prop_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prev_i</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">rel_i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_segs</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">rel_i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">del_i</span><span class="p">:</span>  <span class="c1"># we are at the end of the deletion</span>
                            <span class="c1"># see if we can repair the hole by extending segments</span>
                            <span class="n">l3a</span><span class="p">,</span> <span class="n">l3b</span> <span class="o">=</span> <span class="n">p_segs</span><span class="p">[</span><span class="n">last_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p_segs</span><span class="p">[</span><span class="n">rel_i</span><span class="p">]</span>
                            <span class="n">l2a</span> <span class="o">=</span> <span class="n">Ray2D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">(</span><span class="n">l3a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l3a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                                        <span class="n">Vector2D</span><span class="p">(</span><span class="n">l3a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l3a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                            <span class="n">l2b</span> <span class="o">=</span> <span class="n">Ray2D</span><span class="p">(</span><span class="n">Point2D</span><span class="p">(</span><span class="n">l3b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l3b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">),</span>
                                        <span class="n">Vector2D</span><span class="p">(</span><span class="n">l3b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">l3b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                            <span class="n">v_ang</span> <span class="o">=</span> <span class="n">l2a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">l2b</span><span class="o">.</span><span class="n">v</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">v_ang</span> <span class="o">&lt;=</span> <span class="n">a_tol</span> <span class="ow">or</span> <span class="n">v_ang</span> <span class="o">&gt;=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">a_tol</span><span class="p">:</span>  <span class="c1"># parallel</span>
                                <span class="n">new_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_segs</span><span class="p">[</span><span class="n">last_i</span><span class="p">]</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                                <span class="n">del_prop_i</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># put back the last property</span>
                            <span class="k">else</span><span class="p">:</span>  <span class="c1"># extend lines to the intersection</span>
                                <span class="n">int_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intersect_line2d_infinite</span><span class="p">(</span><span class="n">l2a</span><span class="p">,</span> <span class="n">l2b</span><span class="p">)</span>
                                <span class="n">int_pt3</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">int_pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">int_pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span>
                                <span class="n">new_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">int_pt3</span><span class="p">)</span>
                                <span class="n">post_del</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">in_del</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">post_del</span><span class="p">:</span>
                            <span class="n">new_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lin</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                        <span class="n">post_del</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">post_del</span><span class="p">:</span>
                    <span class="n">new_points</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># put back the last property</span>
                    <span class="n">del_prop_i</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_points</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">final_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_points</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># no short segments to remove on this hole or boundary</span>
                <span class="n">final_pts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">lin</span><span class="o">.</span><span class="n">p</span> <span class="k">for</span> <span class="n">lin</span> <span class="ow">in</span> <span class="n">p_segs</span><span class="p">])</span>
            <span class="n">prev_i</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">p_segs</span><span class="p">)</span>

        <span class="c1"># create the geometry and convert properties for the new segments</span>
        <span class="n">holes</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">final_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">final_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="n">holes</span><span class="p">)</span>
        <span class="n">new_bcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[:]</span>
        <span class="n">new_win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[:]</span>
        <span class="n">new_shd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[:]</span>
        <span class="n">new_abs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span><span class="p">)</span>
        <span class="n">all_props</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">prop_list</span> <span class="ow">in</span> <span class="n">all_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">del_prop_i</span><span class="p">):</span>
                <span class="n">prop_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">di</span><span class="p">)</span>

        <span class="c1"># create the final rebuilt Room2D and return it</span>
        <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span>
            <span class="n">new_shd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_floor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_ceiling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_data</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abridged_properties</span>
        <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rebuilt_room</span></div>


<div class="viewcode-block" id="Room2D.subtract_room_2ds">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.subtract_room_2ds">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">subtract_room_2ds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get (a) version(s) of this Room2D with other Room2Ds subtracted from it.</span>

<span class="sd">        This is useful for resolving overlaps between Room2Ds of the same Story.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2d: A Room2D that will be subtracted from this Room2D.</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct from one another. (Default: 0.01; suitable</span>
<span class="sd">                for objects in Meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2D for the result of splitting this Room2D with the</span>
<span class="sd">            input line. Will be a list with only the current Room2D if the line</span>
<span class="sd">            does not split it into two or more pieces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first check that the two geometries have the same Z coordinate</span>
        <span class="n">self_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span>
        <span class="n">z_v</span> <span class="o">=</span> <span class="n">self_face</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>
        <span class="n">other_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">room_2d</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="n">face2</span> <span class="o">=</span> <span class="n">room_2d</span><span class="o">.</span><span class="n">floor_geometry</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">self_face</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">face2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="n">new_bound</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">face2</span><span class="o">.</span><span class="n">boundary</span><span class="p">]</span>
                <span class="n">new_orig</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">face2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">face2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_v</span><span class="p">)</span>
                <span class="n">new_plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">face2</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">o</span><span class="o">=</span><span class="n">new_orig</span><span class="p">)</span>
                <span class="n">new_holes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">h</span><span class="p">]</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">face2</span><span class="o">.</span><span class="n">holes</span><span class="p">]</span> \
                    <span class="k">if</span> <span class="n">face2</span><span class="o">.</span><span class="n">has_holes</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">face2</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">new_bound</span><span class="p">,</span> <span class="n">new_plane</span><span class="p">,</span> <span class="n">new_holes</span><span class="p">)</span>
            <span class="n">other_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face2</span><span class="p">)</span>

        <span class="c1"># subtract the other Room2Ds from this one</span>
        <span class="n">ang_tol</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_geos</span> <span class="o">=</span> <span class="n">self_face</span><span class="o">.</span><span class="n">coplanar_difference</span><span class="p">(</span><span class="n">other_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">ang_tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">new_geos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">self_face</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>  <span class="c1"># the Face3D did not overlap with one another</span>
        <span class="n">new_geos</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># create the final rebuilt Room2Ds and return them</span>
        <span class="n">new_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">new_geo</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_geos</span><span class="p">):</span>
            <span class="n">rm_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="n">rm_id</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span>
                <span class="n">is_top_exposed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_match_and_transfer_wall_props</span><span class="p">(</span><span class="n">rebuilt_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_floor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_ceiling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_data</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abridged_properties</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
            <span class="n">new_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rebuilt_room</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_rooms</span></div>


<div class="viewcode-block" id="Room2D.split_with_line">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_line">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_with_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get this Room2D split by a line.</span>

<span class="sd">        If the input line does not intersect this Room2D in a manner that splits</span>
<span class="sd">        it into two or more pieces, a list with only the current room will be</span>
<span class="sd">        returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            line: A LineSegment2D object that will be used to split this Room2D</span>
<span class="sd">                into two or more pieces.</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct from one another. (Default: 0.01; suitable</span>
<span class="sd">                for objects in Meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2D for the result of splitting this Room2D with the</span>
<span class="sd">            input line. Will be a list with only the current Room2D if the line</span>
<span class="sd">            does not split it into two or more pieces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the line for the closest point calculation</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LineSegment2D</span><span class="p">):</span>
            <span class="c1"># check if the coordinate values are too high to resolve with tolerance</span>
            <span class="n">t_up</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="o">*</span> <span class="mf">1e6</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">t_up</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">t_up</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">t_up</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">t_up</span><span class="p">:</span>
                <span class="n">min_pt</span><span class="p">,</span> <span class="n">max_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">hgt</span> <span class="o">=</span> <span class="n">max_pt</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">min_pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max_pt</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">min_pt</span><span class="o">.</span><span class="n">y</span>
                <span class="n">bound_rect</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">from_rectangle</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">base</span><span class="p">,</span> <span class="n">hgt</span><span class="p">)</span>
                <span class="n">inter_pts</span> <span class="o">=</span> <span class="n">bound_rect</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">inter_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inter_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">line_3d</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">),</span>
                                    <span class="n">Vector3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected LineSegment2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># split the Room2D with the line</span>
        <span class="n">new_geos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">split_with_line</span><span class="p">(</span><span class="n">line_3d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_geos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>  <span class="c1"># the line did not overlap with the Room2D</span>
        <span class="c1"># create the final Room2Ds</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_split_rooms</span><span class="p">(</span><span class="n">new_geos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.split_with_polyline">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_polyline">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_with_polyline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polyline</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get this Room2D split into two or more Room2Ds by a polyline.</span>

<span class="sd">        If the input polyline does not intersect this Room2D in a manner that splits</span>
<span class="sd">        it into two or more pieces, a list with only the current room will be</span>
<span class="sd">        returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            polyline: A Polyline2D object that will be used to split this Room2D</span>
<span class="sd">                into two or more pieces.</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct from one another. (Default: 0.01; suitable</span>
<span class="sd">                for objects in Meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2D for the result of splitting this Room2D with the</span>
<span class="sd">            input polyline. Will be a list with only the current Room2D if the</span>
<span class="sd">            polyline does not split it into two or more pieces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the polyline for the closest point calculation</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polyline</span><span class="p">,</span> <span class="n">Polyline2D</span><span class="p">):</span>
            <span class="n">polyline_3d</span> <span class="o">=</span> <span class="n">Polyline3D</span><span class="p">(</span>
                <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">polyline</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected Polyline2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">polyline</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># split the Room2D with the polyline</span>
        <span class="n">new_geos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">split_with_polyline</span><span class="p">(</span><span class="n">polyline_3d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_geos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>  <span class="c1"># the polyline did not overlap with the Room2D</span>
        <span class="c1"># create the final Room2Ds</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_split_rooms</span><span class="p">(</span><span class="n">new_geos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.split_with_polygon">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_polygon">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_with_polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get this Room2D split into two or more Room2Ds by a polygon.</span>

<span class="sd">        If the input polygon does not intersect this Room2D in a manner that splits</span>
<span class="sd">        it into two or more pieces, a list with only the current room will be</span>
<span class="sd">        returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            polygon: A Polygon2D object that will be used to split this Room2D</span>
<span class="sd">                into two or more pieces.</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct from one another. (Default: 0.01; suitable</span>
<span class="sd">                for objects in Meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2D for the result of splitting this Room2D with the</span>
<span class="sd">            input polygon. Will be a list with only the current Room2D if the</span>
<span class="sd">            polygon does not split it into two or more pieces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the polygon for the closest point calculation</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">Polygon2D</span><span class="p">):</span>
            <span class="n">face_3d</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span>
                <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">polygon</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected Polygon2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">polygon</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># split the Room2D with the polygon</span>
        <span class="n">ang_tol</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">new_geos</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">coplanar_split</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">face_3d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">ang_tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_geos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>  <span class="c1"># the polygon did not overlap with the Room2D</span>
        <span class="c1"># create the final Room2Ds</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_split_rooms</span><span class="p">(</span><span class="n">new_geos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.split_with_lines">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_lines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_with_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get this Room2D split by multiple line segments together.</span>

<span class="sd">        Using this method is distinct from looping over the Room2D.split_with_line</span>
<span class="sd">        in that this method will resolve cases where multiple segments branch out</span>
<span class="sd">        from nodes in a network of input lines. So, if three line segments</span>
<span class="sd">        meet at a point in the middle of this Room2D and each extend past the</span>
<span class="sd">        edges of this Room2D, this method can split the Room2D in 3 parts whereas</span>
<span class="sd">        looping over the Room2D.split_with_line will not do this given that each</span>
<span class="sd">        individual segment cannot split the Room2D.</span>

<span class="sd">        If the input lines together do not intersect this Room2D in a manner</span>
<span class="sd">        that splits it into two or more pieces, a list with only the current</span>
<span class="sd">        room will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            lines: A list of LineSegment2D objects that will be used to split</span>
<span class="sd">                this Room2D into two or more pieces.</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct from one another. (Default: 0.01; suitable</span>
<span class="sd">                for objects in Meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2D for the result of splitting this Room2D with the</span>
<span class="sd">            input line. Will be a list with only the current Room2D if the line</span>
<span class="sd">            does not split it into two or more pieces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create 3D versions of the lines for the closest point calculation</span>
        <span class="n">lines_3d</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LineSegment2D</span><span class="p">):</span>
                <span class="n">line_3d</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">),</span>
                                        <span class="n">Vector3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">lines_3d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line_3d</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected LineSegment2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># split the Room2D with the line</span>
        <span class="n">new_geos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">split_with_lines</span><span class="p">(</span><span class="n">lines_3d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_geos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>  <span class="c1"># the lines did not overlap with the Room2D</span>
        <span class="c1"># create the final Room2Ds</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_split_rooms</span><span class="p">(</span><span class="n">new_geos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.split_through_self_intersection">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_through_self_intersection">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_through_self_intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">overlap_room</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of non-intersecting Room2Ds if this Room2D intersects itself.</span>

<span class="sd">        If the Room2D does not intersect itself, a list with only the current</span>
<span class="sd">        Room2D instance will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            overlap_room: An optional Room2D, which will be used to ensure that the</span>
<span class="sd">                output list includes only the split Room2D with the highest overlap</span>
<span class="sd">                with this Room2D. This is useful when this method is being used</span>
<span class="sd">                as a cleanup operation for another method that accidentally created</span>
<span class="sd">                a self-intersecting shape (eg. remove_short_segments). If None,</span>
<span class="sd">                the output will include all Room2Ds resulting from the splitting</span>
<span class="sd">                of this shape through self-intersection. (Default: None).</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct from one another. (Default: 0.01; suitable</span>
<span class="sd">                for objects in Meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2D for the result of splitting this Room2D. Will be a</span>
<span class="sd">            list with only the current Room2D instance if the Room2D does not</span>
<span class="sd">            intersect itself</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first, check that the floor geometry intersects itself</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">is_self_intersecting</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="c1"># split the room&#39;s boundary polygon through its self intersection</span>
        <span class="n">rm_poly</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span>
        <span class="n">split_polys</span> <span class="o">=</span> <span class="n">rm_poly</span><span class="o">.</span><span class="n">split_through_self_intersection</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap_room</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">poly_1</span> <span class="o">=</span> <span class="n">overlap_room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span>
            <span class="n">ov_areas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">poly_2</span> <span class="ow">in</span> <span class="n">split_polys</span><span class="p">:</span>
                <span class="n">new_geos</span> <span class="o">=</span> <span class="n">poly_1</span><span class="o">.</span><span class="n">boolean_intersect</span><span class="p">(</span><span class="n">poly_2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_geos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ov_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># the Face3Ds did not overlap with one another</span>
                <span class="n">ov_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">new_geos</span><span class="p">))</span>
            <span class="n">sort_polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ov_areas</span><span class="p">,</span> <span class="n">split_polys</span><span class="p">),</span>
                                               <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">split_polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">sort_polys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1"># create Face3Ds from the split polygons</span>
        <span class="n">new_geos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">z_val</span><span class="p">,</span> <span class="n">flr_plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">split_polys</span><span class="p">:</span>
            <span class="n">face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">([</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_val</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">],</span> <span class="n">plane</span><span class="o">=</span><span class="n">flr_plane</span><span class="p">)</span>
            <span class="n">new_geos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
        <span class="c1"># create the final Room2Ds</span>
        <span class="n">new_rooms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_split_rooms</span><span class="p">(</span><span class="n">new_geos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_rooms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># preserve the original room identifier</span>
            <span class="n">new_rooms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span>
        <span class="k">return</span> <span class="n">new_rooms</span></div>


<div class="viewcode-block" id="Room2D.split_with_thick_line">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_thick_line">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_with_thick_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split this Room2D with a thickened LineSegment2D creating a gap.</span>

<span class="sd">        If the input line does not intersect this Room2D, a list with only the</span>
<span class="sd">        current room will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            line: A LineSegment2D object that will be used to split this Room2D.</span>
<span class="sd">            thickness: A number for the thickness to be applied to the line before</span>
<span class="sd">                it is used to split the Room2D. The input line will be offset half</span>
<span class="sd">                of this distance in both directions before it is used to split</span>
<span class="sd">                this Room2D.</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct from one another. (Default: 0.01; suitable</span>
<span class="sd">                for objects in Meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2D for the result of splitting this Room2D with the</span>
<span class="sd">            input line. Will be a list with only the current Room2D if the line</span>
<span class="sd">            does not split it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the line for the closest point calculation</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">LineSegment2D</span><span class="p">):</span>
            <span class="c1"># check if the coordinate values are too high to resolve with tolerance</span>
            <span class="n">t_up</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="o">*</span> <span class="mf">1e6</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">t_up</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">t_up</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">t_up</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">t_up</span><span class="p">:</span>
                <span class="n">min_pt</span><span class="p">,</span> <span class="n">max_pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span>
                <span class="n">base</span><span class="p">,</span> <span class="n">hgt</span> <span class="o">=</span> <span class="n">max_pt</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">min_pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max_pt</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">min_pt</span><span class="o">.</span><span class="n">y</span>
                <span class="n">bound_rect</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">from_rectangle</span><span class="p">(</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">Vector2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">base</span><span class="p">,</span> <span class="n">hgt</span><span class="p">)</span>
                <span class="n">inter_pts</span> <span class="o">=</span> <span class="n">bound_rect</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">inter_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inter_pts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">line_3d</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">),</span>
                                    <span class="n">Vector3D</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected LineSegment2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># split the Room2D with the line</span>
        <span class="n">new_geos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">split_with_thick_line</span><span class="p">(</span>
            <span class="n">line_3d</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_geos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>  <span class="c1"># the line did not overlap with the Room2D</span>
        <span class="c1"># create the final Room2Ds</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_split_rooms</span><span class="p">(</span><span class="n">new_geos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.split_with_thick_polyline">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.split_with_thick_polyline">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">split_with_thick_polyline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polyline</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split this Room2D with a thickened Polyline2D creating a gap.</span>

<span class="sd">        If the input polyline does not intersect this Room2D, a list with only</span>
<span class="sd">        the current room will be returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            polyline: A Polyline2D object that will be used to split this Room2D.</span>
<span class="sd">            thickness: A number for the thickness to be applied to the polyline before</span>
<span class="sd">                it is used to split the Room2D. The input polyline will be offset half</span>
<span class="sd">                of this distance in both directions before it is used to split</span>
<span class="sd">                this Room2D.</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct from one another. (Default: 0.01; suitable</span>
<span class="sd">                for objects in Meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2D for the result of splitting this Room2D with the</span>
<span class="sd">            input polyline. Will be a list with only the current Room2D if the</span>
<span class="sd">            polyline does not split it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a 3D version of the polyline for the closest point calculation</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polyline</span><span class="p">,</span> <span class="n">Polyline2D</span><span class="p">):</span>
            <span class="n">polyline_3d</span> <span class="o">=</span> <span class="n">Polyline3D</span><span class="p">(</span>
                <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">polyline</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Expected Polyline2D. Got </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">polyline</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># split the Room2D with the polyline</span>
        <span class="n">new_geos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">split_with_thick_polyline</span><span class="p">(</span>
            <span class="n">polyline_3d</span><span class="p">,</span> <span class="n">thickness</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_geos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>  <span class="c1"># the polyline did not overlap with the Room2D</span>
        <span class="c1"># create the final Room2Ds</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_split_rooms</span><span class="p">(</span><span class="n">new_geos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_create_split_rooms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face_3ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create Room2Ds from Face3Ds that were split from this Room2D.&quot;&quot;&quot;</span>
        <span class="c1"># create the Room2Ds</span>
        <span class="n">new_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">new_geo</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">face_3ds</span><span class="p">):</span>
            <span class="n">rm_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="n">rm_id</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span>
                <span class="n">is_top_exposed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_match_and_transfer_wall_props</span><span class="p">(</span><span class="n">rebuilt_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_floor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_ceiling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_data</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abridged_properties</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
            <span class="n">new_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rebuilt_room</span><span class="p">)</span>

        <span class="c1"># split the skylights if they exist</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">floor_geometry</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_rooms</span><span class="p">]</span>
            <span class="n">new_skys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">room_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">room</span><span class="p">,</span> <span class="n">sky_par</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_rooms</span><span class="p">,</span> <span class="n">new_skys</span><span class="p">):</span>
                <span class="n">room</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="n">sky_par</span>

        <span class="k">return</span> <span class="n">new_rooms</span>

<div class="viewcode-block" id="Room2D.separate_plenum">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.separate_plenum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">separate_plenum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_floor_to_ceiling</span><span class="p">,</span> <span class="n">floor_plenum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Separate a section of this Room2D into a ceiling (or floor) plenum.</span>

<span class="sd">        Note that this method is completely distinct from the Room2D properties</span>
<span class="sd">        for ceiling_plenum_depth and floor_plenum_depth and is intended for</span>
<span class="sd">        the case of working with plenums as explicit Room2Ds rather than as</span>
<span class="sd">        numerical properties of base Room2Ds.</span>

<span class="sd">        Args:</span>
<span class="sd">            target_floor_to_ceiling: A number in model units for the desired</span>
<span class="sd">                floor-to-ceiling height of the final room (assuming that this</span>
<span class="sd">                Room2D&#39;s current floor-to-ceiling height is actually the</span>
<span class="sd">                floor-to-floor height). If the current Room2D&#39;s floor-to-ceiling</span>
<span class="sd">                height is less than the input value, the floor-to-ceiling height</span>
<span class="sd">                of this Room2D will be reduced and a new ceiling or floor plenum</span>
<span class="sd">                Rooms2D will be returned from this method.</span>
<span class="sd">            floor_plenum: A boolean to note whether the plenum to be separated is</span>
<span class="sd">                a floor plenum for this current Room2D (in which case it is</span>
<span class="sd">                subtracted from the bottom) or it is a ceiling plenum (in which</span>
<span class="sd">                case it is subtracted from the top). (Default: False).</span>
<span class="sd">            tolerance: The maximum difference between point values for them to be</span>
<span class="sd">                considered distinct from one another. (Default: 0.01; suitable</span>
<span class="sd">                for objects in Meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A new Room2D for the plenum. Will be None if the target_floor_to_ceiling</span>
<span class="sd">            is greater than the current Room2D&#39;s floor_to_ceiling_height.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first make sure that the target_floor_to_ceiling is acceptable</span>
        <span class="k">if</span> <span class="n">target_floor_to_ceiling</span> <span class="o">+</span> <span class="n">tolerance</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># determine the boundary conditions for the new plenum</span>
        <span class="n">pln_typ</span> <span class="o">=</span> <span class="s1">&#39;Floor&#39;</span> <span class="k">if</span> <span class="n">floor_plenum</span> <span class="k">else</span> <span class="s1">&#39;Ceiling&#39;</span>
        <span class="n">new_bcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_conditions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">adj_rm</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">adj_face_i</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;..Face&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">adj_pln_rm</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_Plenum&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">adj_rm</span><span class="p">,</span> <span class="n">pln_typ</span><span class="p">)</span>
                <span class="n">adj_pln_face</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">..Face</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">adj_pln_rm</span><span class="p">,</span> <span class="n">adj_face_i</span><span class="p">)</span>
                <span class="n">new_bc_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">adj_pln_face</span><span class="p">,</span> <span class="n">adj_pln_rm</span><span class="p">]</span>
                <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Surface</span><span class="p">(</span><span class="n">new_bc_objs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
        <span class="c1"># split off the floor or ceiling plenum Room2D</span>
        <span class="n">plenum_ftc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">target_floor_to_ceiling</span>
        <span class="k">if</span> <span class="n">floor_plenum</span><span class="p">:</span>  <span class="c1"># split off a floor plenum</span>
            <span class="n">plenum_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_Plenum&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">pln_typ</span><span class="p">)</span>
            <span class="n">new_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="n">plenum_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">plenum_ftc</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">new_bcs</span><span class="p">,</span>
                <span class="n">shading_parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shading_parameters</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">exist_w_par</span><span class="p">,</span> <span class="n">new_w_par</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c1"># shift all of the window parameters</span>
            <span class="k">for</span> <span class="n">wp</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                    <span class="n">ewp</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">shift_vertically</span><span class="p">(</span><span class="o">-</span><span class="n">plenum_ftc</span><span class="p">)</span>
                    <span class="n">ewp</span><span class="o">.</span><span class="n">adjust_for_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">target_floor_to_ceiling</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">wp</span><span class="o">.</span><span class="n">adjust_for_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">plenum_ftc</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ewp</span> <span class="o">=</span> <span class="n">wp</span> <span class="k">if</span> <span class="n">wp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">wp</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                <span class="n">exist_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ewp</span><span class="p">)</span>
                <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">exist_w_par</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">new_w_par</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">move</span><span class="p">(</span>
                <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">plenum_ftc</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># split off a ceiling plenum</span>
            <span class="n">plenum_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">_Plenum&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">pln_typ</span><span class="p">)</span>
            <span class="n">plenum_geo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">move</span><span class="p">(</span>
                <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">target_floor_to_ceiling</span><span class="p">))</span>
            <span class="n">new_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="n">plenum_id</span><span class="p">,</span> <span class="n">plenum_geo</span><span class="p">,</span> <span class="n">plenum_ftc</span><span class="p">,</span> <span class="n">boundary_conditions</span><span class="o">=</span><span class="n">new_bcs</span><span class="p">,</span>
                <span class="n">shading_parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shading_parameters</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_top_exposed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>
            <span class="n">exist_w_par</span><span class="p">,</span> <span class="n">new_w_par</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>  <span class="c1"># shift all of the window parameters</span>
            <span class="k">for</span> <span class="n">wp</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                    <span class="n">nwp</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">shift_vertically</span><span class="p">(</span><span class="o">-</span><span class="n">target_floor_to_ceiling</span><span class="p">)</span>
                    <span class="n">nwp</span><span class="o">.</span><span class="n">adjust_for_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">plenum_ftc</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">wp</span><span class="o">.</span><span class="n">adjust_for_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">target_floor_to_ceiling</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nwp</span> <span class="o">=</span> <span class="n">wp</span> <span class="k">if</span> <span class="n">wp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">wp</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                <span class="n">exist_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nwp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">exist_w_par</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">new_w_par</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># adjust the height of the current Room</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">=</span> <span class="n">target_floor_to_ceiling</span>
        <span class="c1"># assign all of the other attributes to the new room</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> Plenum&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span><span class="p">,</span> <span class="n">pln_typ</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1"> Plenum&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_zone</span><span class="p">,</span> <span class="n">pln_typ</span><span class="p">)</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">[:]</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abridged_properties</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_room</span></div>


<div class="viewcode-block" id="Room2D.check_horizontal">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_horizontal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_horizontal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the Room2D&#39;s floor geometry is horizontal within a tolerance.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The maximum difference between z values at which</span>
<span class="sd">                face vertices are considered at different heights. Default: 0.01,</span>
<span class="sd">                suitable for objects in meters.</span>
<span class="sd">            raise_exception: Boolean to note whether a ValueError should be raised</span>
<span class="sd">                if the room floor geometry is not horizontal.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">z_vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">z_vals</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">z_vals</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Room &quot;</span><span class="si">{}</span><span class="s1">&quot; is not horizontal to within </span><span class="si">{}</span><span class="s1"> tolerance.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">msg</span></div>


<div class="viewcode-block" id="Room2D.check_degenerate">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_degenerate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_degenerate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detailed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the Room2D&#39;s floor geometry is degenerate with zero area.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                vertices at which they can be considered equivalent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">            raise_exception: If True, a ValueError will be raised if the object</span>
<span class="sd">                intersects with itself. (Default: True).</span>
<span class="sd">            detailed: Boolean for whether the returned object is a detailed list of</span>
<span class="sd">                dicts with error info or a string with a message. (Default: False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A string with the message or a list with a dictionary if detailed is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">degenerate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>  <span class="c1"># degenerate geometry found!</span>
            <span class="n">degenerate</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">degenerate</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; has degenerate floor geometry with zero &#39;</span> \
                <span class="s1">&#39;area.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">full_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validation_message_child</span><span class="p">(</span>
                <span class="n">msg</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">detailed</span><span class="p">,</span> <span class="s1">&#39;100101&#39;</span><span class="p">,</span>
                <span class="n">error_type</span><span class="o">=</span><span class="s1">&#39;Degenerate Room Geometry&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">detailed</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">full_msg</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">full_msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">full_msg</span>
        <span class="k">return</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">detailed</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span></div>


<div class="viewcode-block" id="Room2D.check_self_intersecting">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_self_intersecting">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_self_intersecting</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">detailed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the Room2D&#39;s floor geometry intersects itself (like a bowtie).</span>

<span class="sd">        Note that objects that have duplicate vertices will not be considered</span>
<span class="sd">        self-intersecting and are valid.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                vertices at which they can be considered equivalent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">            raise_exception: If True, a ValueError will be raised if the object</span>
<span class="sd">                intersects with itself. (Default: True).</span>
<span class="sd">            detailed: Boolean for whether the returned object is a detailed list of</span>
<span class="sd">                dicts with error info or a string with a message. (Default: False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A string with the message or a list with a dictionary if detailed is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">is_self_intersecting</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; has floor geometry with self-intersecting &#39;</span> \
                <span class="s1">&#39;edges.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># see if it is self-intersecting because of a duplicate vertex</span>
                <span class="n">new_geo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">remove_duplicate_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_geo</span><span class="o">.</span><span class="n">is_self_intersecting</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">detailed</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># valid with removed dup vertex</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># zero area face; treat it as self-intersecting</span>
            <span class="n">full_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validation_message_child</span><span class="p">(</span>
                <span class="n">msg</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">detailed</span><span class="p">,</span> <span class="s1">&#39;100102&#39;</span><span class="p">,</span>
                <span class="n">error_type</span><span class="o">=</span><span class="s1">&#39;Self-Intersecting Room Geometry&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">detailed</span><span class="p">:</span>
                <span class="n">full_msg</span><span class="p">[</span><span class="s1">&#39;helper_geometry&#39;</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">self_intersection_points</span><span class="p">]</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">full_msg</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">full_msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">full_msg</span>
        <span class="k">return</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">detailed</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span></div>


<div class="viewcode-block" id="Room2D.check_plenum_depths">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_plenum_depths">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_plenum_depths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detailed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check plenum depths do not exceed floor-to-ceiling or contradict has_floor.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                vertices at which they can be considered equivalent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">            raise_exception: If True, a ValueError will be raised if invalid plenum</span>
<span class="sd">                depths are discovered. (Default: True).</span>
<span class="sd">            detailed: Boolean for whether the returned object is a detailed list of</span>
<span class="sd">                dicts with error info or a string with a message. (Default: False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A string with the message or a list with a dictionary if detailed is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">detailed</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">raise_exception</span> <span class="k">else</span> <span class="n">detailed</span>
        <span class="n">ftc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span>
        <span class="n">cpd</span><span class="p">,</span> <span class="n">fpd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_plenum_depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_plenum_depth</span>
        <span class="n">msgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">cpd</span> <span class="o">+</span> <span class="n">fpd</span> <span class="o">&gt;=</span> <span class="n">ftc</span> <span class="o">-</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Combined plenum depths (</span><span class="si">{}</span><span class="s1">) exceed the room floor-to-ceiling &#39;</span>\
                <span class="s1">&#39;height (</span><span class="si">{}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cpd</span> <span class="o">+</span> <span class="n">fpd</span><span class="p">,</span> <span class="n">ftc</span><span class="p">)</span>
            <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_ceiling</span> <span class="ow">and</span> <span class="n">cpd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Room has a ceiling plenum depth assigned (</span><span class="si">{}</span><span class="s1">) but also &#39;</span> \
                <span class="s1">&#39;does not have a ceiling.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cpd</span><span class="p">)</span>
            <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_floor</span> <span class="ow">and</span> <span class="n">fpd</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Room has a floor plenum depth assigned (</span><span class="si">{}</span><span class="s1">) but also &#39;</span> \
                <span class="s1">&#39;does not have a floor.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fpd</span><span class="p">)</span>
            <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">msgs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">detailed</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">full_msg</span> <span class="o">=</span> <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; contains invalid plenum depths.&#39;</span> \
            <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msgs</span><span class="p">))</span>
        <span class="n">full_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validation_message_child</span><span class="p">(</span>
            <span class="n">full_msg</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">detailed</span><span class="p">,</span> <span class="s1">&#39;100107&#39;</span><span class="p">,</span> <span class="n">error_type</span><span class="o">=</span><span class="s1">&#39;Invalid Room Plenum Depths&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">detailed</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">full_msg</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">full_msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">full_msg</span></div>


<div class="viewcode-block" id="Room2D.check_window_parameters_valid">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.check_window_parameters_valid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_window_parameters_valid</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">detailed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the window and skylight parameters produce valid apertures.</span>

<span class="sd">        This means that this Room&#39;s windows do not overlap with one another and,</span>
<span class="sd">        in the case of detailed windows, the polygons do not self-intersect. It</span>
<span class="sd">        also means that skylights do not extend past the boundary of the room.</span>

<span class="sd">        Args:</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                vertices at which they can be considered equivalent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">            raise_exception: Boolean to note whether a ValueError should be raised</span>
<span class="sd">                if the window parameters are not valid.</span>
<span class="sd">            detailed: Boolean for whether the returned object is a detailed list of</span>
<span class="sd">                dicts with error info or a string with a message. (Default: False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A string with the message or a list with a dictionary if detailed is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">detailed</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">raise_exception</span> <span class="k">else</span> <span class="n">detailed</span>
        <span class="n">msgs</span><span class="p">,</span> <span class="n">help_geo</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">checkable_par</span> <span class="o">=</span> <span class="p">(</span><span class="n">RectangularWindows</span><span class="p">,</span> <span class="n">DetailedWindows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">seg</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">wp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">checkable_par</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">check_window_overlaps</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">msg</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; Segment (</span><span class="si">{}</span><span class="s1">) - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">msg</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">DetailedWindows</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">msg</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                        <span class="n">help_geo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">overlapping_geometries</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">check_self_intersecting</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">msg</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                        <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; Segment (</span><span class="si">{}</span><span class="s1">) - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">msg</span><span class="p">))</span>
                        <span class="n">help_geo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">wp</span><span class="o">.</span><span class="n">self_intersecting_geometries</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">):</span>
            <span class="n">sky_help_geo</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span>
            <span class="n">m_vec</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
            <span class="n">roof_face</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">m_vec</span><span class="p">)</span>
            <span class="n">msg1</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">check_valid_for_face</span><span class="p">(</span><span class="n">roof_face</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">msg1</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; Skylights - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg1</span><span class="p">))</span>
                <span class="n">sky_help_geo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">invalid_face_geometries</span><span class="p">(</span><span class="n">roof_face</span><span class="p">))</span>
            <span class="n">msg2</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">check_overlaps</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">msg2</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; Skylights - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg2</span><span class="p">))</span>
                <span class="n">sky_help_geo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">overlapping_geometries</span><span class="p">(</span><span class="n">roof_face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span>
            <span class="n">msg3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">check_self_intersecting</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">msg3</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">msgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; Skylights - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg3</span><span class="p">))</span>
                <span class="n">sky_help_geo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">self_intersecting_geometries</span><span class="p">(</span><span class="n">roof_face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sky_help_geo</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_parent</span> <span class="ow">and</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">roof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># translate the model to 3D so that we get accurate helper geometry</span>
                <span class="n">hb_room</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_honeybee</span><span class="p">(</span><span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">enforce_bc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                              <span class="n">enforce_solid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">skylights</span><span class="p">,</span> <span class="n">sky_polys</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">hb_room</span><span class="o">.</span><span class="n">faces</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">RoofCeiling</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">face</span><span class="o">.</span><span class="n">apertures</span><span class="p">:</span>
                            <span class="n">skylights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ap</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
                            <span class="n">pts_2</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ap</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">]</span>
                            <span class="n">sky_polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon2D</span><span class="p">(</span><span class="n">pts_2</span><span class="p">))</span>
                <span class="n">new_sky_help_geo</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">h_geo</span> <span class="ow">in</span> <span class="n">sky_help_geo</span><span class="p">:</span>
                    <span class="n">h_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">h_geo</span><span class="o">.</span><span class="n">boundary</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">skylight</span><span class="p">,</span> <span class="n">s_poly</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">skylights</span><span class="p">,</span> <span class="n">sky_polys</span><span class="p">):</span>
                        <span class="n">poly_rel</span> <span class="o">=</span> <span class="n">h_poly</span><span class="o">.</span><span class="n">polygon_relationship</span><span class="p">(</span><span class="n">s_poly</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">poly_rel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">new_sky_help_geo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">skylight</span><span class="p">)</span>
                <span class="n">sky_help_geo</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_sky_help_geo</span><span class="p">))</span>
            <span class="n">help_geo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sky_help_geo</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">msgs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">detailed</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
        <span class="n">full_msg</span> <span class="o">=</span> <span class="s1">&#39;Room2D &quot;</span><span class="si">{}</span><span class="s1">&quot; contains invalid window parameters.&#39;</span> \
            <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msgs</span><span class="p">))</span>
        <span class="n">full_msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validation_message_child</span><span class="p">(</span>
            <span class="n">full_msg</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">detailed</span><span class="p">,</span> <span class="s1">&#39;100103&#39;</span><span class="p">,</span> <span class="n">error_type</span><span class="o">=</span><span class="s1">&#39;Invalid Window Parameters&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">detailed</span><span class="p">:</span>
            <span class="n">full_msg</span><span class="p">[</span><span class="s1">&#39;helper_geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">help_geo</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">full_msg</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">full_msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">full_msg</span></div>


<div class="viewcode-block" id="Room2D.to_core_perimeter">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_core_perimeter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_core_perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">perimeter_offset</span><span class="p">,</span> <span class="n">air_boundary</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translate this Room2D into a list of Room2Ds separated by core and perimeter.</span>

<span class="sd">        All of the resulting Room2Ds will have the same properties as this initial</span>
<span class="sd">        Room2D with all windows and boundary conditions conserved. All of the</span>
<span class="sd">        newly-created interior walls between the core and perimeter Room2Ds will</span>
<span class="sd">        have Surface boundary conditions.</span>

<span class="sd">        Args:</span>
<span class="sd">            perimeter_offset: An optional positive number that will be used to offset</span>
<span class="sd">                the perimeter of the all_story_geometry to create core/perimeter</span>
<span class="sd">                zones. If this value is 0, no offset will occur and each story</span>
<span class="sd">                will be represented with a single Room2D per polygon.</span>
<span class="sd">            air_boundary: A boolean to note whether all of the new wall adjacencies</span>
<span class="sd">                should be set to an AirBoundary type. (Default: False).</span>
<span class="sd">            tolerance: The maximum difference between x, y, and z values at which</span>
<span class="sd">                point vertices are considered to be the same. This is also needed as</span>
<span class="sd">                a means to determine which floor geometries are equivalent to one</span>
<span class="sd">                another and should be a part the same Story. Default: 0.01, suitable</span>
<span class="sd">                for objects in meters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2D for core Room2Ds followed by perimeter Room2Ds. If the</span>
<span class="sd">            current Room2D cannot be converted into core and perimeter Room2Ds,</span>
<span class="sd">            a list with the current Room2D instance will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create the floor Face3Ds from this Room2D&#39;s floor_geometry</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">perimeter</span><span class="p">,</span> <span class="n">core</span> <span class="o">=</span> <span class="n">perimeter_core_subfaces</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="p">,</span> <span class="n">perimeter_offset</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">new_face3d_array</span> <span class="o">=</span> <span class="n">perimeter</span> <span class="o">+</span> <span class="n">core</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># the generation of the polyskel failed; possibly neg offset</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>  <span class="c1"># just use existing floor</span>

        <span class="c1"># create the new Room2D objects from the result</span>
        <span class="n">parent_zip</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_conditions</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">window_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shading_parameters</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span>
        <span class="p">)</span>
        <span class="n">new_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">floor_geo</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_face3d_array</span><span class="p">):</span>
            <span class="c1"># determine the segments of the new Room2D</span>
            <span class="k">if</span> <span class="n">floor_geo</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">z</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># ensure upward-facing Face3D</span>
                <span class="n">floor_geo</span> <span class="o">=</span> <span class="n">floor_geo</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
            <span class="n">o_p</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Point3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">floor_geo</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
            <span class="n">floor_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">floor_geo</span><span class="o">.</span><span class="n">boundary</span><span class="p">,</span> <span class="n">o_p</span><span class="p">,</span> <span class="n">floor_geo</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span>
            <span class="n">new_room_seg</span> <span class="o">=</span> <span class="n">floor_geo</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">segments</span> \
                <span class="k">if</span> <span class="ow">not</span> <span class="n">floor_geo</span><span class="o">.</span><span class="n">has_holes</span> \
                <span class="k">else</span> <span class="n">floor_geo</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">segments</span> <span class="o">+</span> \
                <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">floor_geo</span><span class="o">.</span><span class="n">hole_polygon2d</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>
            <span class="c1"># match the new segments to the existing properties</span>
            <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">new_seg</span> <span class="ow">in</span> <span class="n">new_room_seg</span><span class="p">:</span>
                <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">new_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">new_seg</span><span class="o">.</span><span class="n">p2</span>
                <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">wp</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">ab</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">parent_zip</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span> <span class="ow">and</span> \
                            <span class="n">seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>
                        <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
                        <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                        <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
                        <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
                    <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">new_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">new_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="n">new_id</span><span class="p">,</span> <span class="n">floor_geo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span>
                <span class="n">new_shd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">_has_floor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">_has_ceiling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">display_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">display_name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
            <span class="n">new_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_room</span><span class="p">)</span>

        <span class="c1"># re-assign skylights if they exist</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">room_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">floor_geometry</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_rooms</span><span class="p">]</span>
            <span class="n">new_skys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">room_faces</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">room</span><span class="p">,</span> <span class="n">sky_par</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_rooms</span><span class="p">,</span> <span class="n">new_skys</span><span class="p">):</span>
                <span class="n">room</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="n">sky_par</span>

        <span class="c1"># solve adjacency between the Room2Ds</span>
        <span class="n">new_rooms</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">intersect_adjacency</span><span class="p">(</span><span class="n">new_rooms</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">adj_info</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">solve_adjacency</span><span class="p">(</span><span class="n">new_rooms</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">air_boundary</span><span class="p">:</span>  <span class="c1"># set air boundary type if requested</span>
            <span class="k">for</span> <span class="n">room_pair</span> <span class="ow">in</span> <span class="n">adj_info</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">room_adj</span> <span class="ow">in</span> <span class="n">room_pair</span><span class="p">:</span>
                    <span class="n">room</span><span class="p">,</span> <span class="n">wall_i</span> <span class="o">=</span> <span class="n">room_adj</span>
                    <span class="n">room</span><span class="o">.</span><span class="n">set_air_boundary</span><span class="p">(</span><span class="n">wall_i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_rooms</span></div>


<div class="viewcode-block" id="Room2D.to_honeybee">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_honeybee">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_honeybee</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">enforce_bc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">enforce_solid</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert Dragonfly Room2D to a Honeybee Room.</span>

<span class="sd">        Args:</span>
<span class="sd">            multiplier: An integer greater than 0 that denotes the number of times</span>
<span class="sd">                the room is repeated. You may want to set this differently depending</span>
<span class="sd">                on whether you are exporting each room as its own geometry (in which</span>
<span class="sd">                case, this should be 1) or you only want to simulate the &quot;unique&quot; room</span>
<span class="sd">                once and have the results multiplied. (Default: 1).</span>
<span class="sd">            tolerance: The minimum distance in z values of floor_height and</span>
<span class="sd">                floor_to_ceiling_height at which adjacent Faces will be split.</span>
<span class="sd">                This is also used in the generation of Windows, and to check if the</span>
<span class="sd">                Room ceiling is adjacent to the upper floor of the Story before</span>
<span class="sd">                generating a plenum. Default: 0.01, suitable for objects in meters.</span>
<span class="sd">            enforce_bc: Boolean to note whether an exception should be raised if</span>
<span class="sd">                apertures are assigned to Wall with an illegal boundary conditions</span>
<span class="sd">                (True) or if the invalid boundary condition should be replaced</span>
<span class="sd">                with an Outdoor boundary condition (False). (Default: True).</span>
<span class="sd">            enforce_solid: Boolean to note whether the room should be translated</span>
<span class="sd">                as a solid extrusion whenever translating the room with custom</span>
<span class="sd">                roof geometry produces a non-solid result (True) or the non-solid</span>
<span class="sd">                room geometry should be allowed to remain in the result (False).</span>
<span class="sd">                The latter is useful for understanding why a particular roof</span>
<span class="sd">                geometry has produced a non-solid result. (Default: True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with the two items below.</span>

<span class="sd">            * hb_room -- A honeybee-core Room representing the dragonfly Room2D.</span>

<span class="sd">            * adjacencies -- A list of tuples that record any adjacencies that</span>
<span class="sd">                should be set on the level of the Story to which the Room2D belongs.</span>
<span class="sd">                Each tuple will have a honeybee Face as the first item and a</span>
<span class="sd">                tuple of Surface.boundary_condition_objects as the second item.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create the honeybee Room</span>
        <span class="n">has_roof</span><span class="p">,</span> <span class="n">ex_wall_i</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get a roof specification for the room</span>
            <span class="n">roof_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_room_roofs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="c1"># generate the room volume from the slanted roof</span>
            <span class="k">if</span> <span class="n">roof_spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># remove duplicate vertices as they are absent from volume with roof</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">remove_duplicate_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># degenerate room; just let it pass</span>
                    <span class="k">pass</span>
                <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">ex_wall_i</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_room_volume_with_roof</span><span class="p">(</span><span class="n">roof_spec</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">room_polyface</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># complete failure to interpret roof</span>
                    <span class="n">has_roof</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">elif</span> <span class="n">enforce_solid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>
                    <span class="n">has_roof</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">has_roof</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">has_roof</span><span class="p">:</span>  <span class="c1"># generate the Room volume normally through extrusion</span>
            <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_offset_face</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
            <span class="n">roof_face_i</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># create the honeybee Room and set the RoofCeiling faces</span>
        <span class="n">hb_room</span> <span class="o">=</span> <span class="n">Room</span><span class="o">.</span><span class="n">from_polyface3d</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">ground_depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">roof_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">roof_face_i</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rfc</span> <span class="o">=</span> <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">rfc</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ftyp</span><span class="o">.</span><span class="n">roof_ceiling</span>
                <span class="n">roof_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rfc</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># something happened to mess up roof faces</span>

        <span class="c1"># if not all walls are present, reset IDs so that adjacencies work</span>
        <span class="k">if</span> <span class="n">ex_wall_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">ex_wall_i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">skipped</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">face</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hb_room</span><span class="o">.</span><span class="n">faces</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skipped</span> <span class="ow">in</span> <span class="n">ex_wall_i</span><span class="p">:</span>
                    <span class="n">skipped</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">face</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">..Face</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">skipped</span><span class="p">)</span>

        <span class="c1"># assign BCs and record any Surface conditions to be set on the story level</span>
        <span class="n">adjacencies</span><span class="p">,</span> <span class="n">skip</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ex_wall_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ex_wall_i</span><span class="p">:</span>
                <span class="n">skip</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="n">hb_face</span> <span class="o">=</span> <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">skip</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">hb_face</span><span class="o">.</span><span class="n">_boundary_condition</span> <span class="o">=</span> <span class="n">bc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">adjacencies</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">hb_face</span><span class="p">,</span> <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">))</span>

        <span class="c1"># determine if the floor has a counterclockwise hole, requiring window flipping</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">win_flip</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">win_flip</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">hole_poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">hole_polygon2d</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hole_poly</span><span class="o">.</span><span class="n">is_clockwise</span><span class="p">:</span>
                    <span class="n">win_flip</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole_poly</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole_poly</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                        <span class="n">win_flip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="c1"># assign windows, shading, and air boundary properties to walls</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">glz_par</span><span class="p">,</span> <span class="n">w_flip</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span> <span class="n">win_flip</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">ex_wall_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ex_wall_i</span><span class="p">:</span>
                <span class="n">skip</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">glz_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hb_face</span> <span class="o">=</span> <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">skip</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">glz_par</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">)</span> <span class="ow">and</span> <span class="n">w_flip</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">glz_par</span> <span class="o">=</span> <span class="n">glz_par</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">w_flip</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">glz_par</span><span class="o">.</span><span class="n">add_window_to_face</span><span class="p">(</span><span class="n">hb_face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">enforce_bc</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">e</span>
                    <span class="n">hb_face</span><span class="o">.</span><span class="n">_boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
                    <span class="n">hb_face</span><span class="o">.</span><span class="n">remove_sub_faces</span><span class="p">()</span>
                    <span class="n">glz_par</span><span class="o">.</span><span class="n">add_window_to_face</span><span class="p">(</span><span class="n">hb_face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">has_roof</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">glz_par</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                    <span class="n">valid_sf</span><span class="p">,</span> <span class="n">trim_sf</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">hb_face</span><span class="o">.</span><span class="n">sub_faces</span><span class="p">:</span>
                        <span class="n">p_geo</span><span class="p">,</span> <span class="n">sf_geo</span> <span class="o">=</span> <span class="n">hb_face</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">sf</span><span class="o">.</span><span class="n">geometry</span>
                        <span class="n">verts2d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p_geo</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">xyz_to_xy</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sf_geo</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                        <span class="n">sub_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span><span class="n">verts2d</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">p_geo</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">is_polygon_inside</span><span class="p">(</span><span class="n">sub_poly</span><span class="p">):</span>
                            <span class="n">valid_sf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="ow">not</span> <span class="n">p_geo</span><span class="o">.</span><span class="n">polygon2d</span><span class="o">.</span><span class="n">is_polygon_outside</span><span class="p">(</span><span class="n">sub_poly</span><span class="p">):</span>
                            <span class="n">trim_sf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hb_face</span><span class="o">.</span><span class="n">sub_faces</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_sf</span><span class="p">):</span>
                        <span class="n">hb_face</span><span class="o">.</span><span class="n">remove_sub_faces</span><span class="p">()</span>
                        <span class="n">hb_face</span><span class="o">.</span><span class="n">add_sub_faces</span><span class="p">(</span><span class="n">valid_sf</span> <span class="o">+</span> <span class="n">trim_sf</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trim_sf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">hb_face</span><span class="o">.</span><span class="n">fix_invalid_sub_faces</span><span class="p">(</span>
                                <span class="n">trim_with_parent</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">union_overlaps</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="n">offset_distance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
                            <span class="p">)</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">shd_par</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ex_wall_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ex_wall_i</span><span class="p">:</span>
                <span class="n">skip</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">shd_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">shd_par</span><span class="o">.</span><span class="n">add_shading_to_face</span><span class="p">(</span><span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">skip</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a_bnd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">ex_wall_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ex_wall_i</span><span class="p">:</span>
                    <span class="n">skip</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">a_bnd</span><span class="p">:</span>
                    <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">skip</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">ftyp</span><span class="o">.</span><span class="n">air_boundary</span>

        <span class="c1"># ensure matching adjacent Faces across the Story</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_roof</span><span class="p">:</span>
            <span class="n">new_faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_walls_along_height</span><span class="p">(</span><span class="n">hb_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_faces</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hb_room</span><span class="p">):</span>
                <span class="c1"># rebuild the room with split surfaces</span>
                <span class="n">hb_room</span> <span class="o">=</span> <span class="n">Room</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
                <span class="c1"># update adjacencies with the new split face</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">adj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">adjacencies</span><span class="p">):</span>
                    <span class="n">face_id</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">identifier</span>
                    <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">hb_room</span><span class="o">.</span><span class="n">faces</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">face</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="n">face_id</span><span class="p">:</span>
                            <span class="n">adjacencies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">adj</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">break</span>

        <span class="c1"># assign boundary conditions for the roof and floor</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
            <span class="k">for</span> <span class="n">rf</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">:</span>
                <span class="n">rf</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
            <span class="k">pass</span>  <span class="c1"># honeybee_energy is not loaded and Adiabatic type doesn&#39;t exist</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span><span class="p">:</span>
            <span class="n">hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">rf</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">:</span>
                <span class="n">rf</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
            <span class="c1"># set the skylights if top is exposed</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">rf</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">add_skylight_to_face</span><span class="p">(</span><span class="n">rf</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># set the story, multiplier, display_name, and user_data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_parent</span><span class="p">:</span>
            <span class="n">hb_room</span><span class="o">.</span><span class="n">story</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">display_name</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">is_plenum</span><span class="p">:</span>
                <span class="n">hb_room</span><span class="o">.</span><span class="n">exclude_floor_area</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">hb_room</span><span class="o">.</span><span class="n">multiplier</span> <span class="o">=</span> <span class="n">multiplier</span>
        <span class="n">hb_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span>
        <span class="n">hb_room</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span>
        <span class="n">hb_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_data</span>

        <span class="c1"># transfer any extension properties assigned to the Room2D and return result</span>
        <span class="n">hb_room</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">to_honeybee</span><span class="p">(</span><span class="n">hb_room</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hb_room</span><span class="p">,</span> <span class="n">adjacencies</span></div>


<div class="viewcode-block" id="Room2D.to_dict">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.to_dict">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abridged</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">included_prop</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Room2D as a dictionary.</span>

<span class="sd">        Args:</span>
<span class="sd">            abridged: Boolean to note whether the extension properties of the</span>
<span class="sd">                object (ie. program_type, construction_set) should be included in detail</span>
<span class="sd">                (False) or just referenced by identifier (True). Default: False.</span>
<span class="sd">            included_prop: List of properties to filter keys that must be included in</span>
<span class="sd">                output dictionary. For example [&#39;energy&#39;] will include &#39;energy&#39; key if</span>
<span class="sd">                available in properties to_dict. By default all the keys will be</span>
<span class="sd">                included. To exclude all the keys from extensions use an empty list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Room2D&#39;</span><span class="p">}</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;identifier&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;display_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;zone&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zone</span>
        <span class="k">if</span> <span class="n">abridged</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abridged_properties</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">abridged</span><span class="p">,</span> <span class="n">included_prop</span><span class="p">)</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;floor_boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;floor_holes&#39;</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">[[(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">]</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;floor_height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;floor_to_ceiling_height&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_to_ceiling_height</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;is_ground_contact&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;is_top_exposed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;has_floor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;has_ceiling&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_plenum_depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;ceiling_plenum_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_plenum_depth</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_plenum_depth</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;floor_plenum_depth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_plenum_depth</span>

        <span class="n">bc_dicts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Outdoors</span><span class="p">)</span> <span class="ow">and</span> <span class="s1">&#39;energy&#39;</span> <span class="ow">in</span> <span class="n">base</span><span class="p">[</span><span class="s1">&#39;properties&#39;</span><span class="p">]:</span>
                <span class="n">bc_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bc_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">to_dict</span><span class="p">())</span>
        <span class="n">base</span><span class="p">[</span><span class="s1">&#39;boundary_conditions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bc_dicts</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">)):</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;window_parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">glz</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">glz</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">glz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">base</span><span class="p">[</span><span class="s1">&#39;window_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="n">param</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">)):</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;shading_parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">shd</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">shd</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="k">if</span> <span class="n">shd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">base</span><span class="p">[</span><span class="s1">&#39;shading_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">((</span><span class="ow">not</span> <span class="n">param</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">)):</span>
                <span class="n">base</span><span class="p">[</span><span class="s1">&#39;air_boundaries&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;skylight_parameters&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">skylight_parameters</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span><span class="p">[</span><span class="s1">&#39;user_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span>

        <span class="k">return</span> <span class="n">base</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Room2D writer object.</span>

<span class="sd">        Use this method to access Writer class to write the room2d in other formats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">writer</span>

<div class="viewcode-block" id="Room2D.find_adjacency_gaps">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.find_adjacency_gaps">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_adjacency_gaps</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">gap_distance</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identify gaps between a list of Room2Ds that are smaller than a gap_distance.</span>

<span class="sd">        This is useful for identifying cases where gaps can result in failed</span>
<span class="sd">        intersections between Room2Ds of adjacent stories or failed adjacency</span>
<span class="sd">        solving within each story.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which adjacency gaps will be identified.</span>
<span class="sd">            gap_distance: The maximum distance between two Room2Ds that is considered</span>
<span class="sd">                an adjacency gap. Differences between Room2Ds that are higher than</span>
<span class="sd">                this distance are considered meaningful gaps to be preserved.</span>
<span class="sd">                This value should be higher than the tolerance to be</span>
<span class="sd">                meaningful. (Default: 0.1, suitable for objects in meters).</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values at</span>
<span class="sd">                which point they are considered equivalent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Point2Ds that note the location of any gaps between the input</span>
<span class="sd">            room_2ds, which are larger than the tolerance but less than the</span>
<span class="sd">            gap_distance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gap_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">room_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">room_2</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">poly_1</span> <span class="o">=</span> <span class="n">room_1</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span>
                    <span class="n">poly_2</span> <span class="o">=</span> <span class="n">room_2</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">overlapping_bounding_rect</span><span class="p">(</span>
                            <span class="n">poly_1</span><span class="p">,</span> <span class="n">poly_2</span><span class="p">,</span> <span class="n">gap_distance</span><span class="p">):</span>
                        <span class="k">continue</span>  <span class="c1"># no overlap in bounding rect; gap impossible</span>
                    <span class="c1"># check the first polygon against the second</span>
                    <span class="k">for</span> <span class="n">pt_1</span> <span class="ow">in</span> <span class="n">poly_1</span><span class="p">:</span>
                        <span class="n">pt_dist</span> <span class="o">=</span> <span class="n">poly_2</span><span class="o">.</span><span class="n">distance_from_edge_to_point</span><span class="p">(</span><span class="n">pt_1</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">tolerance</span> <span class="o">&lt;</span> <span class="n">pt_dist</span> <span class="o">&lt;=</span> <span class="n">gap_distance</span><span class="p">:</span>
                            <span class="n">gap_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_1</span><span class="p">)</span>
                    <span class="c1"># check the second polygon against the first</span>
                    <span class="k">for</span> <span class="n">pt_2</span> <span class="ow">in</span> <span class="n">poly_2</span><span class="p">:</span>
                        <span class="n">pt_dist</span> <span class="o">=</span> <span class="n">poly_1</span><span class="o">.</span><span class="n">distance_from_edge_to_point</span><span class="p">(</span><span class="n">pt_2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">tolerance</span> <span class="o">&lt;</span> <span class="n">pt_dist</span> <span class="o">&lt;=</span> <span class="n">gap_distance</span><span class="p">:</span>
                            <span class="n">gap_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_2</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># we have reached the end of the list of rooms</span>
        <span class="k">return</span> <span class="n">gap_points</span></div>


<div class="viewcode-block" id="Room2D.solve_adjacency">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.solve_adjacency">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve_adjacency</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">resolve_window_conflicts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Solve for all adjacencies between a list of input Room2Ds.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which adjacencies will be solved.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered adjacent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">            resolve_window_conflicts: Boolean to note whether conflicts between</span>
<span class="sd">                window parameters of adjacent segments should be resolved during</span>
<span class="sd">                adjacency setting or an error should be raised about the mismatch.</span>
<span class="sd">                Resolving conflicts will default to the window parameters with the</span>
<span class="sd">                larger are and assign them to the other segment. (Default: True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples with each tuple containing 2 sub-tuples for wall</span>
<span class="sd">            segments paired in the process of solving adjacency. Sub-tuples have</span>
<span class="sd">            the Room2D as the first item and the index of the adjacent wall as the</span>
<span class="sd">            second item. This data can be used to assign custom properties to the</span>
<span class="sd">            new adjacent walls (like assigning custom window parameters for</span>
<span class="sd">            interior windows, assigning air boundaries, or custom boundary</span>
<span class="sd">            conditions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># first, remove any duplicate vertices that might not be translated to HB</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">room</span><span class="o">.</span><span class="n">remove_duplicate_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># degenerate room; just leave it</span>
                <span class="k">pass</span>
        <span class="c1"># set the adjacencies between all matching segments</span>
        <span class="n">rwc</span> <span class="o">=</span> <span class="n">resolve_window_conflicts</span>
        <span class="n">adj_info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">room_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">room_2</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">overlapping_bounding_rect</span><span class="p">(</span>
                            <span class="n">room_1</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span>
                            <span class="n">room_2</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="k">continue</span>  <span class="c1"># no overlap in bounding rect; adjacency impossible</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">seg_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_1</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">room_2</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">Surface</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                                        <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                                    <span class="c1"># set the boundary conditions of the segments</span>
                                    <span class="n">room_1</span><span class="o">.</span><span class="n">set_adjacency</span><span class="p">(</span><span class="n">room_2</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">rwc</span><span class="p">)</span>
                                    <span class="n">adj_info</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">room_1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">room_2</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>
                                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># we have reached the end of the list of rooms</span>
        <span class="k">return</span> <span class="n">adj_info</span></div>


<div class="viewcode-block" id="Room2D.find_adjacency">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.find_adjacency">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_adjacency</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list with all adjacent pairs of segments between input Room2Ds.</span>

<span class="sd">        Note that this method does not change any boundary conditions of the input</span>
<span class="sd">        Room2Ds or mutate them in any way. It&#39;s purely a geometric analysis of the</span>
<span class="sd">        segments between Room2Ds.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which adjacencies will be evaluated.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered adjacent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples for each discovered adjacency. Each tuple contains</span>
<span class="sd">            2 sub-tuples with two elements. The first element is the Room2D and</span>
<span class="sd">            the second is the index of the wall segment that is adjacent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adj_info</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># lists of adjacencies to track</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">room_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">room_2</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">overlapping_bounding_rect</span><span class="p">(</span>
                            <span class="n">room_1</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span>
                            <span class="n">room_2</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="k">continue</span>  <span class="c1"># no overlap in bounding rect; adjacency impossible</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">seg_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_1</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                                    <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                                <span class="n">adj_info</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">room_1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">room_2</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>
                                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># we have reached the end of the list of rooms</span>
        <span class="k">return</span> <span class="n">adj_info</span></div>


<div class="viewcode-block" id="Room2D.find_adjacency_by_guide_lines">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.find_adjacency_by_guide_lines">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_adjacency_by_guide_lines</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get adjacent pairs of Room2Ds segments that lie along specified guide lines.</span>

<span class="sd">        Note that this method does not change any boundary conditions of the input</span>
<span class="sd">        Room2Ds or mutate them in any way. It&#39;s purely a geometric analysis of the</span>
<span class="sd">        segments between Room2Ds and the input lines.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which adjacencies will be solved.</span>
<span class="sd">            lines: A list of LineSegment2D objects to note which adjacencies</span>
<span class="sd">                along all of the room_2ds should be returned.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered adjacent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of tuples for each discovered adjacency that lies along the</span>
<span class="sd">            input lines. Each tuple contains 2 sub-tuples with two elements.</span>
<span class="sd">            The first element is the Room2D and the second is the index of the</span>
<span class="sd">            wall segment that is adjacent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adj_info</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># lists of adjacencies to track</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">room_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">room_2</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">overlapping_bounding_rect</span><span class="p">(</span>
                            <span class="n">room_1</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span>
                            <span class="n">room_2</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="k">continue</span>  <span class="c1"># no overlap in bounding rect; adjacency impossible</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">seg_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_1</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg_2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room_2</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                                    <span class="n">seg_1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_seg_on_guide_lines</span><span class="p">(</span><span class="n">seg_1</span><span class="p">,</span> <span class="n">lines</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                                    <span class="n">adj_info</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">room_1</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="p">(</span><span class="n">room_2</span><span class="p">,</span> <span class="n">k</span><span class="p">)))</span>
                                <span class="k">break</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># we have reached the end of the list of rooms</span>
        <span class="k">return</span> <span class="n">adj_info</span></div>


<div class="viewcode-block" id="Room2D.intersect_adjacency">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.intersect_adjacency">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersect_adjacency</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">preserve_wall_props</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Intersect the line segments of an array of Room2Ds to ensure matching walls.</span>

<span class="sd">        Also note that this method does not actually set the walls that are next to one</span>
<span class="sd">        another to be adjacent. The solve_adjacency method must be used for this after</span>
<span class="sd">        running this method.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which adjacent segments will be</span>
<span class="sd">                intersected.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered adjacent. Default: 0.01,</span>
<span class="sd">                suitable for objects in meters.</span>
<span class="sd">            preserve_wall_props: Boolean to note whether existing window parameters,</span>
<span class="sd">                shading parameters and boundary conditions should be preserved as</span>
<span class="sd">                vertices are added during intersection. If False, all boundary</span>
<span class="sd">                conditions are replaced with Outdoors, all window parameters are</span>
<span class="sd">                erased, and this method will execute quickly. If True, an attempt</span>
<span class="sd">                will be made to split window parameters new across colinear segments.</span>
<span class="sd">                Existing boundary conditions will also be kept. (Default: True).</span>

<span class="sd">        Returns:</span>
<span class="sd">            An array of Room2Ds that have been intersected with one another.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># keep track of all data needed to map between 2D and 3D space</span>
        <span class="n">master_plane</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span>
        <span class="n">move_dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_holes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">polygon_2ds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">tolerance</span>

        <span class="c1"># map all Room geometry into the same 2D space</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="c1"># ensure all starting room heights match</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">master_plane</span><span class="o">.</span><span class="n">o</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_height</span>
            <span class="n">move_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>  <span class="c1"># record all distances moved</span>
            <span class="n">is_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># record that first Polygon doesn&#39;t have holes</span>
            <span class="n">polygon_2ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">)</span>
            <span class="c1"># of there are holes in the face, add them as their own polygons</span>
            <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="o">.</span><span class="n">hole_polygon2d</span><span class="p">:</span>
                    <span class="n">move_dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>  <span class="c1"># record all distances moved</span>
                    <span class="n">is_holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># record that first Polygon doesn&#39;t have holes</span>
                    <span class="n">polygon_2ds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>

        <span class="c1"># intersect the Room2D polygons within the 2D space</span>
        <span class="n">int_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">intersect_polygon_segments</span><span class="p">(</span><span class="n">polygon_2ds</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>

        <span class="c1"># convert the resulting coordinates back to 3D space</span>
        <span class="n">face_pts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">is_hole</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">int_poly</span><span class="p">,</span> <span class="n">move_dists</span><span class="p">,</span> <span class="n">is_holes</span><span class="p">):</span>
            <span class="n">pt_3d</span> <span class="o">=</span> <span class="p">[</span><span class="n">master_plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pt_3d</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">dist</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">pt_3d</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_hole</span><span class="p">:</span>
                <span class="n">face_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pt_3d</span><span class="p">,</span> <span class="p">[]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">face_pts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_3d</span><span class="p">)</span>

        <span class="c1"># rebuild all of the floor geometries to the input Room2Ds</span>
        <span class="n">intersected_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">face_loops</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">face_pts</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># no holes</span>
                <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">face_loops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># ensure holes are included</span>
                <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">face_loops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span>
                                 <span class="n">face_loops</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">rebuilt_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
                <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                <span class="n">is_ground_contact</span><span class="o">=</span><span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span>
                <span class="n">is_top_exposed</span><span class="o">=</span><span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">)</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_floor</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_has_floor</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_has_ceiling</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_has_ceiling</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_floor_plenum_depth</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_zone</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">skylight_parameters</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_display_name</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> \
                <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">user_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_parent</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="o">=</span> <span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_abridged_properties</span>
            <span class="n">rebuilt_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
            <span class="n">intersected_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rebuilt_room</span><span class="p">)</span>

        <span class="c1"># transfer the wall properties if requested</span>
        <span class="k">if</span> <span class="n">preserve_wall_props</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">orig_r</span><span class="p">,</span> <span class="n">new_r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">intersected_rooms</span><span class="p">):</span>
                <span class="n">orig_r</span><span class="o">.</span><span class="n">_match_and_transfer_wall_props</span><span class="p">(</span><span class="n">new_r</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">intersected_rooms</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.patch_missing_adjacencies">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.patch_missing_adjacencies">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">patch_missing_adjacencies</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace any Surface BCs with missing adjacent objects with outdoors.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which Surface boundary conditions</span>
<span class="sd">                with missing adjacencies will be replaced with Outdoors. Note that</span>
<span class="sd">                missing adjacencies are identified by searching across all</span>
<span class="sd">                Room2Ds within the input room_2ds (not by whether the Room2D&#39;s</span>
<span class="sd">                parent story contains the adjacent Room2D or not).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># gather all of the Surface boundary conditions</span>
        <span class="n">srf_bc_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                    <span class="n">bc_objs</span> <span class="o">=</span> <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">bc_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">bc_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;..Face&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">srf_bc_dict</span><span class="p">[(</span><span class="n">bc_objs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bc_ind</span><span class="p">)]</span> <span class="o">=</span> \
                            <span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">bc_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">room</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># Surface BC not following dragonfly convention</span>
                        <span class="c1"># this will be reported as a missing adjacency later</span>
                        <span class="n">srf_bc_dict</span><span class="p">[(</span><span class="n">bc_objs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10000</span><span class="p">)]</span> <span class="o">=</span> \
                            <span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">bc_objs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">room</span><span class="p">)</span>
        <span class="c1"># check the adjacencies for all Surface boundary conditions</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">srf_bc_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">rm_id</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="n">rm_id</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">rm_bc</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>  <span class="c1"># referenced wall segment does not exist</span>
                        <span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rm_bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                        <span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span></div>


<div class="viewcode-block" id="Room2D.group_by_floor_height">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_floor_height">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">group_by_floor_height</span><span class="p">(</span><span class="n">rooms</span><span class="p">,</span> <span class="n">min_difference</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group Room2Ds according to their floor_height.</span>

<span class="sd">        Args:</span>
<span class="sd">            rooms: A list of Room2Ds to be grouped by floor height.</span>
<span class="sd">            min_difference: An float value to denote the minimum difference</span>
<span class="sd">                in floor heights that is considered meaningful. Default: 0.01, which</span>
<span class="sd">                means that virtually any minor difference in floor heights will</span>
<span class="sd">                result in a new group. This assumption is suitable for models</span>
<span class="sd">                in meters.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with two items.</span>

<span class="sd">            -   grouped_rooms - A list of lists of Room2Ds with each sub-list</span>
<span class="sd">                representing a different floor height.</span>

<span class="sd">            -   floor_heights - A list of floor heights with one floor height for each</span>
<span class="sd">                sub-list of the output grouped_rooms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loop through each of the rooms and get the floor height</span>
        <span class="n">flrhgt_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">:</span>
            <span class="n">flrhgt</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_height</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c1"># assume there is already a story with the room&#39;s floor height</span>
                <span class="n">flrhgt_dict</span><span class="p">[</span><span class="n">flrhgt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>  <span class="c1"># this is the first room with this floor height</span>
                <span class="n">flrhgt_dict</span><span class="p">[</span><span class="n">flrhgt</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">flrhgt_dict</span><span class="p">[</span><span class="n">flrhgt</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>

        <span class="c1"># sort the rooms by floor heights</span>
        <span class="n">room_mtx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">flrhgt_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">flr_hgts</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r_tup</span> <span class="ow">in</span> <span class="n">room_mtx</span><span class="p">]</span>
        <span class="n">rooms</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r_tup</span> <span class="ow">in</span> <span class="n">room_mtx</span><span class="p">]</span>

        <span class="c1"># group floor heights if they differ by less than the min_difference</span>
        <span class="n">floor_heights</span> <span class="o">=</span> <span class="p">[</span><span class="n">flr_hgts</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">grouped_rooms</span> <span class="o">=</span> <span class="p">[</span><span class="n">rooms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">flrh</span><span class="p">,</span> <span class="n">rm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flr_hgts</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rooms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="n">flrh</span> <span class="o">-</span> <span class="n">floor_heights</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_difference</span><span class="p">:</span>
                <span class="n">grouped_rooms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grouped_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
                <span class="n">floor_heights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flrh</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grouped_rooms</span><span class="p">,</span> <span class="n">floor_heights</span></div>


<div class="viewcode-block" id="Room2D.group_by_adjacency">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_adjacency">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">group_by_adjacency</span><span class="p">(</span><span class="n">rooms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group Room2Ds together that are connected by adjacencies.</span>

<span class="sd">        This is useful for separating rooms in the case where a Story contains</span>
<span class="sd">        multiple towers or sections that are separated by outdoor boundary conditions.</span>

<span class="sd">        Args:</span>
<span class="sd">            rooms: A list of Room2Ds to be grouped by their adjacency.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of list with each sub-list containing rooms that share adjacencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_adjacency_grouping</span><span class="p">(</span><span class="n">rooms</span><span class="p">,</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_find_adjacent_rooms</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.group_by_air_boundary_adjacency">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_air_boundary_adjacency">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">group_by_air_boundary_adjacency</span><span class="p">(</span><span class="n">rooms</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group Room2Ds together that share air boundaries.</span>

<span class="sd">        This is useful for understanding the radiant enclosures that will exist</span>
<span class="sd">        when a model is exported to EnergyPlus.</span>

<span class="sd">        Args:</span>
<span class="sd">            rooms: A list of Room2Ds to be grouped by their air boundary adjacency.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of list with each sub-list containing Room2Ds that share adjacent</span>
<span class="sd">            air boundaries. If a Room has no air boundaries it will the the only</span>
<span class="sd">            item within its sub-list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_adjacency_grouping</span><span class="p">(</span>
            <span class="n">rooms</span><span class="p">,</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_find_adjacent_air_boundary_rooms</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.group_by_attribute">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_attribute">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">group_by_attribute</span><span class="p">(</span><span class="n">rooms</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group rooms with the same value for a given attribute.</span>

<span class="sd">        Args:</span>
<span class="sd">            attr_name: A string of an attribute that the input rooms should have.</span>
<span class="sd">                This can have &#39;.&#39; that separate the nested attributes from one another.</span>
<span class="sd">                For example, &#39;properties.energy.program_type&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with two items.</span>

<span class="sd">            -   grouped_rooms - A list of lists of honeybee rooms with each sub-list</span>
<span class="sd">                representing a different value for the attribute.</span>

<span class="sd">            -   values - A list of text strings for the value associated with each</span>
<span class="sd">                sub-list of the output grouped_rooms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loop through each of the rooms and get the orientation</span>
        <span class="n">attr_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">get_attr_nested</span><span class="p">(</span><span class="n">room</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">attr_dict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">attr_dict</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">room</span><span class="p">]</span>

        <span class="c1"># sort the rooms by values</span>
        <span class="n">room_mtx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">attr_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r_tup</span> <span class="ow">in</span> <span class="n">room_mtx</span><span class="p">]</span>
        <span class="n">grouped_rooms</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r_tup</span> <span class="ow">in</span> <span class="n">room_mtx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">grouped_rooms</span><span class="p">,</span> <span class="n">values</span></div>


<div class="viewcode-block" id="Room2D.group_by_orientation">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.group_by_orientation">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">group_by_orientation</span><span class="p">(</span><span class="n">rooms</span><span class="p">,</span> <span class="n">group_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">north_vector</span><span class="o">=</span><span class="n">Vector2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group Room2Ds together that have a similar orientation or exterior walls.</span>

<span class="sd">        This is useful for automatic zoning where rooms with similar solar loads</span>
<span class="sd">        can be grouped into the same zone.</span>

<span class="sd">        Args:</span>
<span class="sd">            rooms: A list of Room2Ds to be grouped by their orientation.</span>
<span class="sd">            group_count: An optional positive integer to set the number of orientation</span>
<span class="sd">                groups to use. For example, setting this to 4 will result in rooms</span>
<span class="sd">                being grouped by four orientations (North, East, South, West). If None,</span>
<span class="sd">                the maximum number of unique groups will be used.</span>
<span class="sd">            north_vector: A ladybug_geometry Vector2D for the north direction.</span>
<span class="sd">                Default is the Y-axis (0, 1).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with three items.</span>

<span class="sd">            -   grouped_rooms - A list of lists of Room2Ds with each sub-list</span>
<span class="sd">                representing a different orientation.</span>

<span class="sd">            -   core_rooms - A list of honeybee Room2Ds with no identifiable orientation.</span>

<span class="sd">            -   orientations - A list of numbers between 0 and 360 with one orientation</span>
<span class="sd">                for each branch of the output grouped_rooms. This will be a list of</span>
<span class="sd">                angle ranges if a value is input for group_count.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loop through each of the rooms and get the orientation</span>
        <span class="n">orient_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">core_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">:</span>
            <span class="n">ori</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">average_orientation</span><span class="p">(</span><span class="n">north_vector</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ori</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">core_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">orient_dict</span><span class="p">[</span><span class="n">ori</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">orient_dict</span><span class="p">[</span><span class="n">ori</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">orient_dict</span><span class="p">[</span><span class="n">ori</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>

        <span class="c1"># sort the rooms by orientation values</span>
        <span class="n">room_mtx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">orient_dict</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">orientations</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">r_tup</span> <span class="ow">in</span> <span class="n">room_mtx</span><span class="p">]</span>
        <span class="n">grouped_rooms</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">r_tup</span> <span class="ow">in</span> <span class="n">room_mtx</span><span class="p">]</span>

        <span class="c1"># group orientations if there is an input group_count</span>
        <span class="k">if</span> <span class="n">group_count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">angs</span> <span class="o">=</span> <span class="n">angles_from_num_orient</span><span class="p">(</span><span class="n">group_count</span><span class="p">)</span>
            <span class="n">p_rooms</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">group_count</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ori</span><span class="p">,</span> <span class="n">rm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">grouped_rooms</span><span class="p">):</span>
                <span class="n">or_ind</span> <span class="o">=</span> <span class="n">orient_index</span><span class="p">(</span><span class="n">ori</span><span class="p">,</span> <span class="n">angs</span><span class="p">)</span>
                <span class="n">p_rooms</span><span class="p">[</span><span class="n">or_ind</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
            <span class="n">orientations</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">angs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">angs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">group_count</span><span class="p">)]</span>
            <span class="n">grouped_rooms</span> <span class="o">=</span> <span class="n">p_rooms</span>
        <span class="k">return</span> <span class="n">grouped_rooms</span><span class="p">,</span> <span class="n">core_rooms</span><span class="p">,</span> <span class="n">orientations</span></div>


<div class="viewcode-block" id="Room2D.automatically_zone">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.automatically_zone">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">automatically_zone</span><span class="p">(</span><span class="n">rooms</span><span class="p">,</span> <span class="n">orient_count</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">north_vector</span><span class="o">=</span><span class="n">Vector2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                           <span class="n">attr_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Automatically group Room2Ds with a similar properties into zones.</span>

<span class="sd">        Relevant properties that are used to group Room2Ds into zones include story,</span>
<span class="sd">        orientation, and additional attributes (like programs).</span>

<span class="sd">        Args:</span>
<span class="sd">            orient_count: An optional positive integer to set the number of orientation</span>
<span class="sd">                groups to use for zoning. For example, setting this to 4 will result</span>
<span class="sd">                in zones being established based on the four orientations (North,</span>
<span class="sd">                East, South, West). If None, the maximum number of unique groups</span>
<span class="sd">                will be used.</span>
<span class="sd">            north_vector: A ladybug_geometry Vector2D for the north direction.</span>
<span class="sd">                Default is the Y-axis (0, 1).</span>
<span class="sd">            attr_name: A string of an attribute that the input Room2Ds should have.</span>
<span class="sd">                This can have &#39;.&#39; that separate the nested attributes from one another.</span>
<span class="sd">                For example, &#39;properties.energy.program_type&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># group the rooms by story</span>
        <span class="n">story_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">:</span>
            <span class="n">story_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> - &#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">display_name</span><span class="p">)</span> <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">has_parent</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">story_dict</span><span class="p">[</span><span class="n">story_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">story_dict</span><span class="p">[</span><span class="n">story_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">room</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">story_id</span><span class="p">,</span> <span class="n">story_rooms</span> <span class="ow">in</span> <span class="n">story_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># group the rooms by orientation</span>
            <span class="n">perim_rooms</span><span class="p">,</span> <span class="n">core_rooms</span><span class="p">,</span> <span class="n">orientations</span><span class="p">,</span> <span class="o">=</span> \
                <span class="n">Room2D</span><span class="o">.</span><span class="n">group_by_orientation</span><span class="p">(</span><span class="n">story_rooms</span><span class="p">,</span> <span class="n">orient_count</span><span class="p">,</span> <span class="n">north_vector</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">orient_count</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">orientations</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">orient_count</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">orientations</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;NE&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;SE&#39;</span><span class="p">,</span> <span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="s1">&#39;SW&#39;</span><span class="p">,</span> <span class="s1">&#39;W&#39;</span><span class="p">,</span> <span class="s1">&#39;NW&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">orientations</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> deg&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">orient</span><span class="p">)</span> <span class="k">for</span> <span class="n">orient</span> <span class="ow">in</span> <span class="n">orientations</span><span class="p">]</span>
            <span class="n">orientations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Core&#39;</span><span class="p">)</span>
            <span class="n">orient_rooms</span> <span class="o">=</span> <span class="n">perim_rooms</span> <span class="o">+</span> <span class="p">[</span><span class="n">core_rooms</span><span class="p">]</span>

            <span class="c1"># assign the zone name to each group</span>
            <span class="k">for</span> <span class="n">orient_id</span><span class="p">,</span> <span class="n">orient_rooms</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">orientations</span><span class="p">,</span> <span class="n">orient_rooms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">attr_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># group the rooms by attribute</span>
                    <span class="n">attr_rooms</span><span class="p">,</span> <span class="n">attr_vals</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">group_by_attribute</span><span class="p">(</span><span class="n">orient_rooms</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">atr_val</span><span class="p">,</span> <span class="n">zone_rooms</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">attr_vals</span><span class="p">,</span> <span class="n">attr_rooms</span><span class="p">):</span>
                        <span class="n">atr_val</span> <span class="o">=</span> <span class="n">atr_val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;::&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">zone_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1"> - </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">story_id</span><span class="p">,</span> <span class="n">orient_id</span><span class="p">,</span> <span class="n">atr_val</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">zone_rooms</span><span class="p">:</span>
                            <span class="n">room</span><span class="o">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">zone_id</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">zone_id</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">story_id</span><span class="p">,</span> <span class="n">orient_id</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">orient_rooms</span><span class="p">:</span>
                        <span class="n">room</span><span class="o">.</span><span class="n">zone</span> <span class="o">=</span> <span class="n">zone_id</span></div>


<div class="viewcode-block" id="Room2D.join_room_2ds">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.join_room_2ds">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">join_room_2ds</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">min_separation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Join Room2Ds together that are touching one another within a min_separation.</span>

<span class="sd">        When the min_separation is less than or equal to the tolerance, all</span>
<span class="sd">        properties of segments for the input Room2Ds will be preserved. When</span>
<span class="sd">        the min_separation is larger than the tolerance, an attempt is made to</span>
<span class="sd">        preserve all wall properties but there is a risk of losing some windows</span>
<span class="sd">        just in the region where two Room2Ds are joined together across a gap</span>
<span class="sd">        between them. This risk can be overcome by inserting Room2D vertices</span>
<span class="sd">        around where the gap will be crossed between that Room2D and the</span>
<span class="sd">        other Room2D.</span>

<span class="sd">        The largest Room2D that is identified within each connected group will</span>
<span class="sd">        determine the extension properties of the resulting Room2D. Skylights</span>
<span class="sd">        will be merged across rooms if they are of the same type or if they are None.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds which will be joined together where they</span>
<span class="sd">                touch one another.</span>
<span class="sd">            min_separation: A number for the minimum distance between Room2Ds that</span>
<span class="sd">                is considered a meaningful separation. Gaps between Room2Ds that</span>
<span class="sd">                are less than this distance will result in the Room2Ds being</span>
<span class="sd">                joined across the gap. When the input Room2Ds have floor_geometry</span>
<span class="sd">                representing the boundaries defined by the interior wall finishes,</span>
<span class="sd">                this input can be thought of as the maximum interior wall thickness.</span>
<span class="sd">                When Room2Ds are perfectly touching one another within the tolerance</span>
<span class="sd">                (with Room2D floor_geometry drawn to the center lines of interior</span>
<span class="sd">                walls), this value can be set to zero or anything less than or</span>
<span class="sd">                equal to the tolerance. Doing so will yield a cleaner result for the</span>
<span class="sd">                boundary, which will be faster and more reliable. Note that care</span>
<span class="sd">                should be taken not to set this value higher than the length of any</span>
<span class="sd">                meaningful exterior wall segments. Otherwise, the exterior segments</span>
<span class="sd">                will be ignored in the result. This can be particularly dangerous</span>
<span class="sd">                around curved exterior walls that have been planarized through</span>
<span class="sd">                subdivision into small segments. (Default: 0).</span>
<span class="sd">            tolerance: The minimum distance between a vertex and the polygon</span>
<span class="sd">                boundary at which point the vertex is considered to lie on the</span>
<span class="sd">                polygon. (Default: 0.01, suitable for objects in meters).</span>
<span class="sd">            identifier: An optional text string for the identifier of the new</span>
<span class="sd">                joined Room2D. If this matches an existing Room2D inside of the</span>
<span class="sd">                polygon, the existing Room2D will be used to set the extension</span>
<span class="sd">                properties of the output Room2D. If None, the identifier</span>
<span class="sd">                and extension properties of the output Room2D will be those of</span>
<span class="sd">                the largest Room2D found inside of the polygon. (Default: None).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the horizontal boundaries around the input Room2Ds</span>
        <span class="n">h_bnds</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">grouped_horizontal_boundary</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">min_separation</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_bnds</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">):</span>  <span class="c1"># no Room2Ds to join; return them as they are</span>
            <span class="k">return</span> <span class="n">room_2ds</span>

        <span class="c1"># ensure Room2D vertices at the boundary exist</span>
        <span class="k">if</span> <span class="n">min_separation</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="n">room_2ds</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">intersect_adjacency</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># we have to figure out if new vertices were added to cross the boundary</span>
            <span class="c1"># gather all vertices across the horizontal boundaries</span>
            <span class="n">bnd_verts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">h_bnd</span> <span class="ow">in</span> <span class="n">h_bnds</span><span class="p">:</span>
                <span class="n">bnd_verts</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">h_bnd</span><span class="o">.</span><span class="n">boundary</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">h_bnd</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">h_bnd</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                        <span class="n">bnd_verts</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">])</span>
            <span class="c1"># loop through rooms and identify vertices to insert</span>
            <span class="n">inter_rooms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">search_dist</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
                <span class="n">floor_segs</span> <span class="o">=</span> <span class="p">[</span><span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="o">.</span><span class="n">segments</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">hole_polygon2d</span><span class="p">:</span>
                        <span class="n">floor_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>
                <span class="n">pts_2d</span><span class="p">,</span> <span class="n">edit_code</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">floor_segs</span><span class="p">:</span>
                    <span class="n">loop_pts_2d</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
                        <span class="n">loop_pts_2d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span>
                        <span class="n">edit_code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">bnd_pt</span> <span class="ow">in</span> <span class="n">bnd_verts</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">bnd_pt</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">search_dist</span><span class="p">:</span>
                                <span class="k">if</span> <span class="ow">not</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">bnd_pt</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="ow">and</span> \
                                        <span class="ow">not</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">bnd_pt</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                                    <span class="n">loop_pts_2d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bnd_pt</span><span class="p">)</span>  <span class="c1"># vertex to insert !</span>
                                    <span class="n">edit_code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
                    <span class="n">pts_2d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">loop_pts_2d</span><span class="p">)</span>
                <span class="n">edit_code</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">edit_code</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;A&#39;</span> <span class="ow">in</span> <span class="n">edit_code</span><span class="p">:</span>  <span class="c1"># room geometry must be updated</span>
                    <span class="n">room</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>  <span class="c1"># duplicate to avoid editing original geo</span>
                    <span class="n">z_v</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_height</span>
                    <span class="n">pts_3d</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">pts_2d</span><span class="p">:</span>
                        <span class="n">pts_3d</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_v</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">])</span>
                    <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> \
                        <span class="n">Face3D</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">holes</span><span class="o">=</span><span class="n">pts_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">room</span><span class="o">.</span><span class="n">update_floor_geometry</span><span class="p">(</span><span class="n">new_geo</span><span class="p">,</span> <span class="n">edit_code</span><span class="p">,</span> <span class="n">search_dist</span><span class="p">)</span>
                <span class="n">inter_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
            <span class="n">room_2ds</span> <span class="o">=</span> <span class="n">inter_rooms</span>

        <span class="c1"># join the Room2Ds according to the horizontal boundaries that were found</span>
        <span class="n">joined_rooms</span><span class="p">,</span> <span class="n">used_identifier</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">h_bnd</span> <span class="ow">in</span> <span class="n">h_bnds</span><span class="p">:</span>
            <span class="n">bnd_p_gon</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">h_bnd</span><span class="o">.</span><span class="n">boundary</span><span class="p">])</span>
            <span class="n">h_p</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">h_bnd</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                <span class="n">h_p</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">h_bnd</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                    <span class="n">h_p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon2D</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]))</span>
            <span class="n">rm_id</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">used_identifier</span> <span class="k">else</span> <span class="n">identifier</span>
            <span class="n">new_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">join_by_boundary</span><span class="p">(</span>
                <span class="n">room_2ds</span><span class="p">,</span> <span class="n">bnd_p_gon</span><span class="p">,</span> <span class="n">h_p</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="n">rm_id</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="n">joined_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_room</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_room</span><span class="o">.</span><span class="n">identifier</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">:</span>
                <span class="n">used_identifier</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">joined_rooms</span></div>


<div class="viewcode-block" id="Room2D.join_by_boundary">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.join_by_boundary">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">join_by_boundary</span><span class="p">(</span>
            <span class="n">room_2ds</span><span class="p">,</span> <span class="n">polygon</span><span class="p">,</span> <span class="n">hole_polygons</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">floor_to_ceiling_height</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">identifier</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">display_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Join several Room2D together using a boundary Polygon as a guide.</span>

<span class="sd">        All properties of segments along the boundary polygon will be preserved.</span>
<span class="sd">        The largest Room2D that is identified within the boundary polygon will</span>
<span class="sd">        determine the extension properties of the resulting Room unless the supplied</span>
<span class="sd">        identifier matches an existing Room2D inside the polygon. Skylights</span>
<span class="sd">        will be merged if they are of the same type or if they are None.</span>

<span class="sd">        It is recommended that the Room2Ds be aligned to the boundaries</span>
<span class="sd">        of the polygon and duplicate vertices be removed before passing them</span>
<span class="sd">        through this method. However, colinear vertices should not be removed</span>
<span class="sd">        where possible. This helps ensure that relevant Room2D segments</span>
<span class="sd">        are colinear with the polygon and so they can influence the result.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds which will be joined together using the polygon.</span>
<span class="sd">            polygon: A ladybug_geometry Polygon2D which will become the boundary</span>
<span class="sd">                of the output joined Room2D.</span>
<span class="sd">            hole_polygons: An optional list of hole polygons, which will add</span>
<span class="sd">                holes into the output joined Room2D polygon. (Default: None).</span>
<span class="sd">            floor_to_ceiling_height: An optional number to set the floor-to-ceiling</span>
<span class="sd">                height of the resulting Room2D. If None, it will be the maximum</span>
<span class="sd">                of the Room2Ds that are found inside the polygon, which ensures</span>
<span class="sd">                that all window geometries are included in the output. If specified</span>
<span class="sd">                and it is lower than the maximum Room2D height, any detailed</span>
<span class="sd">                windows will be automatically trimmed to accommodate the new</span>
<span class="sd">                floor-to-ceiling height. (Default: None).</span>
<span class="sd">            identifier: An optional text string for the identifier of the new</span>
<span class="sd">                joined Room2D. If this matches an existing Room2D inside of the</span>
<span class="sd">                polygon, the existing Room2D will be used to set the extension</span>
<span class="sd">                properties of the output Room2D. If None, the identifier</span>
<span class="sd">                and extension properties of the output Room2D will be those of</span>
<span class="sd">                the largest Room2D found inside of the polygon. (Default: None).</span>
<span class="sd">            display_name: An optional text string for the display_name of the new</span>
<span class="sd">                joined Room2D. If None, the display_name will be taken from the</span>
<span class="sd">                largest existing Room2D inside the polygon or the existing</span>
<span class="sd">                Room2D matching the identifier above. (Default: None).</span>
<span class="sd">            tolerance: The minimum distance between a vertex and the polygon</span>
<span class="sd">                boundary at which point the vertex is considered to lie on the</span>
<span class="sd">                polygon. (Default: 0.01, suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">tolerance</span>
        <span class="c1"># ensure that all polygons are counterclockwise</span>
        <span class="n">polygon</span> <span class="o">=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_clockwise</span> <span class="k">else</span> <span class="n">polygon</span>
        <span class="k">if</span> <span class="n">hole_polygons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cc_hole_polygons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hole_polygons</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_clockwise</span> <span class="k">else</span> <span class="n">p</span>
                <span class="n">cc_hole_polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">hole_polygons</span> <span class="o">=</span> <span class="n">cc_hole_polygons</span>

        <span class="c1"># identify all Room2Ds inside of the polygon</span>
        <span class="n">rel_rooms</span><span class="p">,</span> <span class="n">rel_ids</span><span class="p">,</span> <span class="n">rel_a</span><span class="p">,</span> <span class="n">rel_fh</span><span class="p">,</span> <span class="n">rel_ch</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">test_vec</span> <span class="o">=</span> <span class="n">Vector2D</span><span class="p">(</span><span class="mf">0.99</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">is_convex</span><span class="p">:</span>
                <span class="n">rm_pt</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">center</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rm_pt_3d</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">_point_on_face</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
                <span class="n">rm_pt</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">rm_pt_3d</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rm_pt_3d</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">is_point_inside_bound_rect</span><span class="p">(</span><span class="n">rm_pt</span><span class="p">,</span> <span class="n">test_vec</span><span class="p">):</span>
                <span class="n">rel_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
                <span class="n">rel_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
                <span class="n">rel_a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_area</span><span class="p">)</span>
                <span class="n">rel_fh</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_height</span><span class="p">)</span>
                <span class="n">rel_ch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>

        <span class="c1"># if no rooms are inside the polygon, just return a dummy room from the polygon</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel_rooms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">floor_height</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">)</span>
            <span class="n">ftc</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">)</span> \
                <span class="k">if</span> <span class="n">floor_to_ceiling_height</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">floor_to_ceiling_height</span>
            <span class="n">bound_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">fh</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">]</span>
            <span class="n">all_hole_verts</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">hole_polygons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole_polygons</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">all_hole_verts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">hole_polygons</span><span class="p">:</span>
                    <span class="n">all_hole_verts</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">Point3D</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">fh</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hole</span><span class="o">.</span><span class="n">vertices</span><span class="p">])</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">all_hole_verts</span><span class="p">)</span>
            <span class="n">r_id</span> <span class="o">=</span> <span class="n">clean_and_id_string</span><span class="p">(</span><span class="s1">&#39;Room&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">identifier</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">identifier</span>
            <span class="k">return</span> <span class="n">Room2D</span><span class="p">(</span><span class="n">r_id</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="n">ftc</span><span class="p">)</span>

        <span class="c1"># determine the new floor heights using max/average across relevant rooms</span>
        <span class="n">new_flr_height</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">rel_fh</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel_fh</span><span class="p">)</span>
        <span class="n">max_ftc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">rel_ch</span><span class="p">)</span>
        <span class="n">new_ftc</span> <span class="o">=</span> <span class="n">max_ftc</span> <span class="k">if</span> <span class="n">floor_to_ceiling_height</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">floor_to_ceiling_height</span>

        <span class="c1"># determine a primary room to set help set properties or the resulting room</span>
        <span class="k">if</span> <span class="n">identifier</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">identifier</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rel_ids</span><span class="p">:</span>
            <span class="c1"># find the largest room of the relevant rooms</span>
            <span class="n">sort_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rel_a</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rel_a</span><span class="p">))))]</span>
            <span class="n">primary_room</span> <span class="o">=</span> <span class="n">rel_rooms</span><span class="p">[</span><span class="n">sort_inds</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">identifier</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">identifier</span> <span class="o">=</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">identifier</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># draw properties from the room with the matching identifier</span>
            <span class="k">for</span> <span class="n">r_id</span><span class="p">,</span> <span class="n">rm</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rel_ids</span><span class="p">,</span> <span class="n">rel_rooms</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">r_id</span> <span class="o">==</span> <span class="n">identifier</span><span class="p">:</span>
                    <span class="n">primary_room</span> <span class="o">=</span> <span class="n">rm</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">display_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">display_name</span> <span class="o">=</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">display_name</span>

        <span class="c1"># gather all segments and properties of relevant rooms</span>
        <span class="n">rel_segs</span><span class="p">,</span> <span class="n">rel_bcs</span><span class="p">,</span> <span class="n">rel_win</span><span class="p">,</span> <span class="n">rel_shd</span><span class="p">,</span> <span class="n">rel_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rel_rooms</span><span class="p">:</span>
            <span class="n">rel_segs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_segments_2d</span><span class="p">)</span>
            <span class="n">rel_bcs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">boundary_conditions</span><span class="p">)</span>
            <span class="n">rel_shd</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">shading_parameters</span><span class="p">)</span>
            <span class="n">rel_abs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">air_boundaries</span><span class="p">)</span>
            <span class="n">w_par</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">window_parameters</span>
            <span class="n">in_range</span> <span class="o">=</span> <span class="n">new_ftc</span> <span class="o">-</span> <span class="n">tol</span> <span class="o">&lt;</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">&lt;</span> <span class="n">new_ftc</span> <span class="o">+</span> <span class="n">tol</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_range</span><span class="p">:</span>  <span class="c1"># adjust window ratios to preserve area</span>
                <span class="n">new_w_par</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">wp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">w_par</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">wp</span><span class="p">,</span> <span class="n">SimpleWindowRatio</span><span class="p">):</span>
                        <span class="n">w_area</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">area_from_segment</span><span class="p">(</span>
                            <span class="n">rel_segs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
                        <span class="n">new_ratio</span> <span class="o">=</span> <span class="n">w_area</span> <span class="o">/</span> <span class="p">(</span><span class="n">new_ftc</span> <span class="o">*</span> <span class="n">rel_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>
                        <span class="n">new_wp</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                        <span class="n">new_wp</span><span class="o">.</span><span class="n">_window_ratio</span> <span class="o">=</span> <span class="n">new_ratio</span> <span class="k">if</span> <span class="n">new_ratio</span> <span class="o">&lt;=</span> <span class="mf">0.99</span> <span class="k">else</span> <span class="mf">0.99</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_wp</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wp</span><span class="p">)</span>
                <span class="n">w_par</span> <span class="o">=</span> <span class="n">new_w_par</span>
            <span class="n">rel_win</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">w_par</span><span class="p">)</span>

        <span class="c1"># find all of the Room2Ds segments that lie on each polygon segment</span>
        <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">bound_verts</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_segments_along_polygon</span><span class="p">(</span>
            <span class="n">polygon</span><span class="p">,</span> <span class="n">rel_segs</span><span class="p">,</span> <span class="n">rel_bcs</span><span class="p">,</span> <span class="n">rel_win</span><span class="p">,</span> <span class="n">rel_shd</span><span class="p">,</span> <span class="n">rel_abs</span><span class="p">,</span>
            <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">,</span> <span class="n">new_flr_height</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hole_polygons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole_polygons</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">all_hole_verts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">hole_polygons</span><span class="p">:</span>
                <span class="n">hole_verts</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">_segments_along_polygon</span><span class="p">(</span>
                    <span class="n">hole</span><span class="p">,</span> <span class="n">rel_segs</span><span class="p">,</span> <span class="n">rel_bcs</span><span class="p">,</span> <span class="n">rel_win</span><span class="p">,</span> <span class="n">rel_shd</span><span class="p">,</span> <span class="n">rel_abs</span><span class="p">,</span>
                    <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">,</span> <span class="n">new_flr_height</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
                <span class="n">all_hole_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole_verts</span><span class="p">)</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">all_hole_verts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_geo</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">bound_verts</span><span class="p">)</span>

        <span class="c1"># merge skylights across the input rooms if they are of the same type</span>
        <span class="n">new_sky_lights</span><span class="p">,</span> <span class="n">new_areas</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rel_rooms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_sky_lights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">skylight_parameters</span><span class="p">)</span>
                <span class="n">new_areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_area</span><span class="p">)</span>
        <span class="n">new_sky_light</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="n">DetailedSkylights</span><span class="p">)</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">new_sky_lights</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_polys</span> <span class="o">=</span> <span class="n">new_sky_lights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">polygons</span>
                <span class="n">new_is_dr</span> <span class="o">=</span> <span class="n">new_sky_lights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">are_doors</span>
                <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">new_sky_lights</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">new_polys</span> <span class="o">+=</span> <span class="n">sl</span><span class="o">.</span><span class="n">polygons</span>
                    <span class="n">new_is_dr</span> <span class="o">+=</span> <span class="n">sl</span><span class="o">.</span><span class="n">are_doors</span>
                <span class="n">new_sky_light</span> <span class="o">=</span> <span class="n">DetailedSkylights</span><span class="p">(</span><span class="n">new_polys</span><span class="p">,</span> <span class="n">new_is_dr</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># skylight with no polygons</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="n">GriddedSkylightArea</span><span class="p">)</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">new_sky_lights</span><span class="p">):</span>
            <span class="n">new_area</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sl</span><span class="o">.</span><span class="n">skylight_area</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">new_sky_lights</span><span class="p">)</span>
            <span class="n">new_sky_light</span> <span class="o">=</span> <span class="n">GriddedSkylightArea</span><span class="p">(</span><span class="n">new_area</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">sl</span><span class="p">,</span> <span class="n">GriddedSkylightRatio</span><span class="p">)</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">new_sky_lights</span><span class="p">):</span>
            <span class="n">zip_obj</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_sky_lights</span><span class="p">,</span> <span class="n">new_areas</span><span class="p">)</span>
            <span class="n">new_area</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sl</span><span class="o">.</span><span class="n">skylight_ratio</span> <span class="o">*</span> <span class="n">fa</span> <span class="k">for</span> <span class="n">sl</span><span class="p">,</span> <span class="n">fa</span> <span class="ow">in</span> <span class="n">zip_obj</span><span class="p">)</span>
            <span class="n">new_ratio</span> <span class="o">=</span> <span class="n">new_area</span> <span class="o">/</span> <span class="nb">sum</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_area</span> <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">rel_rooms</span><span class="p">)</span>
            <span class="n">new_sky_light</span> <span class="o">=</span> <span class="n">GriddedSkylightRatio</span><span class="p">(</span><span class="n">new_ratio</span><span class="p">)</span>

        <span class="c1"># merge all segments and properties into a single Room2D</span>
        <span class="n">new_room</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span>
            <span class="n">identifier</span><span class="p">,</span> <span class="n">new_geo</span><span class="p">,</span> <span class="n">new_ftc</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span>
            <span class="n">primary_room</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">,</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">has_floor</span> <span class="o">=</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">has_floor</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">has_ceiling</span> <span class="o">=</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">has_ceiling</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">ceiling_plenum_depth</span> <span class="o">=</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">ceiling_plenum_depth</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">floor_plenum_depth</span> <span class="o">=</span> <span class="n">primary_room</span><span class="o">.</span><span class="n">floor_plenum_depth</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">skylight_parameters</span> <span class="o">=</span> <span class="n">new_sky_light</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">air_boundaries</span> <span class="o">=</span> <span class="n">new_abs</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">display_name</span> <span class="o">=</span> <span class="n">display_name</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="n">primary_room</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>

        <span class="c1"># if the floor-to-ceiling height is lower than the max, re-trim windows</span>
        <span class="k">if</span> <span class="n">new_ftc</span> <span class="o">&lt;</span> <span class="n">max_ftc</span><span class="p">:</span>
            <span class="n">new_w_pars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">w_par</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">new_room</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">,</span> <span class="n">new_room</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w_par</span><span class="p">,</span> <span class="n">DetailedWindows</span><span class="p">):</span>
                    <span class="n">new_w_par</span> <span class="o">=</span> <span class="n">w_par</span><span class="o">.</span><span class="n">adjust_for_segment</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">new_ftc</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_w_par</span> <span class="o">=</span> <span class="n">w_par</span>
                <span class="n">new_w_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_w_par</span><span class="p">)</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_w_pars</span>

        <span class="k">return</span> <span class="n">new_room</span></div>


<div class="viewcode-block" id="Room2D.join_to_neighbor">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.join_to_neighbor">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">join_to_neighbor</span><span class="p">(</span><span class="n">base_room_2ds</span><span class="p">,</span> <span class="n">merge_room_2ds</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge a set of Room2Ds into base Room2Ds that are adjacent to them.</span>

<span class="sd">        The merge_rooms will always be merged into the base_room with which they</span>
<span class="sd">        share the longest total perimeter length.</span>

<span class="sd">        This is a useful way of eliminating small rooms in a Story without compromising</span>
<span class="sd">        the overall adjacency across Story. It can be also used in conjunction with</span>
<span class="sd">        the Story.fill_holes method to fill holes in a manner that expands existing</span>
<span class="sd">        rooms to fill the holes rather than adding new rooms.</span>

<span class="sd">        Args:</span>
<span class="sd">            base_room_2ds: A list of Room2Ds into which other Room2Ds will be merged.</span>
<span class="sd">            merge_room_2ds: A list of Room2Ds to be merged into the base_rooms.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered adjacent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Room2Ds with the merge_rooms incorporated into the base_rooms</span>
<span class="sd">            where possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># intersect adjacency to ensure matching segments</span>
        <span class="n">merge_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rm</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="n">merge_room_2ds</span><span class="p">)</span>
        <span class="n">all_rooms</span> <span class="o">=</span> <span class="n">base_room_2ds</span> <span class="o">+</span> <span class="n">merge_room_2ds</span>
        <span class="n">all_rooms</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">intersect_adjacency</span><span class="p">(</span><span class="n">all_rooms</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="n">base_rooms</span><span class="p">,</span> <span class="n">merge_rooms</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="n">all_rooms</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">rm</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">in</span> <span class="n">merge_ids</span><span class="p">:</span>
                <span class="n">merge_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rm</span><span class="p">)</span>

        <span class="c1"># determine pairs of rooms to be merged together</span>
        <span class="n">merge_pairs</span><span class="p">,</span> <span class="n">lone_merge_rooms</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m_room</span> <span class="ow">in</span> <span class="n">merge_rooms</span><span class="p">:</span>
            <span class="n">perim_dict</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dict to track the total shared perimeter</span>
            <span class="n">adj_info</span> <span class="o">=</span> <span class="n">m_room</span><span class="o">.</span><span class="n">find_segment_adjacency</span><span class="p">(</span><span class="n">base_rooms</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">a_inf</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">m_room</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">,</span> <span class="n">adj_info</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a_inf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">a_room</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">a_inf</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">perim_dict</span><span class="p">[</span><span class="n">a_room</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span> <span class="o">+=</span> <span class="n">seg</span><span class="o">.</span><span class="n">length</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>  <span class="c1"># first time we are encountering the room</span>
                        <span class="n">perim_dict</span><span class="p">[</span><span class="n">a_room</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">length</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">perim_dict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># no neighboring rooms to merge into</span>
                <span class="n">lone_merge_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_room</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">perim_len</span><span class="p">,</span> <span class="n">adj_rm_ids</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rm_id</span><span class="p">,</span> <span class="n">p_len</span> <span class="ow">in</span> <span class="n">perim_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">perim_len</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p_len</span><span class="p">)</span>
                <span class="n">adj_rm_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rm_id</span><span class="p">)</span>
            <span class="n">sort_rm_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">r_id</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">r_id</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">perim_len</span><span class="p">,</span> <span class="n">adj_rm_ids</span><span class="p">),</span>
                           <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
            <span class="n">adj_rm_id</span> <span class="o">=</span> <span class="n">sort_rm_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">merge_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">m_room</span><span class="p">,</span> <span class="n">adj_rm_id</span><span class="p">))</span>

        <span class="c1"># create the final set of merged rooms</span>
        <span class="n">final_rooms</span> <span class="o">=</span> <span class="p">{</span><span class="n">rm</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">rm</span> <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="n">base_room_2ds</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">m_pair</span> <span class="ow">in</span> <span class="n">merge_pairs</span><span class="p">:</span>
            <span class="n">m_room</span><span class="p">,</span> <span class="n">adj_rm_id</span> <span class="o">=</span> <span class="n">m_pair</span>
            <span class="n">pair_rooms</span> <span class="o">=</span> <span class="p">[</span><span class="n">final_rooms</span><span class="p">[</span><span class="n">adj_rm_id</span><span class="p">],</span> <span class="n">m_room</span><span class="p">]</span>
            <span class="n">final_rooms</span><span class="p">[</span><span class="n">adj_rm_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">Room2D</span><span class="o">.</span><span class="n">join_room_2ds</span><span class="p">(</span>
                <span class="n">pair_rooms</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="n">adj_rm_id</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">all_rooms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">final_rooms</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">all_rooms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lone_merge_rooms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_rooms</span></div>


<div class="viewcode-block" id="Room2D.grouped_horizontal_boundary">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.grouped_horizontal_boundary">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">grouped_horizontal_boundary</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">min_separation</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a list of Face3D for the horizontal boundary around several Room2Ds.</span>

<span class="sd">        This method will attempt to produce a boundary that follows along the</span>
<span class="sd">        walls of the Room2Ds and it is not suitable for groups of Room2Ds that</span>
<span class="sd">        overlap one another in plan. This method may return an empty list if the</span>
<span class="sd">        min_separation is so large that a continuous boundary could not be determined</span>
<span class="sd">        or if overlaps between input Room2Ds result in failure.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds for which the horizontal boundary will</span>
<span class="sd">                be computed.</span>
<span class="sd">            min_separation: A number for the minimum distance between Room2Ds that</span>
<span class="sd">                is considered a meaningful separation. Gaps between Room2Ds that</span>
<span class="sd">                are less than this distance will be ignored and the boundary</span>
<span class="sd">                will continue across the gap. When the input Room2Ds have floor_geometry</span>
<span class="sd">                representing the boundaries defined by the interior wall finishes,</span>
<span class="sd">                this input can be thought of as the maximum interior wall thickness,</span>
<span class="sd">                which should be ignored in the calculation of the overall boundary</span>
<span class="sd">                of the Room2Ds. When Room2Ds are touching one another (with Room2D</span>
<span class="sd">                floor_geometry drawn to the center lines of interior walls), this</span>
<span class="sd">                value can be set to zero or anything less than or equal to the</span>
<span class="sd">                tolerance. Doing so will yield a cleaner result for the</span>
<span class="sd">                boundary, which will be faster. Note that care should be taken</span>
<span class="sd">                not to set this value higher than the length of any meaningful</span>
<span class="sd">                exterior wall segments. Otherwise, the exterior segments</span>
<span class="sd">                will be ignored in the result. This can be particularly dangerous</span>
<span class="sd">                around curved exterior walls that have been planarized through</span>
<span class="sd">                subdivision into small segments. (Default: 0).</span>
<span class="sd">            tolerance: The maximum difference between coordinate values of two</span>
<span class="sd">                vertices at which they can be considered equivalent. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the floor geometry of the rooms</span>
        <span class="n">floor_geos</span> <span class="o">=</span> <span class="p">[</span><span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span> <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">]</span>

        <span class="c1"># remove colinear vertices and degenerate rooms</span>
        <span class="n">clean_floor_geos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">geo</span> <span class="ow">in</span> <span class="n">floor_geos</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">clean_floor_geos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geo</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>  <span class="c1"># degenerate geometry to ignore</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clean_floor_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>  <span class="c1"># no Room boundary to be found</span>

        <span class="c1"># merge any rooms together that overlap with one another</span>
        <span class="n">room_groups</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">group_by_coplanar_overlap</span><span class="p">(</span><span class="n">clean_floor_geos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="n">clean_geos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">r_group</span> <span class="ow">in</span> <span class="n">room_groups</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">clean_geos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">r_group</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">union_faces</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">coplanar_union_all</span><span class="p">(</span>
                    <span class="n">r_group</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">union_faces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">clean_geos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">union_faces</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">clean_geos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">r_group</span><span class="p">)</span>

        <span class="c1"># convert the floor Face3Ds into counterclockwise Polygon2Ds</span>
        <span class="n">floor_polys</span><span class="p">,</span> <span class="n">z_vals</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">flr_geo</span> <span class="ow">in</span> <span class="n">clean_geos</span><span class="p">:</span>
            <span class="n">z_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flr_geo</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            <span class="n">b_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">boundary</span><span class="p">])</span>
            <span class="n">floor_polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b_poly</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">flr_geo</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                    <span class="n">h_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">])</span>
                    <span class="n">floor_polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">h_poly</span><span class="p">)</span>
        <span class="n">z_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">z_vals</span><span class="p">)</span>

        <span class="c1"># if the min_separation is small, use the more reliable intersection method</span>
        <span class="k">if</span> <span class="n">min_separation</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
            <span class="n">closed_polys</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">joined_intersected_boundary</span><span class="p">(</span><span class="n">floor_polys</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># otherwise, use the more intense and less reliable gap crossing method</span>
            <span class="n">closed_polys</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">gap_crossing_boundary</span><span class="p">(</span>
                <span class="n">floor_polys</span><span class="p">,</span> <span class="n">min_separation</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># remove colinear vertices from the resulting polygons</span>
        <span class="n">clean_polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">closed_polys</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">clean_polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># degenerate polygon to ignore</span>

        <span class="c1"># figure out if polygons represent holes in the others and make Face3D</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clean_polys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">clean_polys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># can be represented with a single Face3D</span>
            <span class="n">pts3d</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_min</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">clean_polys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">Face3D</span><span class="p">(</span><span class="n">pts3d</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># need to separate holes from distinct Face3Ds</span>
            <span class="n">bound_faces</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">clean_polys</span><span class="p">:</span>
                <span class="n">pts3d</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z_min</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">poly</span><span class="p">)</span>
                <span class="n">bound_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">pts3d</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">merge_faces_to_holes</span><span class="p">(</span><span class="n">bound_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.room_orientation_plane">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.room_orientation_plane">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">room_orientation_plane</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">angle_tolerance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Plane from the most frequently-occurring right angle across Room2Ds.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2Ds which will have their right-angles analyzed</span>
<span class="sd">                to determine an orientation plane from the most common right angle.</span>
<span class="sd">            angle_tolerance: A number in degrees for the maximum difference that</span>
<span class="sd">                a pair of Room2D segments can differ from a true right angle for</span>
<span class="sd">                it to be counted towards the computation of the orientation</span>
<span class="sd">                plane. (Default: 1 degree).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A ladybug-geometry Plane object derived from the input Room2Ds. If there</span>
<span class="sd">            were not enough right angles among the input Room2Ds to determine a</span>
<span class="sd">            plane, the World XY will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># define variables to be used throughout the evaluation</span>
        <span class="n">ang_tol</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">min_ang</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">ang_tol</span>
        <span class="n">max_ang</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">ang_tol</span>

        <span class="c1"># loop through the room_2ds and determine the possible y axes</span>
        <span class="n">plane_x_axes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list to hold all of the potential y axes</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_segments_2d</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">min_ang</span> <span class="o">&lt;</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_ang</span><span class="p">:</span>  <span class="c1"># right angle!</span>
                    <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x_vec</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span>
                    <span class="k">elif</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x_vec</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">x_vec</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">v</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">x_vec</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                    <span class="n">plane_x_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_vec</span><span class="o">.</span><span class="n">normalize</span><span class="p">())</span>

        <span class="c1"># determine the plane X-axis from the median values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">plane_x_axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Plane</span><span class="p">()</span>
        <span class="n">median_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plane_x_axes</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">x_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vec</span><span class="o">.</span><span class="n">x</span> <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">plane_x_axes</span><span class="p">]</span>
        <span class="n">y_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vec</span><span class="o">.</span><span class="n">y</span> <span class="k">for</span> <span class="n">vec</span> <span class="ow">in</span> <span class="n">plane_x_axes</span><span class="p">]</span>
        <span class="n">x_vals</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">y_vals</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">median_x_axis</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="n">x_vals</span><span class="p">[</span><span class="n">median_i</span><span class="p">],</span> <span class="n">y_vals</span><span class="p">[</span><span class="n">median_i</span><span class="p">])</span>

        <span class="c1"># determine a suitable plane origin</span>
        <span class="n">min_pt</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">bounding_box</span><span class="p">([</span><span class="n">r</span><span class="o">.</span><span class="n">floor_geometry</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Plane</span><span class="p">(</span><span class="n">o</span><span class="o">=</span><span class="n">min_pt</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">median_x_axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.generate_alignment_axes">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.generate_alignment_axes">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generate_alignment_axes</span><span class="p">(</span><span class="n">room_2ds</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">Vector2D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                <span class="n">angle_tolerance</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">filter_tolerance</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get suggested LineSegment2Ds for the Room2D.align method.</span>

<span class="sd">        This method will return the most common axes across the input Room2D</span>
<span class="sd">        geometry along with the number of Room2D segments that correspond to</span>
<span class="sd">        each axis. The latter can be used to filter the suggested alignment axes</span>
<span class="sd">        to get only the most common ones across the input Room2Ds.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_2ds: A list of Room2D objects for which common axes will be evaluated.</span>
<span class="sd">            distance: A number for the distance that will be used in the alignment</span>
<span class="sd">                operation. This will be used to determine the resolution at which</span>
<span class="sd">                alignment axes are generated and evaluated. Smaller alignment</span>
<span class="sd">                distances will result in the generation of more common_axes since</span>
<span class="sd">                a finer resolution can differentiate common that would typically be</span>
<span class="sd">                grouped together. For typical building geometry, an alignment distance</span>
<span class="sd">                of 0.3 meters or 1 foot is typically suitable for eliminating</span>
<span class="sd">                unwanted details while not changing the geometry too much from</span>
<span class="sd">                its original location.</span>
<span class="sd">            direction: A Vector2D object to represent the direction in which the</span>
<span class="sd">                common axes will be evaluated and generated.</span>
<span class="sd">            angle_tolerance: The max angle difference in degrees that the Room2D</span>
<span class="sd">                segment direction can differ from the input direction before the</span>
<span class="sd">                segments are not factored into this calculation of common axes.</span>
<span class="sd">            filter_tolerance: A number that can be used to filter out axes in the</span>
<span class="sd">                result, which are already perfectly aligned with the input polygon</span>
<span class="sd">                segments. Setting this to zero wil guarantee that no axes are</span>
<span class="sd">                filtered out no matter how close they are to the existing polygon</span>
<span class="sd">                segments. (Default: 0).</span>

<span class="sd">            Returns:</span>
<span class="sd">                A tuple with two elements.</span>

<span class="sd">            -   common_axes: A list of LineSegment2D objects for the common</span>
<span class="sd">                axes across the input Room2Ds.</span>

<span class="sd">            -   axis_values: A list of integers that aligns with the common_axes</span>
<span class="sd">                and denotes how many segments of the input Room2D each axis</span>
<span class="sd">                relates to. Higher numbers indicate that that the axis is more</span>
<span class="sd">                commonly aligned across the Room2Ds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process the inputs</span>
        <span class="n">min_distance</span><span class="p">,</span> <span class="n">merge_distance</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="mi">4</span><span class="p">,</span> <span class="n">distance</span>
        <span class="n">ang_tol</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle_tolerance</span><span class="p">)</span>
        <span class="n">polygons</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">room_2ds</span><span class="p">:</span>
            <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">hole_polygon2d</span><span class="p">:</span>
                    <span class="n">polygons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
        <span class="c1"># return the common axes and values</span>
        <span class="k">return</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">common_axes</span><span class="p">(</span>
            <span class="n">polygons</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">min_distance</span><span class="p">,</span> <span class="n">merge_distance</span><span class="p">,</span> <span class="n">ang_tol</span><span class="p">,</span> <span class="n">filter_tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="Room2D.floor_segment_by_index">
<a class="viewcode-back" href="../../dragonfly.room2d.html#dragonfly.room2d.Room2D.floor_segment_by_index">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">floor_segment_by_index</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">segment_index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a particular LineSegment3D from a Face3D object.</span>

<span class="sd">        The logic applied by this method to select the segment is the same that is</span>
<span class="sd">        used to assign lists of values to the floor_geometry (eg. boundary conditions).</span>

<span class="sd">        Args:</span>
<span class="sd">            geometry: A Face3D representing floor geometry.</span>
<span class="sd">            segment_index: An integer for the index of the segment to return.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">segs</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">holes</span> <span class="ow">is</span> \
            <span class="kc">None</span> <span class="k">else</span> <span class="n">geometry</span><span class="o">.</span><span class="n">boundary_segments</span> <span class="o">+</span> \
            <span class="nb">tuple</span><span class="p">(</span><span class="n">seg</span> <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">geometry</span><span class="o">.</span><span class="n">hole_segments</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">segs</span><span class="p">[</span><span class="n">segment_index</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_room_volume_with_roof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roof_spec</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Polyface3D for the Room volume given a roof_spec above the room.</span>

<span class="sd">        Args:</span>
<span class="sd">            roof_spec: A Dragonfly RoofSpecification that describes the Roof</span>
<span class="sd">                above the room geometry.</span>
<span class="sd">            tolerance: The minimum distance from roof polygon edges at which a</span>
<span class="sd">                point is considered to lie on the edge.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with the three items below.</span>

<span class="sd">            * room_polyface -- A Polyface3D object for the Room volume. This will</span>
<span class="sd">                be None whenever the Room has no Roof geometries above it or the</span>
<span class="sd">                roof calculation otherwise failed.</span>

<span class="sd">            * roof_face_i -- A list of integers for the indices of the faces in</span>
<span class="sd">                the Polyface3D that correspond to the roof. Will be None whenever</span>
<span class="sd">                the roof is not successfully applied to the Room.</span>

<span class="sd">            * ex_wall_i -- A set of integers for the indices of the wall segments</span>
<span class="sd">                that were excluded from the room polyface. This can be used to</span>
<span class="sd">                ensure that windows and boundary conditions are assigned to the</span>
<span class="sd">                correct Face of the polyface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the roof polygons and the bounding Room2D polygon</span>
        <span class="n">roof_polys</span> <span class="o">=</span> <span class="n">roof_spec</span><span class="o">.</span><span class="n">boundary_geometry_2d</span>
        <span class="n">roof_planes</span> <span class="o">=</span> <span class="n">roof_spec</span><span class="o">.</span><span class="n">planes</span>
        <span class="n">room_pts2d</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">]</span>
        <span class="n">room_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">(</span><span class="n">room_pts2d</span><span class="p">)</span>
        <span class="n">ex_wall_i</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># gather all of the relevant roof polygons for the Room2D</span>
        <span class="n">rel_rf_polys</span><span class="p">,</span> <span class="n">rel_rf_planes</span><span class="p">,</span> <span class="n">is_full_bound</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">rf_py</span><span class="p">,</span> <span class="n">rf_pl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">roof_polys</span><span class="p">,</span> <span class="n">roof_planes</span><span class="p">):</span>
            <span class="n">poly_rel</span> <span class="o">=</span> <span class="n">rf_py</span><span class="o">.</span><span class="n">polygon_relationship</span><span class="p">(</span><span class="n">room_poly</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">poly_rel</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rel_rf_polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rf_py</span><span class="p">)</span>
                <span class="n">rel_rf_planes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rf_pl</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">poly_rel</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># simple solution of one roof</span>
                <span class="n">is_full_bound</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">rel_rf_polys</span> <span class="o">=</span> <span class="p">[</span><span class="n">rel_rf_polys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">rel_rf_planes</span> <span class="o">=</span> <span class="p">[</span><span class="n">rel_rf_planes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">break</span>

        <span class="c1"># make the room volume</span>
        <span class="n">p_faces</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">flip</span><span class="p">()]</span>  <span class="c1"># a list of Room volume faces</span>
        <span class="n">proj_dir</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># direction to project onto Roof planes</span>

        <span class="c1"># when fully bounded, simply project the segments onto the single Roof face</span>
        <span class="k">if</span> <span class="n">is_full_bound</span><span class="p">:</span>
            <span class="n">roof_plane</span> <span class="o">=</span> <span class="n">rel_rf_planes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">roof_verts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">:</span>
                <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span>
                <span class="n">p3</span> <span class="o">=</span> <span class="n">roof_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">proj_dir</span><span class="p">)</span>
                <span class="n">p4</span> <span class="o">=</span> <span class="n">roof_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">proj_dir</span><span class="p">)</span>
                <span class="n">p_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">)))</span>
                <span class="n">roof_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p4</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                <span class="n">p_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">roof_verts</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
                <span class="n">part_roof_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">roof_verts</span><span class="p">[:</span><span class="n">v_count</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                    <span class="n">part_roof_verts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roof_verts</span><span class="p">[</span><span class="n">v_count</span><span class="p">:</span><span class="n">v_count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)])</span>
                    <span class="n">v_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
                <span class="n">p_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">part_roof_verts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">holes</span><span class="o">=</span><span class="n">part_roof_verts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">p_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="n">roof_face_i</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>  <span class="c1"># roof is touching a floor segment</span>
                <span class="n">tol</span> <span class="o">=</span> <span class="n">tolerance</span>
                <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">ex_wall_i</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_separate_disconnected_faces</span><span class="p">(</span><span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>
                    <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">merge_overlapping_edges</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">p_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">),</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">ex_wall_i</span>

        <span class="c1"># when multiple roofs, each segment must be intersected with the roof polygons</span>
        <span class="c1"># gather polygons that account for all of the Room2D holes</span>
        <span class="n">all_room_poly</span> <span class="o">=</span> <span class="p">[</span><span class="n">room_poly</span><span class="p">]</span>
        <span class="n">flr_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">v_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_poly</span><span class="p">)</span>
            <span class="n">all_segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">flr_segs</span><span class="p">[:</span><span class="n">v_count</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="n">hole_poly</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="p">([</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">])</span>
                <span class="n">all_room_poly</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole_poly</span><span class="p">)</span>
                <span class="n">all_segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flr_segs</span><span class="p">[</span><span class="n">v_count</span><span class="p">:</span><span class="n">v_count</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)])</span>
                <span class="n">v_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">flr_segs</span><span class="p">]</span>

        <span class="c1"># get the roof faces using polygon boolean operations</span>
        <span class="n">roof_faces</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_roof_faces</span><span class="p">(</span>
            <span class="n">all_room_poly</span><span class="p">,</span> <span class="n">rel_rf_polys</span><span class="p">,</span> <span class="n">rel_rf_planes</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">roof_faces</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># invalid roof geometry</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># create the walls from the segments by intersecting them with the roof</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">roof_faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">rel_rf_polys</span><span class="p">):</span>  <span class="c1"># new roofs added; rebuild polygons</span>
            <span class="n">rel_rf_polys</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">Polygon2D</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">Point2D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">geo</span><span class="o">.</span><span class="n">boundary</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">geo</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">]</span>
            <span class="n">rel_rf_planes</span> <span class="o">=</span> <span class="p">[</span><span class="n">geo</span><span class="o">.</span><span class="n">plane</span> <span class="k">for</span> <span class="n">geo</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">]</span>
        <span class="n">walls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wall_faces_with_roof</span><span class="p">(</span>
            <span class="n">all_room_poly</span><span class="p">,</span> <span class="n">all_segments</span><span class="p">,</span> <span class="n">rel_rf_polys</span><span class="p">,</span> <span class="n">rel_rf_planes</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">walls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># invalid roof geometry</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

        <span class="c1"># combine all of the room volume faces together</span>
        <span class="n">p_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">walls</span><span class="p">)</span>
        <span class="n">roof_face_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">roof_faces</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">p_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">roof_faces</span><span class="p">)</span>

        <span class="c1"># create the Polyface3D and try to repair it if it is not solid</span>
        <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">p_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># make sure that overlapping edges are merged so we don&#39;t get false readings</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>
            <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">merge_overlapping_edges</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># try to patch any vertical gaps between roofs with new walls</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_polyface</span><span class="o">.</span><span class="n">naked_edges</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_patch_vertical_gaps</span><span class="p">(</span><span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>
                <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">merge_overlapping_edges</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># remove disconnected roof geometries from the Polyface (eg. dormers)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>
            <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">ex_wall_i</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_separate_disconnected_faces</span><span class="p">(</span><span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>
                <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">merge_overlapping_edges</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># lastly, try to patch any remaining planar holes by capping them</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_polyface</span><span class="o">.</span><span class="n">naked_edges</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_cap_planar_holes</span><span class="p">(</span><span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">is_solid</span><span class="p">:</span>
                <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">merge_overlapping_edges</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">ex_wall_i</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_roof_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_room_poly</span><span class="p">,</span> <span class="n">rel_rf_polys</span><span class="p">,</span> <span class="n">rel_rf_planes</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Face3D for the Room Roofs when there are multiple Roof Polygons.</span>

<span class="sd">        Args:</span>
<span class="sd">            all_room_poly: A list of Polygon2D where each polygon represents either</span>
<span class="sd">                the boundary of the room or a hole.</span>
<span class="sd">            rel_rf_polys: A list of Polygon2D for the Roof geometries that are</span>
<span class="sd">                relevant to the Room2D.</span>
<span class="sd">            rel_rf_planes: A list of Plane objects for each Roof geometry that</span>
<span class="sd">                is relevant to the Room2D.</span>
<span class="sd">            tolerance: The distance value for absolute tolerance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Face3D for the Roofs of the Room. Will be None if computing</span>
<span class="sd">            the roof geometry failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">roof_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">proj_dir</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># direction to project onto Roof planes</span>

        <span class="c1"># create a BooleanPolygon for the Room2D</span>
        <span class="n">room_polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rom_poly</span> <span class="ow">in</span> <span class="n">all_room_poly</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rom_poly</span> <span class="o">=</span> <span class="n">rom_poly</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># degenerate polygon to ignore (usually degenerate hole)</span>
            <span class="n">room_polys</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pb</span><span class="o">.</span><span class="n">BooleanPoint</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">rom_poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_polys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># completely degenerate room</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">b_room_poly</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">BooleanPolygon</span><span class="p">(</span><span class="n">room_polys</span><span class="p">)</span>
        <span class="n">room_poly_area</span> <span class="o">=</span> <span class="n">all_room_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">all_room_poly</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="c1"># find the boolean intersection with each roof polygon and project the result</span>
        <span class="n">int_tol</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="o">/</span> <span class="mi">100</span>  <span class="c1"># intersection tolerance must be finer</span>
        <span class="n">roof_poly_area</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">rf_poly</span><span class="p">,</span> <span class="n">rf_plane</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rel_rf_polys</span><span class="p">,</span> <span class="n">rel_rf_planes</span><span class="p">):</span>
            <span class="c1"># snap the polygons to one another to avoid tolerance issues</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">rf_poly</span> <span class="o">=</span> <span class="n">rf_poly</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># degenerate roof polygon to ignore</span>
            <span class="k">for</span> <span class="n">rom_poly</span> <span class="ow">in</span> <span class="n">all_room_poly</span><span class="p">:</span>
                <span class="n">rf_poly</span> <span class="o">=</span> <span class="n">rom_poly</span><span class="o">.</span><span class="n">snap_to_polygon</span><span class="p">(</span><span class="n">rf_poly</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="n">rf_pts</span> <span class="o">=</span> <span class="p">(</span><span class="n">pb</span><span class="o">.</span><span class="n">BooleanPoint</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">rf_poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">b_rf_poly</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">BooleanPolygon</span><span class="p">([</span><span class="n">rf_pts</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">int_result</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">b_room_poly</span><span class="p">,</span> <span class="n">b_rf_poly</span><span class="p">,</span> <span class="n">int_tol</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  <span class="c1"># intersection failed for some reason</span>
                <span class="c1"># tiny edge caused a failure; try one more time with small tol</span>
                <span class="n">int_tol</span> <span class="o">=</span> <span class="n">int_tol</span> <span class="o">/</span> <span class="mi">100</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">int_result</span> <span class="o">=</span> <span class="n">pb</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">b_room_poly</span><span class="p">,</span> <span class="n">b_rf_poly</span><span class="p">,</span> <span class="n">int_tol</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>   <span class="c1"># the edge is just too tiny</span>
            <span class="n">polys</span> <span class="o">=</span> <span class="n">Polygon2D</span><span class="o">.</span><span class="n">_from_bool_poly</span><span class="p">(</span><span class="n">int_result</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">has_holes</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># sort the polygons by area and check if any are inside the others</span>
                <span class="n">polys</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">poly_groups</span> <span class="o">=</span> <span class="p">[[</span><span class="n">polys</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
                <span class="k">for</span> <span class="n">sub_poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">poly_groups</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">pg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_polygon_inside</span><span class="p">(</span><span class="n">sub_poly</span><span class="p">):</span>  <span class="c1"># it&#39;s a hole</span>
                            <span class="n">poly_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_poly</span><span class="p">)</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># it&#39;s a separate Face3D</span>
                        <span class="n">poly_groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">sub_poly</span><span class="p">])</span>
                <span class="c1"># convert all vertices to 3D and append the roof Face3D</span>
                <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="n">poly_groups</span><span class="p">:</span>
                    <span class="n">roof_poly_area</span> <span class="o">+=</span> <span class="n">pg</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">area</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">pg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">pg_3d</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">shp</span> <span class="ow">in</span> <span class="n">pg</span><span class="p">:</span>
                        <span class="n">pt3s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                            <span class="n">rf_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">Point3D</span><span class="o">.</span><span class="n">from_point2d</span><span class="p">(</span><span class="n">pt2</span><span class="p">),</span> <span class="n">proj_dir</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">pt2</span> <span class="ow">in</span> <span class="n">shp</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                        <span class="n">pg_3d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt3s</span><span class="p">)</span>
                    <span class="n">roof_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">pg_3d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rf_plane</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">pg_3d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># no holes are possible in the result; project all polygons directly</span>
                <span class="k">for</span> <span class="n">sub_poly</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
                    <span class="n">roof_poly_area</span> <span class="o">+=</span> <span class="n">sub_poly</span><span class="o">.</span><span class="n">area</span>
                    <span class="n">pt3s</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                        <span class="n">rf_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">Point3D</span><span class="o">.</span><span class="n">from_point2d</span><span class="p">(</span><span class="n">pt2</span><span class="p">),</span> <span class="n">proj_dir</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">pt2</span> <span class="ow">in</span> <span class="n">sub_poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
                    <span class="n">roof_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">pt3s</span><span class="p">,</span> <span class="n">rf_plane</span><span class="p">))</span>

        <span class="c1"># if all of the polygons didn&#39;t cover the Room2D, add extra horizontal roof faces</span>
        <span class="n">sort_lens</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">all_room_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">segments</span><span class="p">)</span>
        <span class="n">max_len</span> <span class="o">=</span> <span class="n">sort_lens</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="n">sort_lens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">min_len</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="k">if</span> <span class="n">min_len</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="k">else</span> <span class="n">min_len</span>
        <span class="n">tol_area</span> <span class="o">=</span> <span class="n">min_len</span> <span class="o">*</span> <span class="n">tolerance</span>
        <span class="n">area_diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">room_poly_area</span> <span class="o">-</span> <span class="n">roof_poly_area</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">room_poly_area</span> <span class="o">-</span> <span class="n">roof_poly_area</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tol_area</span><span class="p">:</span>  <span class="c1"># room not covered by roofs</span>
            <span class="n">rm_z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_height</span>
            <span class="n">subtract_geo</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rf_face</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">:</span>
                <span class="n">proj_pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rm_z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">rf_face</span><span class="o">.</span><span class="n">boundary</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">rf_face</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
                    <span class="n">hole_pts</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rm_z</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">hole</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">rf_face</span><span class="o">.</span><span class="n">holes</span><span class="p">]</span>
                    <span class="n">subtract_geo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">proj_pts</span><span class="p">,</span> <span class="n">holes</span><span class="o">=</span><span class="n">hole_pts</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subtract_geo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">proj_pts</span><span class="p">))</span>
            <span class="n">ang_tol</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">ceil_vec</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">)</span>
            <span class="n">ceil_geo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_geometry</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">ceil_vec</span><span class="p">)</span>
            <span class="c1"># first attempt a coplanar difference with all geometry together</span>
            <span class="n">cover_faces</span> <span class="o">=</span> <span class="n">ceil_geo</span><span class="o">.</span><span class="n">coplanar_difference</span><span class="p">(</span><span class="n">subtract_geo</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">ang_tol</span><span class="p">)</span>
            <span class="n">up_tol_area</span> <span class="o">=</span> <span class="n">max_len</span> <span class="o">*</span> <span class="n">tolerance</span>
            <span class="n">all_fail</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">cover_faces</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">area</span> <span class="o">&lt;=</span> <span class="n">area_diff</span> <span class="o">+</span> <span class="n">up_tol_area</span><span class="p">:</span>
                    <span class="n">roof_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="n">all_fail</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># if all of them failed, try subtracting them individually</span>
            <span class="k">if</span> <span class="n">all_fail</span><span class="p">:</span>
                <span class="n">cover_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">ceil_geo</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">sub_geo</span> <span class="ow">in</span> <span class="n">subtract_geo</span><span class="p">:</span>
                    <span class="n">new_cover</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">c_geo</span> <span class="ow">in</span> <span class="n">cover_faces</span><span class="p">:</span>
                        <span class="n">cf</span> <span class="o">=</span> <span class="n">c_geo</span><span class="o">.</span><span class="n">coplanar_difference</span><span class="p">([</span><span class="n">sub_geo</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">ang_tol</span><span class="p">)</span>
                        <span class="n">new_cover</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span>
                    <span class="n">cover_faces</span> <span class="o">=</span> <span class="n">new_cover</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">cover_faces</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">area</span> <span class="o">&lt;=</span> <span class="n">area_diff</span> <span class="o">+</span> <span class="n">up_tol_area</span><span class="p">:</span>
                        <span class="n">roof_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># perform a final check to remove all colinear vertices from the roof</span>
        <span class="n">clean_roofs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">roof_face</span> <span class="ow">in</span> <span class="n">roof_faces</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">clean_roofs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">roof_face</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># degenerate face to ignore</span>

        <span class="c1"># merge coplanar faces across the roofs if they exist</span>
        <span class="n">coplanar_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">clean_roofs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plane</span><span class="p">:</span> <span class="p">[</span><span class="n">clean_roofs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]}</span>
        <span class="k">for</span> <span class="n">geo</span> <span class="ow">in</span> <span class="n">clean_roofs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">for</span> <span class="n">pln</span><span class="p">,</span> <span class="n">f_list</span> <span class="ow">in</span> <span class="n">coplanar_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">geo</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">is_coplanar</span><span class="p">(</span><span class="n">pln</span><span class="p">):</span>
                    <span class="n">f_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geo</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># the first face with this type of plane</span>
                <span class="n">coplanar_dict</span><span class="p">[</span><span class="n">geo</span><span class="o">.</span><span class="n">plane</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">geo</span><span class="p">]</span>
        <span class="n">clean_roof_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f_geos</span> <span class="ow">in</span> <span class="n">coplanar_dict</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_geos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># no faces to merge</span>
                <span class="n">clean_roof_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_geos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># there are faces to merge</span>
                <span class="n">clean_roof_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">Face3D</span><span class="o">.</span><span class="n">join_coplanar_faces</span><span class="p">(</span><span class="n">f_geos</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">clean_roof_faces</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_wall_faces_with_roof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_room_poly</span><span class="p">,</span> <span class="n">all_segments</span><span class="p">,</span>
                              <span class="n">rel_rf_polys</span><span class="p">,</span> <span class="n">rel_rf_planes</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Face3D for the Room Walls when there are multiple Roof Polygons.</span>

<span class="sd">        Args:</span>
<span class="sd">            all_room_poly: A list of Polygon2D where each polygon represents either</span>
<span class="sd">                the boundary of the room or a hole.</span>
<span class="sd">            all_segments: A list of lists where each sub-list contains LineSegment2D</span>
<span class="sd">                objects for each polygon in all_room_poly.</span>
<span class="sd">            rel_rf_polys: A list of Polygon2D for the Roof geometries that are</span>
<span class="sd">                relevant to the Room2D.</span>
<span class="sd">            rel_rf_planes: A list of Plane objects for each Roof geometry that</span>
<span class="sd">                is relevant to the Room2D.</span>
<span class="sd">            tolerance: The distance value for absolute tolerance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of Face3D for the Walls of the Room. Will be None if the Roof</span>
<span class="sd">            geometries are invalid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># establish variables to be used throughout the calculation</span>
        <span class="n">wall_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">proj_dir</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># direction to project onto Roof planes</span>
        <span class="c1"># get the relative tolerance using a log function</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rtol</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">rtol</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the tol is equal to 1 (out of range for log)</span>

        <span class="c1"># loop through holes and boundary polygons and generate walls from them</span>
        <span class="k">for</span> <span class="n">rm_poly</span><span class="p">,</span> <span class="n">rm_segs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">all_room_poly</span><span class="p">,</span> <span class="n">all_segments</span><span class="p">):</span>
            <span class="n">pt1</span> <span class="o">=</span> <span class="n">rm_poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># start with the first vertex of the room polygon</span>
            <span class="n">rot_poly</span> <span class="o">=</span> <span class="n">rm_poly</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt1</span><span class="p">,)</span>

            <span class="c1"># loop through segments and make a wall face for each one</span>
            <span class="k">for</span> <span class="n">pt2</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rot_poly</span><span class="p">,</span> <span class="n">rm_segs</span><span class="p">):</span>
                <span class="c1"># find the polygon that the first segment vertex is located in</span>
                <span class="n">current_poly</span><span class="p">,</span> <span class="n">current_plane</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                <span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span> <span class="o">=</span> <span class="n">rel_rf_polys</span><span class="p">[:],</span> <span class="n">rel_rf_planes</span><span class="p">[:]</span>  <span class="c1"># copy lists</span>
                <span class="c1"># sort the roof polygons by Z to ensure lower roof polygons are first</span>
                <span class="n">pt1_3</span> <span class="o">=</span> <span class="n">Point3D</span><span class="p">(</span><span class="n">pt1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt1</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">zs</span> <span class="o">=</span> <span class="p">[</span><span class="n">rf_pl</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">pt1_3</span><span class="p">,</span> <span class="n">proj_dir</span><span class="p">)</span><span class="o">.</span><span class="n">z</span> <span class="k">for</span> <span class="n">rf_pl</span> <span class="ow">in</span> <span class="n">other_planes</span><span class="p">]</span>
                <span class="n">sort_obj</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">zs</span><span class="p">,</span> <span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">zs</span><span class="p">,</span> <span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sort_obj</span><span class="p">)</span>
                <span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other_poly</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">other_planes</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rf_py</span><span class="p">,</span> <span class="n">rf_pl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">rf_py</span><span class="o">.</span><span class="n">point_relationship</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">current_poly</span><span class="p">,</span> <span class="n">current_plane</span> <span class="o">=</span> <span class="n">rf_py</span><span class="p">,</span> <span class="n">rf_pl</span>
                        <span class="n">other_poly</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">other_planes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">current_poly</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># first point not inside a roof, invalid roof</span>
                    <span class="k">return</span> <span class="kc">None</span>

                <span class="c1"># start building the wall face</span>
                <span class="n">face_pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">]</span>
                <span class="n">seg_2d</span> <span class="o">=</span> <span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_array</span><span class="p">(((</span><span class="n">pt1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt1</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="n">pt2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt2</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>
                <span class="n">int_pts</span><span class="p">,</span> <span class="n">int_pls</span> <span class="o">=</span> <span class="p">[(</span><span class="n">seg_2d</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> <span class="p">[</span><span class="n">current_plane</span><span class="p">]</span>
                <span class="c1"># find where the segment leaves the polygon</span>
                <span class="k">for</span> <span class="n">rf_seg</span> <span class="ow">in</span> <span class="n">current_poly</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                    <span class="n">int_pt</span> <span class="o">=</span> <span class="n">seg_2d</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">rf_seg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">dist</span><span class="p">,</span> <span class="n">cls_pts</span> <span class="o">=</span> <span class="n">closest_point2d_between_line2d</span><span class="p">(</span><span class="n">seg_2d</span><span class="p">,</span> <span class="n">rf_seg</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                            <span class="n">int_pt</span> <span class="o">=</span> <span class="n">cls_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">int_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">int_pt</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                        <span class="n">int_pls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_plane</span><span class="p">)</span>

                <span class="c1"># if the segment ends in the same face it starts, the solution is simple</span>
                <span class="n">pts_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="nb">round</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rtol</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rtol</span><span class="p">)))</span>
                              <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">int_pts</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts_set</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="ow">and</span> \
                        <span class="n">current_poly</span><span class="o">.</span><span class="n">point_relationship</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">face_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">proj_dir</span><span class="p">))</span>
                    <span class="n">face_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_plane</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">proj_dir</span><span class="p">))</span>
                    <span class="n">wall_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">face_pts</span><span class="p">))</span>  <span class="c1"># make the final Face3D</span>
                    <span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span>  <span class="c1"># increment for next segment</span>
                    <span class="k">continue</span>

                <span class="c1"># otherwise, we must find where it intersects the other roof polygons</span>
                <span class="k">for</span> <span class="n">pi</span><span class="p">,</span> <span class="p">(</span><span class="n">o_poly</span><span class="p">,</span> <span class="n">o_pl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">o_seg</span> <span class="ow">in</span> <span class="n">o_poly</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
                        <span class="n">dist_1</span> <span class="o">=</span> <span class="n">o_seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2d</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span>
                        <span class="n">dist_2</span> <span class="o">=</span> <span class="n">o_seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg_2d</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
                        <span class="n">dist_3</span> <span class="o">=</span> <span class="n">seg_2d</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">o_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span>
                        <span class="n">dist_4</span> <span class="o">=</span> <span class="n">seg_2d</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">o_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
                        <span class="n">dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">dist_1</span><span class="p">,</span> <span class="n">dist_2</span><span class="p">,</span> <span class="n">dist_3</span><span class="p">,</span> <span class="n">dist_4</span><span class="p">]</span>
                        <span class="n">pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_2d</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg_2d</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">o_seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">o_seg</span><span class="o">.</span><span class="n">p2</span><span class="p">]</span>
                        <span class="n">co_pts</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span> <span class="k">for</span> <span class="n">pt</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="n">dists</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">co_pts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="c1"># segments are colinear and overlap; add both points</span>
                            <span class="k">for</span> <span class="n">co_pt</span> <span class="ow">in</span> <span class="n">co_pts</span><span class="p">:</span>
                                <span class="n">int_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">co_pt</span><span class="p">,</span> <span class="n">pi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                                <span class="n">int_pls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o_pl</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">int_pt</span> <span class="o">=</span> <span class="n">seg_2d</span><span class="o">.</span><span class="n">intersect_line_ray</span><span class="p">(</span><span class="n">o_seg</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">d</span><span class="p">,</span> <span class="n">cls_pts</span> <span class="o">=</span> <span class="n">closest_point2d_between_line2d</span><span class="p">(</span><span class="n">seg_2d</span><span class="p">,</span> <span class="n">o_seg</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                                    <span class="n">int_pt</span> <span class="o">=</span> <span class="n">cls_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">int_pt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">int_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">int_pt</span><span class="p">,</span> <span class="n">pi</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                                <span class="n">int_pls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o_pl</span><span class="p">)</span>

                <span class="c1"># add a vertex for where the segment ends in the polygon</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">rf_py</span><span class="p">,</span> <span class="n">rf_pl</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">other_poly</span><span class="p">,</span> <span class="n">other_planes</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">rf_py</span><span class="o">.</span><span class="n">point_relationship</span><span class="p">(</span><span class="n">pt2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">int_pts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">pt2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="n">int_pls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rf_pl</span><span class="p">)</span>
                        <span class="k">break</span>

                <span class="c1"># remove any duplicates among the intersection points</span>
                <span class="n">int_set</span><span class="p">,</span> <span class="n">clean_int_pts</span><span class="p">,</span> <span class="n">clean_int_pls</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">ipl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">int_pts</span><span class="p">,</span> <span class="n">int_pls</span><span class="p">):</span>
                    <span class="n">str_pt</span> <span class="o">=</span> <span class="nb">str</span><span class="p">((</span><span class="nb">round</span><span class="p">(</span><span class="n">ipt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rtol</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">ipt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rtol</span><span class="p">),</span> <span class="n">ipt</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">str_pt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">int_set</span><span class="p">:</span>
                        <span class="n">clean_int_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ipt</span><span class="p">)</span>
                        <span class="n">clean_int_pls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ipl</span><span class="p">)</span>
                    <span class="n">int_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">str_pt</span><span class="p">)</span>
                <span class="n">int_pts</span><span class="p">,</span> <span class="n">int_pls</span> <span class="o">=</span> <span class="n">clean_int_pts</span><span class="p">,</span> <span class="n">clean_int_pls</span>

                <span class="c1"># sort the intersection points along the segment</span>
                <span class="n">pt_dists</span> <span class="o">=</span> <span class="p">[(</span><span class="n">seg_2d</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">ipt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ipt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">ipt</span> <span class="ow">in</span> <span class="n">int_pts</span><span class="p">]</span>
                <span class="n">pts_pls</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="p">(</span><span class="n">ipl</span><span class="o">.</span><span class="n">project_point</span><span class="p">(</span><span class="n">Point3D</span><span class="o">.</span><span class="n">from_point2d</span><span class="p">(</span><span class="n">ipt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">proj_dir</span><span class="p">),</span> <span class="n">ipt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">ipt</span><span class="p">,</span> <span class="n">ipl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">int_pts</span><span class="p">,</span> <span class="n">int_pls</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">sort_obj</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">pt_dists</span><span class="p">,</span> <span class="n">pts_pls</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># group the intersection points together that are equivalent in tolerance</span>
                <span class="n">pt_groups</span><span class="p">,</span> <span class="n">prev_dist</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sort_obj</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]],</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">((</span><span class="n">dist</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">pt_tup</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sort_obj</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dist</span> <span class="o">-</span> <span class="n">prev_dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span><span class="p">:</span>
                        <span class="n">pt_groups</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt_tup</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># the start of a new point group</span>
                        <span class="n">pt_groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pt_tup</span><span class="p">])</span>
                    <span class="n">prev_dist</span> <span class="o">=</span> <span class="n">dist</span>

                <span class="c1"># move through each group and connect the points along common roof polys</span>
                <span class="n">rf_pts</span><span class="p">,</span> <span class="n">rf_ids</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pt_grp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pt_groups</span><span class="p">):</span>
                    <span class="c1"># determine the start point of the group</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># we can just pick the very first vertex</span>
                        <span class="n">st_pt</span><span class="p">,</span> <span class="n">rf_id</span> <span class="o">=</span> <span class="n">pt_grp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># base it on the previous group</span>
                        <span class="n">st_pts</span><span class="p">,</span> <span class="n">pt_ids</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">c_pt</span> <span class="ow">in</span> <span class="n">pt_grp</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">p_pt</span> <span class="ow">in</span> <span class="n">pt_groups</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]:</span>
                                <span class="k">if</span> <span class="n">c_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">p_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                    <span class="n">st_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_pt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                                    <span class="n">pt_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c_pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># a single connection; best result</span>
                            <span class="n">st_pt</span><span class="p">,</span> <span class="n">rf_id</span> <span class="o">=</span> <span class="n">st_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">st_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># failed to connect points; not a good sign</span>
                            <span class="n">st_pt</span><span class="p">,</span> <span class="n">rf_id</span> <span class="o">=</span> <span class="n">pt_grp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># multiple possible connections; find the best fit</span>
                            <span class="k">for</span> <span class="n">spt</span><span class="p">,</span> <span class="n">rid</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">st_pts</span><span class="p">,</span> <span class="n">pt_ids</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">rid</span> <span class="o">==</span> <span class="n">rf_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                                    <span class="n">st_pt</span><span class="p">,</span> <span class="n">rf_id</span> <span class="o">=</span> <span class="n">spt</span><span class="p">,</span> <span class="n">rid</span>
                                    <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">st_pt</span><span class="p">,</span> <span class="n">rf_id</span> <span class="o">=</span> <span class="n">st_pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pt_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">rf_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">st_pt</span><span class="p">)</span>
                    <span class="n">rf_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rf_id</span><span class="p">)</span>
                    <span class="c1"># add an extra point if there are any vertical jumps in the group</span>
                    <span class="n">z_diffs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">st_pt</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">pt3</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">pt3</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pt_grp</span><span class="p">]</span>
                    <span class="n">sort_z</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">z_diffs</span><span class="p">,</span> <span class="n">pt_grp</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">sort_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                        <span class="n">rf_pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">rf_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sort_z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># add the points to the Face3D vertices</span>
                <span class="n">rf_pts</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">face_pts</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rf_pts</span><span class="p">)</span>
                <span class="c1"># make the final Face3D</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">face_pts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># second point not inside a roof, invalid roof</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="n">wall_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Face3D</span><span class="p">(</span><span class="n">face_pts</span><span class="p">))</span>
                <span class="n">pt1</span> <span class="o">=</span> <span class="n">pt2</span>  <span class="c1"># increment for next segment</span>

        <span class="k">return</span> <span class="n">wall_faces</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_patch_vertical_gaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Patch any vertical gaps in a room_polyface.</span>

<span class="sd">        This method should fill all cases of vertical gaps within a Polyface3D.</span>
<span class="sd">        The only exception is if the vertical gap happens between two edges that</span>
<span class="sd">        overlap in plan but they share no end points. To catch this particular</span>
<span class="sd">        type of edge case, the _cap_planar_holes method should be used.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_polyface: The non-solid Polyface3D to be patched with planar</span>
<span class="sd">                vertical Faces.</span>
<span class="sd">            roof_face_i: The indices of the polyface that correspond to the roof.</span>
<span class="sd">            tolerance: The distance value for absolute tolerance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The patched Room Polyface3D followed by an updated list of face indices</span>
<span class="sd">            that should become Roofs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the faces and naked edges</span>
        <span class="n">p_faces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">room_polyface</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">ed</span> <span class="k">for</span> <span class="n">ed</span> <span class="ow">in</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">naked_edges</span>
                 <span class="k">if</span> <span class="ow">not</span> <span class="n">ed</span><span class="o">.</span><span class="n">is_vertical</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)]</span>
        <span class="n">vertical_faces</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through the naked edges and try to match them</span>
        <span class="n">matched_segs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">edge_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">edge_1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
            <span class="n">edge_1_2d</span> <span class="o">=</span> <span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span>
                <span class="n">Point2D</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_1</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_1</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            <span class="n">other_edges</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">other_is</span> <span class="o">=</span> <span class="n">edge_indices</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">edge_indices</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="k">for</span> <span class="n">oi</span><span class="p">,</span> <span class="n">edge_2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">other_is</span><span class="p">,</span> <span class="n">other_edges</span><span class="p">):</span>
                <span class="n">e2p1</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">e2p2</span> <span class="o">=</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">edge_1_2d</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">e2p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                        <span class="n">edge_1_2d</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">e2p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># check to be sure that the segments have not been paired already</span>
                    <span class="n">edge_pair_1</span><span class="p">,</span> <span class="n">edge_pair_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">oi</span><span class="p">),</span> <span class="p">(</span><span class="n">oi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">edge_pair_1</span> <span class="ow">in</span> <span class="n">matched_segs</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">matched_segs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_pair_1</span><span class="p">)</span>
                    <span class="n">matched_segs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_pair_2</span><span class="p">)</span>
                    <span class="c1"># build the points of the vertical face</span>
                    <span class="n">norm</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="n">edge_1</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge_1</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">int_pl_1</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">o</span><span class="o">=</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span>
                    <span class="n">int_pl_2</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="n">o</span><span class="o">=</span><span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span>
                    <span class="n">edge_1_1</span> <span class="o">=</span> <span class="n">intersect_line3d_plane_infinite</span><span class="p">(</span><span class="n">edge_1</span><span class="p">,</span> <span class="n">int_pl_1</span><span class="p">)</span>
                    <span class="n">edge_1_2</span> <span class="o">=</span> <span class="n">intersect_line3d_plane_infinite</span><span class="p">(</span><span class="n">edge_1</span><span class="p">,</span> <span class="n">int_pl_2</span><span class="p">)</span>
                    <span class="n">new_face3d</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">((</span><span class="n">edge_1_1</span><span class="p">,</span> <span class="n">edge_1_2</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">edge_2</span><span class="o">.</span><span class="n">p1</span><span class="p">))</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">new_face3d</span> <span class="o">=</span> <span class="n">new_face3d</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="c1"># find the grouping of points that is not self intersecting</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">new_face3d</span><span class="o">.</span><span class="n">is_self_intersecting</span> <span class="ow">and</span> \
                            <span class="n">new_face3d</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="n">tolerance</span> <span class="o">**</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">vertical_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_face3d</span><span class="p">)</span>

        <span class="c1"># remove duplicated vertices in the resulting vertical faces</span>
        <span class="n">clean_vert_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">vertical_faces</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">clean_vert_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">remove_duplicate_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># invalid sliver face</span>

        <span class="c1"># rebuild the room polyface</span>
        <span class="n">st_v</span> <span class="o">=</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">clean_vert_faces</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">roof_face_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">st_v</span><span class="p">,</span> <span class="n">st_v</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">roof_face_i</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">p_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">clean_vert_faces</span><span class="p">)</span>
        <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">p_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_cap_planar_holes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cap all planar holes in a room_polyface.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_polyface: The non-solid Polyface3D to be patched with planar</span>
<span class="sd">                vertical Faces.</span>
<span class="sd">            roof_face_i: The indices of the polyface that correspond to the roof.</span>
<span class="sd">            tolerance: The distance value for absolute tolerance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The capped Room Polyface3D followed by an updated list of face indices</span>
<span class="sd">            that should become Roofs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># join all of the naked edges into closed loops</span>
        <span class="n">naked_edges</span> <span class="o">=</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">naked_edges</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">naked_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span>
        <span class="n">joined_loops</span> <span class="o">=</span> <span class="n">Polyline3D</span><span class="o">.</span><span class="n">join_segments</span><span class="p">(</span><span class="n">naked_edges</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># create Face3D from any closed planar loops</span>
        <span class="n">cap_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">joined_loops</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">Polyline3D</span><span class="p">)</span> <span class="ow">and</span> <span class="n">loop</span><span class="o">.</span><span class="n">is_closed</span><span class="p">(</span><span class="n">tolerance</span><span class="p">):</span>
                <span class="n">cap_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cap_face</span> <span class="o">=</span> <span class="n">cap_face</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>  <span class="c1"># degenerate geometry</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cap_face</span><span class="o">.</span><span class="n">check_planar</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                    <span class="c1"># try to get the correct plane from non-vertical segments</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">cap_face</span><span class="o">.</span><span class="n">boundary_segments</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">edge</span><span class="o">.</span><span class="n">is_vertical</span><span class="p">(</span><span class="n">tolerance</span><span class="p">):</span>
                            <span class="n">norm</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                            <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">rotate_xy</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
                            <span class="n">plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
                            <span class="n">cap_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">loop</span><span class="o">.</span><span class="n">vertices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">plane</span><span class="p">)</span>
                            <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">cap_face</span><span class="o">.</span><span class="n">check_planar</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">cap_face</span><span class="o">.</span><span class="n">is_self_intersecting</span><span class="p">:</span>
                    <span class="n">spt_p</span> <span class="o">=</span> <span class="n">cap_face</span><span class="o">.</span><span class="n">polygon2d</span>
                    <span class="n">spt_p</span> <span class="o">=</span> <span class="n">spt_p</span><span class="o">.</span><span class="n">split_through_self_intersection</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spt_p</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sp</span><span class="o">.</span><span class="n">is_self_intersecting</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">s_verts</span> <span class="o">=</span> <span class="p">[</span><span class="n">cap_face</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">xy_to_xyz</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">sp</span><span class="p">]</span>
                        <span class="n">n_cap_face</span> <span class="o">=</span> <span class="n">Face3D</span><span class="p">(</span><span class="n">s_verts</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">n_cap_face</span><span class="o">.</span><span class="n">check_planar</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                            <span class="n">cap_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_cap_face</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cap_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cap_face</span><span class="p">)</span>

        <span class="c1"># remove duplicated vertices in the resulting cap faces</span>
        <span class="n">clean_cap_faces</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">cap_faces</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">clean_cap_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">remove_duplicate_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># invalid sliver face</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clean_cap_faces</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span>

        <span class="c1"># rebuild the room polyface</span>
        <span class="n">st_v</span> <span class="o">=</span> <span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">clean_cap_faces</span><span class="p">)</span> <span class="o">+</span> <span class="n">roof_face_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">roof_face_i</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">st_v</span><span class="p">,</span> <span class="n">st_v</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">roof_face_i</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">p_faces</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">room_polyface</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span> <span class="o">+</span> <span class="n">clean_cap_faces</span>
        <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">p_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_separate_disconnected_faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Separate Face3Ds from a room_polyface, with are not connected to the solid.</span>

<span class="sd">        This will also remove all degenerate faces from the Polyface3D geometry.</span>

<span class="sd">        Args:</span>
<span class="sd">            room_polyface: The non-solid Polyface3D for which disconnected faces</span>
<span class="sd">                will be separated out.</span>
<span class="sd">            roof_face_i: The indices of the polyface that correspond to the roof.</span>
<span class="sd">            tolerance: The distance value for absolute tolerance.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple with three elements.</span>

<span class="sd">                * room_polyface -- The new Room Polyface3D.</span>

<span class="sd">                * roof_face_i -- An updated list of roof face indices in the polyface.</span>

<span class="sd">                * ex_wall_i -- A set of wall faces that were excluded in the output.</span>

<span class="sd">                * disconnect_geometry -- A list of Face3D objects, which are</span>
<span class="sd">                    disconnected and were removed from the Polyface3D.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># remove disconnected roof geometries from the Polyface (eg. dormers)</span>
        <span class="n">disconnect_geometry</span><span class="p">,</span> <span class="n">p_faces</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">disconnect_i</span><span class="p">,</span> <span class="n">ex_wall_i</span> <span class="o">=</span> <span class="p">[],</span> <span class="kc">None</span>
        <span class="n">edge_i</span><span class="p">,</span> <span class="n">edge_t</span> <span class="o">=</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">edge_indices</span><span class="p">,</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">edge_types</span>
        <span class="n">zip_obj</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">room_polyface</span><span class="o">.</span><span class="n">face_indices</span><span class="p">,</span> <span class="n">room_polyface</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f_ind</span><span class="p">,</span> <span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">f3d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">zip_obj</span><span class="p">):</span>
            <span class="n">fe_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">face</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">vi</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fi</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ind</span> <span class="o">=</span> <span class="n">edge_i</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">vi</span><span class="p">,</span> <span class="n">fi</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))</span>
                        <span class="n">et</span> <span class="o">=</span> <span class="n">edge_t</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># make sure reversed edge isn&#39;t there</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">ind</span> <span class="o">=</span> <span class="n">edge_i</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">fi</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">vi</span><span class="p">))</span>
                            <span class="n">et</span> <span class="o">=</span> <span class="n">edge_t</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># an edge that was merged in overlapping</span>
                            <span class="n">et</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">fe_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fe_types</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># disconnected face found!</span>
                <span class="n">disconnect_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_ind</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">f3d</span> <span class="o">=</span> <span class="n">f3d</span><span class="o">.</span><span class="n">remove_colinear_vertices</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">p_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f3d</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>  <span class="c1"># degenerate sliver face to be removed</span>
                    <span class="n">disconnect_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_ind</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">disconnect_i</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># process the roof indices</span>
            <span class="n">ex_wall_i</span><span class="p">,</span> <span class="n">max_wall_i</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">sub_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">low_i</span> <span class="o">=</span> <span class="n">roof_face_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_polyface</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">del_i</span> <span class="ow">in</span> <span class="n">disconnect_i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">del_i</span> <span class="o">&gt;</span> <span class="n">low_i</span><span class="p">:</span>
                    <span class="n">sub_i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">del_i</span> <span class="o">&lt;=</span> <span class="n">max_wall_i</span><span class="p">:</span>
                    <span class="n">ex_wall_i</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">del_i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">new_roof_face_i</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">exist_i</span> <span class="ow">in</span> <span class="n">roof_face_i</span><span class="p">:</span>
                <span class="n">pos_ei</span> <span class="o">=</span> <span class="n">exist_i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">room_polyface</span><span class="o">.</span><span class="n">faces</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">del_i</span> <span class="ow">in</span> <span class="n">disconnect_i</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">del_i</span> <span class="o">==</span> <span class="n">pos_ei</span><span class="p">:</span>  <span class="c1"># deleted roof</span>
                        <span class="n">sub_i</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># roof that was not removed</span>
                    <span class="n">new_roof_face_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">exist_i</span> <span class="o">+</span> <span class="n">sub_i</span><span class="p">)</span>
            <span class="n">roof_face_i</span> <span class="o">=</span> <span class="n">new_roof_face_i</span>
        <span class="c1"># rebuild the Polyface3D</span>
        <span class="n">disconnect_geometry</span> <span class="o">=</span> <span class="p">[</span><span class="n">room_polyface</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="n">f_ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">f_ind</span> <span class="ow">in</span> <span class="n">disconnect_i</span><span class="p">]</span>
        <span class="n">room_polyface</span> <span class="o">=</span> <span class="n">Polyface3D</span><span class="o">.</span><span class="n">from_faces</span><span class="p">(</span><span class="n">p_faces</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">room_polyface</span><span class="p">,</span> <span class="n">roof_face_i</span><span class="p">,</span> <span class="n">ex_wall_i</span><span class="p">,</span> <span class="n">disconnect_geometry</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_wall_assigned_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">obj_name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check an input that gets assigned to all of the walls of the Room.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">value</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input </span><span class="si">{}</span><span class="s1"> must be a list or a tuple&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj_name</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="s1">&#39;Input </span><span class="si">{}</span><span class="s1"> length must be the &#39;</span> \
            <span class="s1">&#39;same as the number of floor_segments. </span><span class="si">{}</span><span class="s1"> != </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">obj_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_flip_wall_assigned_objects</span><span class="p">(</span><span class="n">original_geo</span><span class="p">,</span> <span class="n">bcs</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span> <span class="n">shd_pars</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get arrays of wall-assigned parameters that are flipped/reversed.</span>

<span class="sd">        This method accounts for the case that a floor geometry has holes in it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># go through the boundary and ensure detailed parameters are flipped</span>
        <span class="n">new_bcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_win_pars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_shd_pars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">original_geo</span><span class="o">.</span><span class="n">boundary_segments</span><span class="p">):</span>
            <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">win_par</span> <span class="o">=</span> <span class="n">win_pars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">win_par</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
                <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_par</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">length</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_win_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_par</span><span class="p">)</span>
            <span class="n">new_shd_pars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shd_pars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># reverse the lists of wall-assigned objects on the floor boundary</span>
        <span class="n">new_bcs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">new_win_pars</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="n">new_shd_pars</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="c1"># add any objects related to the holes</span>
        <span class="k">if</span> <span class="n">original_geo</span><span class="o">.</span><span class="n">has_holes</span><span class="p">:</span>
            <span class="n">bound_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">original_geo</span><span class="o">.</span><span class="n">boundary</span><span class="p">)</span>
            <span class="n">new_bcs</span> <span class="o">=</span> <span class="n">new_bcs</span> <span class="o">+</span> <span class="n">bcs</span><span class="p">[</span><span class="n">bound_len</span><span class="p">:]</span>
            <span class="n">new_win_pars</span> <span class="o">=</span> <span class="n">new_win_pars</span> <span class="o">+</span> <span class="n">win_pars</span><span class="p">[</span><span class="n">bound_len</span><span class="p">:]</span>
            <span class="n">new_shd_pars</span> <span class="o">=</span> <span class="n">new_shd_pars</span> <span class="o">+</span> <span class="n">shd_pars</span><span class="p">[</span><span class="n">bound_len</span><span class="p">:]</span>

        <span class="c1"># return the flipped lists</span>
        <span class="k">return</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win_pars</span><span class="p">,</span> <span class="n">new_shd_pars</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_split_walls_along_height</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hb_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split adjacent walls to ensure matching surface areas in to_honeybee workflow.</span>

<span class="sd">        Args:</span>
<span class="sd">            hb_room: A non-split Honeybee Room representation of this Room2D.</span>
<span class="sd">            tolerance: The minimum distance in z values of floor_height and</span>
<span class="sd">                floor_to_ceiling_height at which adjacent Faces will be split.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the boundary condition to be used for adiabatic cases</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ad_bc</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">adiabatic</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">ad_bc</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>  <span class="c1"># honeybee_energy is not loaded; no adiabatic BC</span>
        <span class="c1"># loop through the walls and split adjacent ones</span>
        <span class="n">new_faces</span> <span class="o">=</span> <span class="p">[</span><span class="n">hb_room</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">):</span>
            <span class="n">face</span> <span class="o">=</span> <span class="n">hb_room</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">new_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">adj_rm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">room_by_identifier</span><span class="p">(</span>
                        <span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># missing adjacency in Story; just pass invalid BC</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">flr_diff</span> <span class="o">=</span> <span class="n">adj_rm</span><span class="o">.</span><span class="n">floor_height</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_height</span>
                <span class="n">ciel_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ceiling_height</span> <span class="o">-</span> <span class="n">adj_rm</span><span class="o">.</span><span class="n">ceiling_height</span>
                <span class="k">if</span> <span class="n">flr_diff</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> <span class="n">ciel_diff</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># No need to split the surface along its height</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">flr_diff</span> <span class="o">&gt;</span> <span class="n">tolerance</span> <span class="ow">and</span> <span class="n">ciel_diff</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># split the face into to 3 smaller faces along its height</span>
                    <span class="n">lseg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">lseg</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">mid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">ciel_diff</span> <span class="o">-</span> <span class="n">flr_diff</span>
                    <span class="k">if</span> <span class="n">mid_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">vec1</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flr_diff</span><span class="p">)</span>
                    <span class="n">vec2</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">ciel_diff</span><span class="p">)</span>
                    <span class="n">below</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">vec1</span><span class="p">)</span>
                    <span class="n">mid</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span>
                        <span class="n">lseg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vec1</span><span class="p">),</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid_dist</span><span class="p">))</span>
                    <span class="n">above</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span>
                        <span class="n">lseg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vec2</span><span class="p">),</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ciel_diff</span><span class="p">))</span>
                    <span class="n">mid_face</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                    <span class="n">mid_face</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">mid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_reassign_split_windows</span><span class="p">(</span><span class="n">mid_face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">below_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_Below&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="n">below</span><span class="p">)</span>
                    <span class="n">above_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_Above&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="n">above</span><span class="p">)</span>
                    <span class="n">below_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">ad_bc</span>
                    <span class="n">above_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">ad_bc</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">:</span>
                        <span class="n">below_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span>
                    <span class="k">if</span> <span class="n">adj_rm</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">:</span>
                        <span class="n">above_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_reassign_above_windows</span><span class="p">(</span>
                            <span class="n">above_face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">ciel_diff</span><span class="p">)</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">below_face</span><span class="p">,</span> <span class="n">mid_face</span><span class="p">,</span> <span class="n">above_face</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">flr_diff</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># split the face into to 2 smaller faces along its height</span>
                    <span class="n">lseg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">lseg</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">mid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">flr_diff</span>
                    <span class="k">if</span> <span class="n">mid_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">vec1</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">flr_diff</span><span class="p">)</span>
                    <span class="n">below</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">vec1</span><span class="p">)</span>
                    <span class="n">mid</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span>
                        <span class="n">lseg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vec1</span><span class="p">),</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid_dist</span><span class="p">))</span>
                    <span class="n">mid_face</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                    <span class="n">mid_face</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">mid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_reassign_split_windows</span><span class="p">(</span><span class="n">mid_face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">below_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_Below&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="n">below</span><span class="p">)</span>
                    <span class="n">below_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">ad_bc</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_ground_contact</span><span class="p">:</span>
                        <span class="n">below_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">below_face</span><span class="p">,</span> <span class="n">mid_face</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">ciel_diff</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
                    <span class="c1"># split the face into to 2 smaller faces along its height</span>
                    <span class="n">lseg</span> <span class="o">=</span> <span class="n">LineSegment3D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="n">face</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">lseg</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">mid_dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">ciel_diff</span>
                    <span class="k">if</span> <span class="n">mid_dist</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">vec1</span> <span class="o">=</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid_dist</span><span class="p">)</span>
                    <span class="n">mid</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">vec1</span><span class="p">)</span>
                    <span class="n">above</span> <span class="o">=</span> <span class="n">Face3D</span><span class="o">.</span><span class="n">from_extrusion</span><span class="p">(</span>
                        <span class="n">lseg</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">vec1</span><span class="p">),</span> <span class="n">Vector3D</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ciel_diff</span><span class="p">))</span>
                    <span class="n">mid_face</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
                    <span class="n">mid_face</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">mid</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_reassign_split_windows</span><span class="p">(</span><span class="n">mid_face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                    <span class="n">above_face</span> <span class="o">=</span> <span class="n">Face</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_Above&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">identifier</span><span class="p">),</span> <span class="n">above</span><span class="p">)</span>
                    <span class="n">above_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">ad_bc</span>
                    <span class="k">if</span> <span class="n">adj_rm</span><span class="o">.</span><span class="n">is_top_exposed</span><span class="p">:</span>
                        <span class="n">above_face</span><span class="o">.</span><span class="n">boundary_condition</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_reassign_above_windows</span><span class="p">(</span>
                            <span class="n">above_face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span> <span class="o">-</span> <span class="n">ciel_diff</span><span class="p">)</span>
                    <span class="n">new_faces</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">mid_face</span><span class="p">,</span> <span class="n">above_face</span><span class="p">])</span>
        <span class="n">new_faces</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hb_room</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_faces</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reassign_split_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-assign WindowParameters to a middle base surface that has been split.</span>

<span class="sd">        Args:</span>
<span class="sd">            face: Honeybee Face to which windows will be re-assigned.</span>
<span class="sd">            i: The index of the window_parameters that correspond to the face</span>
<span class="sd">            tolerance: The tolerance, which will be used to re-assign windows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">glz_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">glz_par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">face</span><span class="o">.</span><span class="n">remove_sub_faces</span><span class="p">()</span>
            <span class="n">glz_par</span><span class="o">.</span><span class="n">add_window_to_face</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_reassign_above_windows</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">face</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">shift_dist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-assign WindowParameters to an above surface that has been split.</span>

<span class="sd">        Args:</span>
<span class="sd">            face: Honeybee Face to which windows will be re-assigned.</span>
<span class="sd">            i: The index of the window_parameters that correspond to the face</span>
<span class="sd">            tolerance: The tolerance, which will be used to re-assign windows.</span>
<span class="sd">            shift_dist: Optional distance to be used to vertically shift detailed</span>
<span class="sd">                window parameters as they are applied</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">glz_par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">glz_par</span><span class="p">,</span> <span class="n">_AsymmetricBase</span><span class="p">):</span>
            <span class="n">face</span><span class="o">.</span><span class="n">remove_sub_faces</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">shift_dist</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">glz_par</span> <span class="o">=</span> <span class="n">glz_par</span><span class="o">.</span><span class="n">shift_vertically</span><span class="p">(</span><span class="o">-</span><span class="n">shift_dist</span><span class="p">)</span>
            <span class="n">glz_par</span><span class="o">.</span><span class="n">add_window_to_face</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_segment_wall_face</span><span class="p">(</span><span class="n">room</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a Wall Face that corresponds with a certain wall segment.</span>

<span class="sd">        Args:</span>
<span class="sd">            room: A Honeybee Room from which a wall Face will be returned.</span>
<span class="sd">            segment: A LineSegment3D along one of the walls of the room.</span>
<span class="sd">            tolerance: The maximum difference between values at which point vertices</span>
<span class="sd">                are considered to be the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">faces</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">face</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="p">(</span><span class="n">Wall</span><span class="p">,</span> <span class="n">AirBoundary</span><span class="p">)):</span>
                <span class="n">fg</span> <span class="o">=</span> <span class="n">face</span><span class="o">.</span><span class="n">geometry</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">verts</span> <span class="o">=</span> <span class="n">fg</span><span class="o">.</span><span class="n">_remove_colinear</span><span class="p">(</span>
                        <span class="n">fg</span><span class="o">.</span><span class="n">_boundary</span><span class="p">,</span> <span class="n">fg</span><span class="o">.</span><span class="n">boundary_polygon2d</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">segment</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                        <span class="n">p2</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">p2</span>
                        <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">verts</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">p2</span><span class="o">.</span><span class="n">is_equivalent</span><span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
                                <span class="k">return</span> <span class="n">face</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_match_and_transfer_wall_props</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_room</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span>
                                       <span class="n">transfer_air_bounds</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transfer wall properties of matching segments between this room and a new one.</span>

<span class="sd">        All wall properties are transferred exactly as they are when segments</span>
<span class="sd">        are perfectly equal between this room and the new room. When segments</span>
<span class="sd">        are colinear/overlapping but the segment on the new_room is shorter than</span>
<span class="sd">        that on this room, the wall properties on this room will be split in</span>
<span class="sd">        order to assign them correctly to the new room. When a given segment</span>
<span class="sd">        of the new_room is not overlapping/colinear with any segment of this</span>
<span class="sd">        room, it will be given default properties with an outdoor boundary</span>
<span class="sd">        condition.</span>

<span class="sd">        This all makes this method suitable for preserving properties across</span>
<span class="sd">        operations that trim or split the original room to make the new_room.</span>

<span class="sd">        Args:</span>
<span class="sd">            new_room: An new Room2D to which wall properties will be transferred.</span>
<span class="sd">            tolerance: The minimum distance at which points are considered distinct.</span>
<span class="sd">            transfer_air_bounds: Boolean for whether the air boundary properties</span>
<span class="sd">                should be transferred. (Default: False).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the relevant original segments by copying the lists on this Room2D</span>
        <span class="n">rel_segs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span>
        <span class="n">rel_win</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span>
        <span class="n">rel_shd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span>
        <span class="n">rel_abs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">air_boundaries</span>
        <span class="n">rel_bcs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">rel_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Surface boundary conditions can mess up window splitting</span>
                <span class="n">rel_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
        <span class="c1"># build up new lists of parameters if the segments match</span>
        <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rel_segs</span><span class="p">):</span>
            <span class="n">m_win_segs</span><span class="p">,</span> <span class="n">m_i</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seg2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_room</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                        <span class="n">seg1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">seg2</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>  <span class="c1"># colinear</span>
                    <span class="n">new_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_bcs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">new_shd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_shd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">new_abs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_abs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">m_win_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg2</span><span class="p">)</span>
                    <span class="n">m_i</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="c1"># split the window parameters across the matched segments</span>
            <span class="n">wp_par_to_split</span> <span class="o">=</span> <span class="n">rel_win</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">wp_par_to_split</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">m_i</span><span class="p">:</span>
                    <span class="n">new_win</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">full_len</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">sg</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">sg</span> <span class="ow">in</span> <span class="n">m_win_segs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">seg1</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">full_len</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>  <span class="c1"># all segments accounted</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># no change to the segment</span>
                        <span class="n">new_win</span><span class="p">[</span><span class="n">m_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">wp_par_to_split</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># windows to be split</span>
                        <span class="n">split_par</span> <span class="o">=</span> <span class="n">wp_par_to_split</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">m_win_segs</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w_par</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">m_i</span><span class="p">,</span> <span class="n">split_par</span><span class="p">):</span>
                            <span class="n">new_win</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w_par</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># not all segment accounted; trim each window par from original</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n_seg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">m_i</span><span class="p">,</span> <span class="n">m_win_segs</span><span class="p">):</span>
                        <span class="n">new_win</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wp_par_to_split</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">seg1</span><span class="p">,</span> <span class="n">n_seg</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># assign the matched properties to the new room</span>
        <span class="n">final_bcs</span><span class="p">,</span> <span class="n">final_win</span><span class="p">,</span> <span class="n">final_shd</span><span class="p">,</span> <span class="n">final_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_room</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">final_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">final_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_win</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">final_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_shd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">final_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>  <span class="c1"># segment not matched to any in existing room</span>
                <span class="n">final_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
                <span class="n">final_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">final_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">final_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">boundary_conditions</span> <span class="o">=</span> <span class="n">final_bcs</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">window_parameters</span> <span class="o">=</span> <span class="n">final_win</span>
        <span class="n">new_room</span><span class="o">.</span><span class="n">shading_parameters</span> <span class="o">=</span> <span class="n">final_shd</span>
        <span class="k">if</span> <span class="n">transfer_air_bounds</span><span class="p">:</span>
            <span class="n">new_room</span><span class="o">.</span><span class="n">air_boundaries</span> <span class="o">=</span> <span class="n">final_abs</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_remove_colinear_props</span><span class="p">(</span>
            <span class="n">pts_3d</span><span class="p">,</span> <span class="n">pts_2d</span><span class="p">,</span> <span class="n">segs_2d</span><span class="p">,</span> <span class="n">bound_cds</span><span class="p">,</span> <span class="n">win_pars</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove colinear vertices across a boundary while merging window properties.&quot;&quot;&quot;</span>
        <span class="n">new_vertices</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_w_par</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># track the number of vertices being skipped/removed</span>
        <span class="n">first_skip</span><span class="p">,</span> <span class="n">is_first</span><span class="p">,</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span>  <span class="c1"># track the number skipped from first vertex</span>
        <span class="n">m_segs</span><span class="p">,</span> <span class="n">m_bcs</span><span class="p">,</span> <span class="n">m_w_par</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="c1"># loop through vertices and remove all cases of colinear verts</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">_v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pts_2d</span><span class="p">):</span>
            <span class="n">m_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segs_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">m_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bound_cds</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">m_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">win_pars</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">_v2</span><span class="p">,</span> <span class="n">_v1</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">skip</span><span class="p">],</span> <span class="n">pts_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="n">_v2</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">_v1</span><span class="p">)</span> <span class="o">+</span> <span class="n">_v1</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="o">+</span> <span class="n">_v</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">_v2</span><span class="p">)</span>
            <span class="n">b_dist</span> <span class="o">=</span> <span class="n">_v</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">_v2</span><span class="p">)</span>
            <span class="n">b_dist</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="k">if</span> <span class="n">b_dist</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="k">else</span> <span class="n">b_dist</span>
            <span class="n">tri_tol</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_dist</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># area of triangle with tolerance height</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tri_tol</span><span class="p">:</span>  <span class="c1"># vertex is not colinear; add vertex and merge</span>
                <span class="n">new_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Ground</span><span class="p">)</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">m_bcs</span><span class="p">):</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">wp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">m_w_par</span><span class="p">):</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_w_par</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_w_par</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">new_wp</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">m_w_par</span><span class="p">,</span> <span class="n">m_segs</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">)</span>
                        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_wp</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">ground</span><span class="p">)</span>
                    <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">is_first</span><span class="p">:</span>
                    <span class="n">is_first</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">first_skip</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">m_bcs</span><span class="p">,</span> <span class="n">m_w_par</span><span class="p">,</span> <span class="n">m_segs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># vertex is colinear; continue</span>
                <span class="n">skip</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># catch the case of degenerate rooms</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_vertices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># catch case of last few vertices being equal but distinct from first point</span>
        <span class="k">if</span> <span class="n">skip</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">first_skip</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">_v2</span><span class="p">,</span> <span class="n">_v1</span><span class="p">,</span> <span class="n">_v</span> <span class="o">=</span> <span class="n">pts_2d</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="n">skip</span><span class="p">],</span> <span class="n">pts_2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">pts_2d</span><span class="p">[</span><span class="n">first_skip</span><span class="p">]</span>
            <span class="n">_a</span> <span class="o">=</span> <span class="n">_v2</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">_v1</span><span class="p">)</span> <span class="o">+</span> <span class="n">_v1</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">_v</span><span class="p">)</span> <span class="o">+</span> <span class="n">_v</span><span class="o">.</span><span class="n">determinant</span><span class="p">(</span><span class="n">_v2</span><span class="p">)</span>
            <span class="n">b_dist</span> <span class="o">=</span> <span class="n">_v</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">_v2</span><span class="p">)</span>
            <span class="n">b_dist</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="k">if</span> <span class="n">b_dist</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="k">else</span> <span class="n">b_dist</span>
            <span class="n">tri_tol</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_dist</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># area of triangle with tolerance height</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bound_cds</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="n">skip</span><span class="p">],</span> <span class="n">Ground</span><span class="p">):</span>
                <span class="n">new_bc</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span>
                <span class="n">m_w_par</span> <span class="o">=</span> <span class="n">win_pars</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="n">skip</span><span class="p">:]</span> <span class="o">+</span> <span class="n">win_pars</span><span class="p">[:</span><span class="n">first_skip</span><span class="p">]</span>
                <span class="n">m_segs</span> <span class="o">=</span> <span class="n">segs_2d</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span> <span class="o">-</span> <span class="n">skip</span><span class="p">:]</span> <span class="o">+</span> <span class="n">segs_2d</span><span class="p">[:</span><span class="n">first_skip</span><span class="p">]</span>
                <span class="n">new_wp</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">m_w_par</span><span class="p">,</span> <span class="n">m_segs</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">)</span>
                <span class="n">new_wp</span> <span class="o">=</span> <span class="n">new_wp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_bc</span> <span class="o">=</span> <span class="n">bcs</span><span class="o">.</span><span class="n">ground</span>
                <span class="n">new_wp</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">tri_tol</span><span class="p">:</span>
                <span class="n">new_vertices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pts_3d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_bc</span><span class="p">)</span>
                <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_wp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_w_par</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_wp</span>
        <span class="k">elif</span> <span class="n">skip</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">w_par_for_merge</span> <span class="o">=</span> <span class="n">m_w_par</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_w_par</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">wp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="n">w_par_for_merge</span><span class="p">):</span>
                <span class="n">segs_for_merge</span> <span class="o">=</span> <span class="n">m_segs</span> <span class="o">+</span> <span class="p">[</span><span class="n">segs_2d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">new_w_par</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">DetailedWindows</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">w_par_for_merge</span><span class="p">,</span> <span class="n">segs_for_merge</span><span class="p">,</span> <span class="n">ftc_height</span><span class="p">)</span>
        <span class="c1"># move the first properties to the end to match with the vertices</span>
        <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_bcs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">new_w_par</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_w_par</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_vertices</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_w_par</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_adjacency_grouping</span><span class="p">(</span><span class="n">rooms</span><span class="p">,</span> <span class="n">adj_finding_function</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group Room2Ds together according to an adjacency finding function.</span>

<span class="sd">        Args:</span>
<span class="sd">            rooms: A list of Room2Ds to be grouped by their adjacency.</span>
<span class="sd">            adj_finding_function: A function that denotes which rooms are adjacent</span>
<span class="sd">                to another.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of list with each sub-list containing rooms that share adjacencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create a room lookup table and duplicate the list of rooms</span>
        <span class="n">room_lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">rm</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">rm</span> <span class="k">for</span> <span class="n">rm</span> <span class="ow">in</span> <span class="n">rooms</span><span class="p">}</span>
        <span class="n">all_rooms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rooms</span><span class="p">)</span>
        <span class="n">adj_network</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># loop through the rooms and find air boundary adjacencies</span>
        <span class="k">for</span> <span class="n">room</span> <span class="ow">in</span> <span class="n">all_rooms</span><span class="p">:</span>
            <span class="n">adj_ids</span> <span class="o">=</span> <span class="n">adj_finding_function</span><span class="p">(</span><span class="n">room</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># a room that is its own solar enclosure</span>
                <span class="n">adj_network</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">room</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># there are other adjacent rooms to find</span>
                <span class="n">local_network</span> <span class="o">=</span> <span class="p">[</span><span class="n">room</span><span class="p">]</span>
                <span class="n">local_ids</span><span class="p">,</span> <span class="n">first_id</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">adj_ids</span><span class="p">),</span> <span class="n">room</span><span class="o">.</span><span class="n">identifier</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">adj_ids</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># add the current rooms to the local network</span>
                    <span class="n">adj_objs</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">rm_id</span> <span class="ow">in</span> <span class="n">adj_ids</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">adj_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">room_lookup</span><span class="p">[</span><span class="n">rm_id</span><span class="p">])</span>
                        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">pass</span>  <span class="c1"># not a Room2D that is in the input</span>
                    <span class="n">local_network</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">adj_objs</span><span class="p">)</span>
                    <span class="n">adj_ids</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># reset the list of new adjacencies</span>
                    <span class="c1"># find any rooms that are adjacent to the adjacent rooms</span>
                    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">adj_objs</span><span class="p">:</span>
                        <span class="n">all_new_ids</span> <span class="o">=</span> <span class="n">adj_finding_function</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                        <span class="n">new_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">rid</span> <span class="k">for</span> <span class="n">rid</span> <span class="ow">in</span> <span class="n">all_new_ids</span>
                                   <span class="k">if</span> <span class="n">rid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">local_ids</span> <span class="ow">and</span> <span class="n">rid</span> <span class="o">!=</span> <span class="n">first_id</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">rm_id</span> <span class="ow">in</span> <span class="n">new_ids</span><span class="p">:</span>
                            <span class="n">local_ids</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">rm_id</span><span class="p">)</span>
                        <span class="n">adj_ids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_ids</span><span class="p">)</span>
                <span class="c1"># after the local network is understood, clean up duplicated rooms</span>
                <span class="n">adj_network</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">local_network</span><span class="p">)</span>
                <span class="n">i_to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">room_obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_rooms</span><span class="p">)</span>
                               <span class="k">if</span> <span class="n">room_obj</span><span class="o">.</span><span class="n">identifier</span> <span class="ow">in</span> <span class="n">local_ids</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">i_to_remove</span><span class="p">):</span>
                    <span class="n">all_rooms</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">adj_network</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_adjacent_rooms</span><span class="p">(</span><span class="n">room</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the identifiers of all rooms with adjacency to a room.&quot;&quot;&quot;</span>
        <span class="n">adj_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="n">room</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">adj_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">adj_rooms</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_find_adjacent_air_boundary_rooms</span><span class="p">(</span><span class="n">room</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the identifiers of all rooms with air boundary adjacency to a room.&quot;&quot;&quot;</span>
        <span class="n">adj_rooms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bc</span><span class="p">,</span> <span class="n">ab</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">room</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">,</span> <span class="n">room</span><span class="o">.</span><span class="n">air_boundaries</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ab</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bc</span><span class="p">,</span> <span class="n">Surface</span><span class="p">):</span>
                <span class="n">adj_rooms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">boundary_condition_objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">adj_rooms</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_segments_along_polygon</span><span class="p">(</span>
            <span class="n">polygon</span><span class="p">,</span> <span class="n">rel_segs</span><span class="p">,</span> <span class="n">rel_bcs</span><span class="p">,</span> <span class="n">rel_win</span><span class="p">,</span> <span class="n">rel_shd</span><span class="p">,</span> <span class="n">rel_abs</span><span class="p">,</span>
            <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">,</span> <span class="n">new_flr_height</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the segments along a polygon and add their properties to new lists.&quot;&quot;&quot;</span>
        <span class="n">new_segs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">polygon</span><span class="o">.</span><span class="n">segments</span><span class="p">:</span>
            <span class="n">seg_segs</span><span class="p">,</span> <span class="n">seg_bcs</span><span class="p">,</span> <span class="n">seg_win</span><span class="p">,</span> <span class="n">seg_shd</span><span class="p">,</span> <span class="n">seg_abs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="c1"># collect the room segments and properties along the boundary</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rel_segs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span> <span class="ow">and</span> \
                        <span class="n">seg</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">rs</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>  <span class="c1"># colinear</span>
                    <span class="n">seg_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rs</span><span class="p">)</span>
                    <span class="n">seg_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">seg_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel_win</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">seg_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel_shd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">seg_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rel_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg_segs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Room2D</span><span class="o">.</span><span class="n">_add_dummy_segment</span><span class="p">(</span>
                    <span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">new_segs</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="c1"># sort the Room2D segments along the polygon segment</span>
            <span class="n">seg_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">p1</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seg_segs</span><span class="p">]</span>
            <span class="n">sort_ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">seg_dists</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seg_dists</span><span class="p">))))]</span>
            <span class="n">seg_segs</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="n">seg_bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="n">seg_win</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_win</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="n">seg_shd</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_shd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="n">seg_abs</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg_abs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sort_ind</span><span class="p">]</span>
            <span class="c1"># identify any gaps and add dummy segments</span>
            <span class="n">p1_dists</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">seg_dists</span><span class="p">)</span>
            <span class="n">p2_dists</span> <span class="o">=</span> <span class="p">[</span><span class="n">seg</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seg_segs</span><span class="p">]</span>
            <span class="n">last_d</span><span class="p">,</span> <span class="n">last_seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">p1d</span><span class="p">,</span> <span class="n">p2d</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">p1_dists</span><span class="p">,</span> <span class="n">p2_dists</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">p1d</span> <span class="o">&lt;</span> <span class="n">last_d</span> <span class="o">-</span> <span class="n">tol</span><span class="p">:</span>  <span class="c1"># overlapping segment; ignore it</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">p1d</span> <span class="o">&gt;</span> <span class="n">last_d</span> <span class="o">+</span> <span class="n">tol</span><span class="p">:</span>  <span class="c1"># add a dummy segment for the gap</span>
                    <span class="n">st_pt</span> <span class="o">=</span> <span class="n">last_seg</span><span class="o">.</span><span class="n">p2</span> <span class="k">if</span> <span class="n">last_seg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">seg</span><span class="o">.</span><span class="n">p1</span>
                    <span class="n">Room2D</span><span class="o">.</span><span class="n">_add_dummy_segment</span><span class="p">(</span>
                        <span class="n">st_pt</span><span class="p">,</span> <span class="n">seg_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">new_segs</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span>
                        <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">)</span>
                <span class="c1"># add the segment</span>
                <span class="n">new_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_segs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_bcs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_win</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_shd</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seg_abs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">last_d</span> <span class="o">=</span> <span class="n">p2d</span>
                <span class="n">last_seg</span> <span class="o">=</span> <span class="n">seg_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">Point3D</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">p1</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">new_flr_height</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">new_segs</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_add_dummy_segment</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">new_segs</span><span class="p">,</span> <span class="n">new_bcs</span><span class="p">,</span> <span class="n">new_win</span><span class="p">,</span> <span class="n">new_shd</span><span class="p">,</span> <span class="n">new_abs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a dummy segment to lists of properties that are being built.&quot;&quot;&quot;</span>
        <span class="n">new_segs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LineSegment2D</span><span class="o">.</span><span class="n">from_end_points</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">))</span>
        <span class="n">new_bcs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bcs</span><span class="o">.</span><span class="n">outdoors</span><span class="p">)</span>
        <span class="n">new_win</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_shd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">new_abs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_seg_on_guide_lines</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="n">guide_lines</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate whether a segment lies along a sed of guide lines.</span>

<span class="sd">        Args:</span>
<span class="sd">            segment: A LineSegment2D to be evaluated.</span>
<span class="sd">            guide_lines: A list of LineSegment2D objects for guide segments.</span>
<span class="sd">            tolerance: The minimum difference between the coordinate values of two</span>
<span class="sd">                faces at which they can be considered toughing. (Default: 0.01,</span>
<span class="sd">                suitable for objects in meters).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">segment</span><span class="o">.</span><span class="n">p2</span>
        <span class="k">for</span> <span class="n">g_line</span> <span class="ow">in</span> <span class="n">guide_lines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">g_line</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span> <span class="ow">and</span> \
                    <span class="n">g_line</span><span class="o">.</span><span class="n">distance_to_point</span><span class="p">(</span><span class="n">pt2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_intersect_line2d_infinite</span><span class="p">(</span><span class="n">line_ray_a</span><span class="p">,</span> <span class="n">line_ray_b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the intersection between a Ray2Ds extended infinitely.</span>

<span class="sd">        Args:</span>
<span class="sd">            line_ray_a: A Ray2D object.</span>
<span class="sd">            line_ray_b: Another Ray2D object.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Point2D of intersection if it exists. None if lines are parallel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span>
        <span class="n">ua</span> <span class="o">=</span> <span class="p">(</span><span class="n">line_ray_b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">dy</span> <span class="o">-</span> <span class="n">line_ray_b</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">Point2D</span><span class="p">(</span><span class="n">line_ray_a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">ua</span> <span class="o">*</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
                       <span class="n">line_ray_a</span><span class="o">.</span><span class="n">p</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">ua</span> <span class="o">*</span> <span class="n">line_ray_a</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">new_r</span> <span class="o">=</span> <span class="n">Room2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_geometry</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">floor_to_ceiling_height</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_boundary_conditions</span><span class="p">[:])</span>  <span class="c1"># copy boundary condition list</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_display_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display_name</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_user_data</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="n">new_wp</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">wp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window_parameters</span><span class="p">:</span>
            <span class="n">nwp</span> <span class="o">=</span> <span class="n">wp</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span> <span class="k">if</span> <span class="n">wp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">new_wp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nwp</span><span class="p">)</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_window_parameters</span> <span class="o">=</span> <span class="n">new_wp</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_shading_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shading_parameters</span><span class="p">[:]</span>  <span class="c1"># copy shading list</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span><span class="p">[:]</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_air_boundaries</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_is_ground_contact</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_ground_contact</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_is_top_exposed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_top_exposed</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_has_floor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_floor</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_has_ceiling</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_ceiling</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ceiling_plenum_depth</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_floor_plenum_depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_floor_plenum_depth</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_zone</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zone</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span> \
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skylight_parameters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_abridged_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_abridged_properties</span>
        <span class="n">new_r</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">_duplicate_extension_attr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_r</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_segment_count</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floor_segments</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Room2D: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">display_name</span></div>

</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2025, Ladybug Tools.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 8.0.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>